{"version":3,"file":"lodGeometryWorker-CPNS1EKh.js","sources":["../src/workers/lodGeometryWorker.ts"],"sourcesContent":["// LOD Geometry Worker - builds LOD terrain geometry off the main thread\r\n// Optimized: pre-computed normalizations, cached surface data, reduced passes\r\n\r\n// Vector3-like operations using plain objects\r\ninterface Vec3 {\r\n  x: number;\r\n  y: number;\r\n  z: number;\r\n}\r\n\r\n// Note: Vector operations are inlined in hot loops to avoid function call overhead\r\n// and object allocations. The raw x/y/z math is faster than helper functions.\r\n\r\n// Torch data for vertex lighting calculation\r\ninterface TorchData {\r\n  position: Vec3;\r\n  range: number;\r\n  intensity: number;\r\n}\r\n\r\n// Calculate torch light contribution at a point\r\nfunction calculateTorchLight(x: number, y: number, z: number, torches: TorchData[]): number {\r\n  let totalLight = 0;\r\n  for (const torch of torches) {\r\n    const dx = x - torch.position.x;\r\n    const dy = y - torch.position.y;\r\n    const dz = z - torch.position.z;\r\n    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n\r\n    if (dist < torch.range) {\r\n      // Quadratic falloff matching the shader formula\r\n      const attenuation = 1.0 / (1.0 + 2.0 * dist * dist / (torch.range * torch.range));\r\n      totalLight += attenuation * torch.intensity;\r\n    }\r\n  }\r\n  return Math.min(totalLight, 1.5); // Cap at 1.5 like the shader\r\n}\r\n\r\n// Per-chunk geometry buffers\r\ninterface ChunkGeometry {\r\n  grassPositions: number[];\r\n  grassNormals: number[];\r\n  grassUvs: number[];\r\n  grassSkyLight: number[];  // Sky light attribute for terrain shader\r\n  grassTorchLight: number[];  // Torch light attribute for terrain shader\r\n  grassIndices: number[];\r\n  grassVertexOffset: number;\r\n  dirtPositions: number[];\r\n  dirtNormals: number[];\r\n  dirtUvs: number[];\r\n  dirtSkyLight: number[];\r\n  dirtTorchLight: number[];\r\n  dirtIndices: number[];\r\n  dirtVertexOffset: number;\r\n  stonePositions: number[];\r\n  stoneNormals: number[];\r\n  stoneUvs: number[];\r\n  stoneSkyLight: number[];\r\n  stoneTorchLight: number[];\r\n  stoneIndices: number[];\r\n  stoneVertexOffset: number;\r\n  sandPositions: number[];\r\n  sandNormals: number[];\r\n  sandUvs: number[];\r\n  sandSkyLight: number[];\r\n  sandTorchLight: number[];\r\n  sandIndices: number[];\r\n  sandVertexOffset: number;\r\n  woodPositions: number[];\r\n  woodNormals: number[];\r\n  woodUvs: number[];\r\n  woodSkyLight: number[];\r\n  woodTorchLight: number[];\r\n  woodIndices: number[];\r\n  woodVertexOffset: number;\r\n  waterPositions: number[];\r\n  waterNormals: number[];\r\n  waterUvs: number[];\r\n  waterIndices: number[];\r\n  waterVertexOffset: number;\r\n  sidePositions: number[];\r\n  sideNormals: number[];\r\n  sideUvs: number[];\r\n  sideSkyLight: number[];\r\n  sideTorchLight: number[];\r\n  sideIndices: number[];\r\n  sideVertexOffset: number;\r\n  waterSidePositions: number[];\r\n  waterSideNormals: number[];\r\n  waterSideUvs: number[];\r\n  waterSideIndices: number[];\r\n  waterSideVertexOffset: number;\r\n  // Snow biome buffers\r\n  snowPositions: number[];\r\n  snowNormals: number[];\r\n  snowUvs: number[];\r\n  snowSkyLight: number[];\r\n  snowTorchLight: number[];\r\n  snowIndices: number[];\r\n  snowVertexOffset: number;\r\n  icePositions: number[];\r\n  iceNormals: number[];\r\n  iceUvs: number[];\r\n  iceSkyLight: number[];\r\n  iceTorchLight: number[];\r\n  iceIndices: number[];\r\n  iceVertexOffset: number;\r\n}\r\n\r\nfunction createEmptyChunkGeometry(): ChunkGeometry {\r\n  return {\r\n    grassPositions: [], grassNormals: [], grassUvs: [], grassSkyLight: [], grassTorchLight: [], grassIndices: [], grassVertexOffset: 0,\r\n    dirtPositions: [], dirtNormals: [], dirtUvs: [], dirtSkyLight: [], dirtTorchLight: [], dirtIndices: [], dirtVertexOffset: 0,\r\n    stonePositions: [], stoneNormals: [], stoneUvs: [], stoneSkyLight: [], stoneTorchLight: [], stoneIndices: [], stoneVertexOffset: 0,\r\n    sandPositions: [], sandNormals: [], sandUvs: [], sandSkyLight: [], sandTorchLight: [], sandIndices: [], sandVertexOffset: 0,\r\n    woodPositions: [], woodNormals: [], woodUvs: [], woodSkyLight: [], woodTorchLight: [], woodIndices: [], woodVertexOffset: 0,\r\n    waterPositions: [], waterNormals: [], waterUvs: [], waterIndices: [], waterVertexOffset: 0,\r\n    sidePositions: [], sideNormals: [], sideUvs: [], sideSkyLight: [], sideTorchLight: [], sideIndices: [], sideVertexOffset: 0,\r\n    waterSidePositions: [], waterSideNormals: [], waterSideUvs: [], waterSideIndices: [], waterSideVertexOffset: 0,\r\n    snowPositions: [], snowNormals: [], snowUvs: [], snowSkyLight: [], snowTorchLight: [], snowIndices: [], snowVertexOffset: 0,\r\n    icePositions: [], iceNormals: [], iceUvs: [], iceSkyLight: [], iceTorchLight: [], iceIndices: [], iceVertexOffset: 0\r\n  };\r\n}\r\n\r\n// Tile data passed from main thread\r\ninterface TileData {\r\n  index: number;\r\n  vertices: Vec3[];\r\n  center: Vec3;\r\n  neighbors: number[];\r\n}\r\n\r\n// Column data passed from main thread\r\ninterface ColumnData {\r\n  tileIndex: number;\r\n  tile: TileData;\r\n  blocks: number[];\r\n}\r\n\r\n// Pre-computed tile data for fast access\r\ninterface PrecomputedTileData {\r\n  normalizedCenter: Vec3;\r\n  normalizedVertices: Vec3[];\r\n  // Edge midpoint normalized directions (for neighbor lookup)\r\n  edgeMidDirs: Vec3[];\r\n  // Which neighbor is across each edge (index into neighbors array, -1 if none found)\r\n  edgeNeighborIdx: number[];\r\n  // Pre-computed normalized UVs for each vertex (0-1 range, touching edges)\r\n  normalizedUVs: { u: number; v: number }[];\r\n  // Center UV (where the face center maps to in UV space)\r\n  centerUV: { u: number; v: number };\r\n}\r\n\r\n// Block types (must match HexBlock.ts)\r\nconst HexBlockType = {\r\n  AIR: 0,\r\n  STONE: 1,\r\n  DIRT: 2,\r\n  GRASS: 3,\r\n  WATER: 4,\r\n  SAND: 5,\r\n  WOOD: 6,\r\n  LEAVES: 7,\r\n  // Mineral ores\r\n  ORE_COAL: 8,\r\n  ORE_COPPER: 9,\r\n  ORE_IRON: 10,\r\n  ORE_GOLD: 11,\r\n  ORE_LITHIUM: 12,\r\n  ORE_ALUMINUM: 13,\r\n  ORE_COBALT: 14,\r\n  // Snow biome blocks\r\n  SNOW: 15,\r\n  DIRT_SNOW: 16,\r\n  ICE: 17\r\n};\r\n\r\n// Config passed from main thread\r\ninterface LODWorkerConfig {\r\n  radius: number;\r\n  blockHeight: number;\r\n  seaLevel: number;\r\n  maxDepth: number;  // Total depth (for radius calculation)\r\n  waterSurfaceOffset: number;\r\n  lodOffset: number;\r\n  chunkCount: number;\r\n}\r\n\r\n// Helper to convert depth to radius (0 = bedrock, maxDepth-1 = sky)\r\nfunction depthToRadius(depth: number, config: LODWorkerConfig): number {\r\n  return config.radius - (config.maxDepth - 1 - depth) * config.blockHeight;\r\n}\r\n\r\n// Get sea level depth in new system (0 = bedrock)\r\nfunction getSeaLevelDepth(config: LODWorkerConfig): number {\r\n  return config.maxDepth - 1 - config.seaLevel;\r\n}\r\n\r\n// Message types\r\ninterface BuildLODGeometryMessage {\r\n  type: 'buildLODGeometry';\r\n  tileData: Record<number, TileData>;\r\n  blockData: Record<number, number[]>;\r\n  nearbyTiles: number[];\r\n  tileToChunk: Record<number, number>;\r\n  config: LODWorkerConfig;\r\n  torches?: TorchData[];  // Torch positions for vertex lighting\r\n}\r\n\r\ninterface LODGeometryResultMessage {\r\n  type: 'lodGeometryResult';\r\n  chunkGeometries: ChunkGeometry[];\r\n}\r\n\r\n// Cached pre-computed data (persists across messages for same tile structure)\r\nlet cachedPrecomputed: Map<number, PrecomputedTileData> | null = null;\r\nlet cachedTileCount = 0;\r\n\r\n// Worker message handler\r\nself.onmessage = (e: MessageEvent<BuildLODGeometryMessage>) => {\r\n  const { type, tileData, blockData, nearbyTiles, tileToChunk, config, torches = [] } = e.data;\r\n\r\n  if (type === 'buildLODGeometry') {\r\n    const nearbyTilesSet = new Set(nearbyTiles);\r\n    const tileToChunkMap = new Map(Object.entries(tileToChunk).map(([k, v]) => [parseInt(k), v]));\r\n\r\n    // Reconstruct columns from separate tile and block data\r\n    const columnsMap = new Map<number, ColumnData>();\r\n    for (const [tileIndexStr, tile] of Object.entries(tileData)) {\r\n      const tileIndex = parseInt(tileIndexStr);\r\n      const blocks = blockData[tileIndex];\r\n      if (blocks) {\r\n        columnsMap.set(tileIndex, { tileIndex, tile, blocks });\r\n      }\r\n    }\r\n\r\n    // Pre-compute normalized data if not cached or tile count changed\r\n    const tileCount = Object.keys(tileData).length;\r\n    if (!cachedPrecomputed || cachedTileCount !== tileCount) {\r\n      cachedPrecomputed = new Map();\r\n      cachedTileCount = tileCount;\r\n\r\n      for (const [tileIndex, column] of columnsMap) {\r\n        const tile = column.tile;\r\n        const numVerts = tile.vertices.length;\r\n\r\n        // Normalize center once\r\n        const centerLen = Math.sqrt(tile.center.x * tile.center.x + tile.center.y * tile.center.y + tile.center.z * tile.center.z);\r\n        const normalizedCenter: Vec3 = centerLen > 0\r\n          ? { x: tile.center.x / centerLen, y: tile.center.y / centerLen, z: tile.center.z / centerLen }\r\n          : { x: 0, y: 0, z: 0 };\r\n\r\n        // Normalize all vertices once\r\n        const normalizedVertices: Vec3[] = [];\r\n        for (const v of tile.vertices) {\r\n          const vLen = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\r\n          normalizedVertices.push(vLen > 0\r\n            ? { x: v.x / vLen, y: v.y / vLen, z: v.z / vLen }\r\n            : { x: 0, y: 0, z: 0 });\r\n        }\r\n\r\n        // Pre-compute edge midpoint directions\r\n        const edgeMidDirs: Vec3[] = [];\r\n        for (let i = 0; i < numVerts; i++) {\r\n          const next = (i + 1) % numVerts;\r\n          const v1 = tile.vertices[i];\r\n          const v2 = tile.vertices[next];\r\n          const midX = v1.x + v2.x;\r\n          const midY = v1.y + v2.y;\r\n          const midZ = v1.z + v2.z;\r\n          const midLen = Math.sqrt(midX * midX + midY * midY + midZ * midZ);\r\n          edgeMidDirs.push(midLen > 0\r\n            ? { x: midX / midLen, y: midY / midLen, z: midZ / midLen }\r\n            : { x: 0, y: 0, z: 0 });\r\n        }\r\n\r\n        // Pre-compute which neighbor is across each edge\r\n        const edgeNeighborIdx: number[] = [];\r\n        for (let i = 0; i < numVerts; i++) {\r\n          const edgeMidDir = edgeMidDirs[i];\r\n          let closestNeighbor = -1;\r\n          let closestDist = Infinity;\r\n\r\n          for (const nIdx of tile.neighbors) {\r\n            const neighborColumn = columnsMap.get(nIdx);\r\n            if (!neighborColumn) continue;\r\n\r\n            const nc = neighborColumn.tile.center;\r\n            const ncLen = Math.sqrt(nc.x * nc.x + nc.y * nc.y + nc.z * nc.z);\r\n            if (ncLen === 0) continue;\r\n\r\n            const ncNormX = nc.x / ncLen;\r\n            const ncNormY = nc.y / ncLen;\r\n            const ncNormZ = nc.z / ncLen;\r\n\r\n            const dx = ncNormX - edgeMidDir.x;\r\n            const dy = ncNormY - edgeMidDir.y;\r\n            const dz = ncNormZ - edgeMidDir.z;\r\n            const dist = dx * dx + dy * dy + dz * dz;\r\n\r\n            if (dist < closestDist) {\r\n              closestDist = dist;\r\n              closestNeighbor = nIdx;\r\n            }\r\n          }\r\n          edgeNeighborIdx.push(closestNeighbor);\r\n        }\r\n\r\n        // Pre-compute local coordinate system for UV mapping\r\n        // Create tangent and bitangent vectors perpendicular to the normal\r\n        const up: Vec3 = Math.abs(normalizedCenter.y) < 0.9\r\n          ? { x: 0, y: 1, z: 0 }\r\n          : { x: 1, y: 0, z: 0 };\r\n\r\n        // tangent = cross(up, normal)\r\n        const tangentX = up.y * normalizedCenter.z - up.z * normalizedCenter.y;\r\n        const tangentY = up.z * normalizedCenter.x - up.x * normalizedCenter.z;\r\n        const tangentZ = up.x * normalizedCenter.y - up.y * normalizedCenter.x;\r\n        const tangentLen = Math.sqrt(tangentX * tangentX + tangentY * tangentY + tangentZ * tangentZ);\r\n        const tangent: Vec3 = tangentLen > 0\r\n          ? { x: tangentX / tangentLen, y: tangentY / tangentLen, z: tangentZ / tangentLen }\r\n          : { x: 1, y: 0, z: 0 };\r\n\r\n        // bitangent = cross(normal, tangent)\r\n        const bitangentX = normalizedCenter.y * tangent.z - normalizedCenter.z * tangent.y;\r\n        const bitangentY = normalizedCenter.z * tangent.x - normalizedCenter.x * tangent.z;\r\n        const bitangentZ = normalizedCenter.x * tangent.y - normalizedCenter.y * tangent.x;\r\n        const bitangent: Vec3 = { x: bitangentX, y: bitangentY, z: bitangentZ };\r\n\r\n        // Project vertices onto local 2D plane and find bounding box\r\n        const localCoords: { u: number; v: number }[] = [];\r\n        let minU = Infinity, maxU = -Infinity, minV = Infinity, maxV = -Infinity;\r\n\r\n        for (const vert of tile.vertices) {\r\n          // Vector from center to vertex\r\n          const toVertX = vert.x - tile.center.x;\r\n          const toVertY = vert.y - tile.center.y;\r\n          const toVertZ = vert.z - tile.center.z;\r\n\r\n          // Project onto tangent and bitangent\r\n          const u = toVertX * tangent.x + toVertY * tangent.y + toVertZ * tangent.z;\r\n          const v = toVertX * bitangent.x + toVertY * bitangent.y + toVertZ * bitangent.z;\r\n          localCoords.push({ u, v });\r\n\r\n          minU = Math.min(minU, u);\r\n          maxU = Math.max(maxU, u);\r\n          minV = Math.min(minV, v);\r\n          maxV = Math.max(maxV, v);\r\n        }\r\n\r\n        // Normalize UVs to 0-1 range\r\n        const rangeU = maxU - minU;\r\n        const rangeV = maxV - minV;\r\n        const normalizedUVs: { u: number; v: number }[] = localCoords.map(coord => ({\r\n          u: (coord.u - minU) / rangeU,\r\n          v: (coord.v - minV) / rangeV\r\n        }));\r\n\r\n        // Center UV (the center vertex at (0,0) in local coords maps to this UV)\r\n        const centerUV = {\r\n          u: (0 - minU) / rangeU,\r\n          v: (0 - minV) / rangeV\r\n        };\r\n\r\n        cachedPrecomputed.set(tileIndex, {\r\n          normalizedCenter,\r\n          normalizedVertices,\r\n          edgeMidDirs,\r\n          edgeNeighborIdx,\r\n          normalizedUVs,\r\n          centerUV\r\n        });\r\n      }\r\n    }\r\n\r\n    const chunkGeometries: ChunkGeometry[] = [];\r\n    for (let i = 0; i < config.chunkCount; i++) {\r\n      chunkGeometries.push(createEmptyChunkGeometry());\r\n    }\r\n\r\n    const seaLevelDepth = getSeaLevelDepth(config);\r\n    const waterRadius = depthToRadius(seaLevelDepth, config) - config.lodOffset;\r\n\r\n    // Combined first pass: calculate display radius AND surface block type for each tile\r\n    // This eliminates redundant block array searches\r\n    interface TileInfo {\r\n      radius: number;           // Display radius for LOD rendering\r\n      isWater: boolean;         // True if surface is water\r\n      surfaceBlockType: number; // The topmost non-air block type\r\n      terrainRadius: number;    // Radius of actual solid terrain (for water walls)\r\n    }\r\n    const tileInfo = new Map<number, TileInfo>();\r\n\r\n    for (const [tileIndex, column] of columnsMap) {\r\n      // Find surface depth (topmost non-air block, searching from top down)\r\n      let surfaceDepth = 0;\r\n      let surfaceBlockType = HexBlockType.GRASS;\r\n      let terrainDepth = 0; // Topmost solid block (ignoring water)\r\n      const blocks = column.blocks;\r\n      for (let d = blocks.length - 1; d >= 0; d--) {\r\n        if (blocks[d] !== HexBlockType.AIR) {\r\n          if (surfaceBlockType === HexBlockType.GRASS) {\r\n            // First non-air block found\r\n            surfaceDepth = d;\r\n            surfaceBlockType = blocks[d];\r\n          }\r\n          if (blocks[d] !== HexBlockType.WATER) {\r\n            // First solid (non-water) block found\r\n            terrainDepth = d;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      const isWater = surfaceBlockType === HexBlockType.WATER;\r\n      const displayRadius = isWater\r\n        ? waterRadius\r\n        : depthToRadius(surfaceDepth, config) - config.lodOffset;\r\n      const terrainRadius = depthToRadius(terrainDepth, config) - config.lodOffset;\r\n\r\n      tileInfo.set(tileIndex, { radius: displayRadius, isWater, surfaceBlockType, terrainRadius });\r\n    }\r\n\r\n    // NOTE: Do NOT do camera-based back-face culling here - the geometry is built once\r\n    // but the camera moves after. THREE.js handles per-chunk frustum culling at render time\r\n    // via cullLODChunks() in Planet.ts\r\n\r\n    // Second pass: build top faces for LOD tiles (uses cached data)\r\n    for (const [tileIndex] of columnsMap) {\r\n      if (nearbyTilesSet.has(tileIndex)) continue;\r\n\r\n      const precomputed = cachedPrecomputed.get(tileIndex)!;\r\n      const info = tileInfo.get(tileIndex)!\r\n      const displayRadius = info.radius;\r\n      const surfaceBlockType = info.surfaceBlockType;\r\n\r\n      const chunkIdx = tileToChunkMap.get(tileIndex) ?? 0;\r\n      const chunk = chunkGeometries[chunkIdx];\r\n\r\n      // Select buffer based on surface type\r\n      let positions: number[], normals: number[], uvs: number[], skyLight: number[] | null, torchLight: number[] | null, indices: number[];\r\n      let vertexOffset: number;\r\n\r\n      if (surfaceBlockType === HexBlockType.WATER) {\r\n        positions = chunk.waterPositions;\r\n        normals = chunk.waterNormals;\r\n        uvs = chunk.waterUvs;\r\n        skyLight = null; // Water uses different shader, doesn't need skyLight\r\n        torchLight = null;\r\n        indices = chunk.waterIndices;\r\n        vertexOffset = chunk.waterVertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.DIRT) {\r\n        positions = chunk.dirtPositions;\r\n        normals = chunk.dirtNormals;\r\n        uvs = chunk.dirtUvs;\r\n        skyLight = chunk.dirtSkyLight;\r\n        torchLight = chunk.dirtTorchLight;\r\n        indices = chunk.dirtIndices;\r\n        vertexOffset = chunk.dirtVertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.STONE) {\r\n        positions = chunk.stonePositions;\r\n        normals = chunk.stoneNormals;\r\n        uvs = chunk.stoneUvs;\r\n        skyLight = chunk.stoneSkyLight;\r\n        torchLight = chunk.stoneTorchLight;\r\n        indices = chunk.stoneIndices;\r\n        vertexOffset = chunk.stoneVertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.SAND) {\r\n        positions = chunk.sandPositions;\r\n        normals = chunk.sandNormals;\r\n        uvs = chunk.sandUvs;\r\n        skyLight = chunk.sandSkyLight;\r\n        torchLight = chunk.sandTorchLight;\r\n        indices = chunk.sandIndices;\r\n        vertexOffset = chunk.sandVertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.WOOD) {\r\n        positions = chunk.woodPositions;\r\n        normals = chunk.woodNormals;\r\n        uvs = chunk.woodUvs;\r\n        skyLight = chunk.woodSkyLight;\r\n        torchLight = chunk.woodTorchLight;\r\n        indices = chunk.woodIndices;\r\n        vertexOffset = chunk.woodVertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.SNOW || surfaceBlockType === HexBlockType.DIRT_SNOW) {\r\n        positions = chunk.snowPositions;\r\n        normals = chunk.snowNormals;\r\n        uvs = chunk.snowUvs;\r\n        skyLight = chunk.snowSkyLight;\r\n        torchLight = chunk.snowTorchLight;\r\n        indices = chunk.snowIndices;\r\n        vertexOffset = chunk.snowVertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.ICE) {\r\n        positions = chunk.icePositions;\r\n        normals = chunk.iceNormals;\r\n        uvs = chunk.iceUvs;\r\n        skyLight = chunk.iceSkyLight;\r\n        torchLight = chunk.iceTorchLight;\r\n        indices = chunk.iceIndices;\r\n        vertexOffset = chunk.iceVertexOffset;\r\n      } else {\r\n        // GRASS, LEAVES, or any other type defaults to grass\r\n        positions = chunk.grassPositions;\r\n        normals = chunk.grassNormals;\r\n        uvs = chunk.grassUvs;\r\n        skyLight = chunk.grassSkyLight;\r\n        torchLight = chunk.grassTorchLight;\r\n        indices = chunk.grassIndices;\r\n        vertexOffset = chunk.grassVertexOffset;\r\n      }\r\n\r\n      // Use pre-computed normalized center, vertices, and UVs\r\n      const normal = precomputed.normalizedCenter;\r\n      const normalizedVerts = precomputed.normalizedVertices;\r\n      const normalizedUVs = precomputed.normalizedUVs;\r\n      const centerUV = precomputed.centerUV;\r\n\r\n      // Fan triangulation from center\r\n      const centerIdx = vertexOffset;\r\n      const cx = normal.x * displayRadius;\r\n      const cy = normal.y * displayRadius;\r\n      const cz = normal.z * displayRadius;\r\n      positions.push(cx, cy, cz);\r\n      normals.push(normal.x, normal.y, normal.z);\r\n      uvs.push(centerUV.u, centerUV.v);\r\n      if (skyLight) skyLight.push(1.0); // LOD terrain is always at surface, full sky exposure\r\n      if (torchLight) torchLight.push(calculateTorchLight(cx, cy, cz, torches));\r\n      vertexOffset++;\r\n\r\n      for (let i = 0; i < normalizedVerts.length; i++) {\r\n        const nv = normalizedVerts[i];\r\n        const vx = nv.x * displayRadius;\r\n        const vy = nv.y * displayRadius;\r\n        const vz = nv.z * displayRadius;\r\n        positions.push(vx, vy, vz);\r\n        normals.push(normal.x, normal.y, normal.z);\r\n        uvs.push(normalizedUVs[i].u, normalizedUVs[i].v);\r\n        if (skyLight) skyLight.push(1.0);\r\n        if (torchLight) torchLight.push(calculateTorchLight(vx, vy, vz, torches));\r\n        vertexOffset++;\r\n\r\n        indices.push(centerIdx, centerIdx + 1 + i, centerIdx + 1 + ((i + 1) % normalizedVerts.length));\r\n      }\r\n\r\n      // Update offset\r\n      if (surfaceBlockType === HexBlockType.WATER) {\r\n        chunk.waterVertexOffset = vertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.DIRT) {\r\n        chunk.dirtVertexOffset = vertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.STONE) {\r\n        chunk.stoneVertexOffset = vertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.SAND) {\r\n        chunk.sandVertexOffset = vertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.WOOD) {\r\n        chunk.woodVertexOffset = vertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.SNOW || surfaceBlockType === HexBlockType.DIRT_SNOW) {\r\n        chunk.snowVertexOffset = vertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.ICE) {\r\n        chunk.iceVertexOffset = vertexOffset;\r\n      } else {\r\n        chunk.grassVertexOffset = vertexOffset;\r\n      }\r\n    }\r\n\r\n    // Third pass: generate side walls (uses cached edge-neighbor mapping)\r\n    for (const [tileIndex] of columnsMap) {\r\n      if (nearbyTilesSet.has(tileIndex)) continue;\r\n\r\n      const precomputed = cachedPrecomputed.get(tileIndex)!;\r\n      const info = tileInfo.get(tileIndex)!\r\n      const thisRadius = info.radius;\r\n      const thisIsWater = info.isWater;\r\n      const normalizedVerts = precomputed.normalizedVertices;\r\n      const edgeNeighborIdx = precomputed.edgeNeighborIdx;\r\n      const numSides = normalizedVerts.length;\r\n\r\n      const chunkIdx = tileToChunkMap.get(tileIndex) ?? 0;\r\n      const chunk = chunkGeometries[chunkIdx];\r\n\r\n      for (let i = 0; i < numSides; i++) {\r\n        const neighborTileIdx = edgeNeighborIdx[i];\r\n        if (neighborTileIdx < 0) continue;\r\n\r\n        const neighborInfo = tileInfo.get(neighborTileIdx);\r\n        if (!neighborInfo) continue;\r\n\r\n        const neighborRadius = neighborInfo.radius;\r\n\r\n        // Generate wall only when this tile is higher than neighbor\r\n        // This applies to both solid and water tiles - walls show height differences\r\n        if (thisRadius <= neighborRadius) continue;\r\n\r\n        const next = (i + 1) % numSides;\r\n        const nv1 = normalizedVerts[i];\r\n        const nv2 = normalizedVerts[next];\r\n\r\n        // Create wall vertices using pre-normalized directions\r\n        const innerV1x = nv1.x * neighborRadius, innerV1y = nv1.y * neighborRadius, innerV1z = nv1.z * neighborRadius;\r\n        const innerV2x = nv2.x * neighborRadius, innerV2y = nv2.y * neighborRadius, innerV2z = nv2.z * neighborRadius;\r\n        const outerV1x = nv1.x * thisRadius, outerV1y = nv1.y * thisRadius, outerV1z = nv1.z * thisRadius;\r\n        const outerV2x = nv2.x * thisRadius, outerV2y = nv2.y * thisRadius, outerV2z = nv2.z * thisRadius;\r\n\r\n        // Calculate side normal\r\n        const edge1x = innerV2x - innerV1x, edge1y = innerV2y - innerV1y, edge1z = innerV2z - innerV1z;\r\n        const edge2x = outerV1x - innerV1x, edge2y = outerV1y - innerV1y, edge2z = outerV1z - innerV1z;\r\n        const crossX = edge1y * edge2z - edge1z * edge2y;\r\n        const crossY = edge1z * edge2x - edge1x * edge2z;\r\n        const crossZ = edge1x * edge2y - edge1y * edge2x;\r\n        const crossLen = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);\r\n        const snx = crossLen > 0 ? crossX / crossLen : 0;\r\n        const sny = crossLen > 0 ? crossY / crossLen : 0;\r\n        const snz = crossLen > 0 ? crossZ / crossLen : 0;\r\n\r\n        const positions = thisIsWater ? chunk.waterSidePositions : chunk.sidePositions;\r\n        const normals = thisIsWater ? chunk.waterSideNormals : chunk.sideNormals;\r\n        const uvs = thisIsWater ? chunk.waterSideUvs : chunk.sideUvs;\r\n        const skyLight = thisIsWater ? null : chunk.sideSkyLight;\r\n        const sideTorchLight = thisIsWater ? null : chunk.sideTorchLight;\r\n        const indices = thisIsWater ? chunk.waterSideIndices : chunk.sideIndices;\r\n        const baseIdx = thisIsWater ? chunk.waterSideVertexOffset : chunk.sideVertexOffset;\r\n\r\n        positions.push(\r\n          innerV1x, innerV1y, innerV1z,\r\n          innerV2x, innerV2y, innerV2z,\r\n          outerV2x, outerV2y, outerV2z,\r\n          outerV1x, outerV1y, outerV1z\r\n        );\r\n\r\n        normals.push(snx, sny, snz, snx, sny, snz, snx, sny, snz, snx, sny, snz);\r\n        uvs.push(0, 0, 1, 0, 1, 1, 0, 1);\r\n        if (skyLight) skyLight.push(1.0, 1.0, 1.0, 1.0); // Full sky exposure for LOD\r\n        if (sideTorchLight) {\r\n          sideTorchLight.push(\r\n            calculateTorchLight(innerV1x, innerV1y, innerV1z, torches),\r\n            calculateTorchLight(innerV2x, innerV2y, innerV2z, torches),\r\n            calculateTorchLight(outerV2x, outerV2y, outerV2z, torches),\r\n            calculateTorchLight(outerV1x, outerV1y, outerV1z, torches)\r\n          );\r\n        }\r\n\r\n        indices.push(baseIdx, baseIdx + 1, baseIdx + 2);\r\n        indices.push(baseIdx, baseIdx + 2, baseIdx + 3);\r\n\r\n        if (thisIsWater) {\r\n          chunk.waterSideVertexOffset += 4;\r\n        } else {\r\n          chunk.sideVertexOffset += 4;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fourth pass: water boundary walls at LOD/terrain edge\r\n    for (const [tileIndex] of columnsMap) {\r\n      if (nearbyTilesSet.has(tileIndex)) continue;\r\n\r\n      const precomputed = cachedPrecomputed.get(tileIndex)!;\r\n      const info = tileInfo.get(tileIndex);\r\n      if (!info || !info.isWater) continue;\r\n      const normalizedVerts = precomputed.normalizedVertices;\r\n      const edgeNeighborIdx = precomputed.edgeNeighborIdx;\r\n      const numSides = normalizedVerts.length;\r\n\r\n      const chunkIdx = tileToChunkMap.get(tileIndex) ?? 0;\r\n      const chunk = chunkGeometries[chunkIdx];\r\n\r\n      for (let i = 0; i < numSides; i++) {\r\n        const neighborTileIdx = edgeNeighborIdx[i];\r\n        if (neighborTileIdx < 0) continue;\r\n        if (!nearbyTilesSet.has(neighborTileIdx)) continue;\r\n\r\n        const neighborInfo = tileInfo.get(neighborTileIdx);\r\n        if (!neighborInfo) continue;\r\n\r\n        // Use terrainRadius (solid ground) not radius (which could be water surface)\r\n        const bottomRadius = neighborInfo.terrainRadius;\r\n        const topRadius = waterRadius;\r\n        if (bottomRadius >= topRadius) continue;\r\n\r\n        const next = (i + 1) % numSides;\r\n        const nv1 = normalizedVerts[i];\r\n        const nv2 = normalizedVerts[next];\r\n\r\n        const innerV1x = nv1.x * bottomRadius, innerV1y = nv1.y * bottomRadius, innerV1z = nv1.z * bottomRadius;\r\n        const innerV2x = nv2.x * bottomRadius, innerV2y = nv2.y * bottomRadius, innerV2z = nv2.z * bottomRadius;\r\n        const outerV1x = nv1.x * topRadius, outerV1y = nv1.y * topRadius, outerV1z = nv1.z * topRadius;\r\n        const outerV2x = nv2.x * topRadius, outerV2y = nv2.y * topRadius, outerV2z = nv2.z * topRadius;\r\n\r\n        const edge1x = innerV2x - innerV1x, edge1y = innerV2y - innerV1y, edge1z = innerV2z - innerV1z;\r\n        const edge2x = outerV1x - innerV1x, edge2y = outerV1y - innerV1y, edge2z = outerV1z - innerV1z;\r\n        const crossX = edge1y * edge2z - edge1z * edge2y;\r\n        const crossY = edge1z * edge2x - edge1x * edge2z;\r\n        const crossZ = edge1x * edge2y - edge1y * edge2x;\r\n        const crossLen = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);\r\n        const snx = crossLen > 0 ? crossX / crossLen : 0;\r\n        const sny = crossLen > 0 ? crossY / crossLen : 0;\r\n        const snz = crossLen > 0 ? crossZ / crossLen : 0;\r\n\r\n        const baseIdx = chunk.waterSideVertexOffset;\r\n\r\n        chunk.waterSidePositions.push(\r\n          innerV1x, innerV1y, innerV1z,\r\n          innerV2x, innerV2y, innerV2z,\r\n          outerV2x, outerV2y, outerV2z,\r\n          outerV1x, outerV1y, outerV1z\r\n        );\r\n\r\n        chunk.waterSideNormals.push(snx, sny, snz, snx, sny, snz, snx, sny, snz, snx, sny, snz);\r\n        chunk.waterSideUvs.push(0, 0, 1, 0, 1, 1, 0, 1);\r\n\r\n        chunk.waterSideIndices.push(baseIdx, baseIdx + 1, baseIdx + 2);\r\n        chunk.waterSideIndices.push(baseIdx, baseIdx + 2, baseIdx + 3);\r\n\r\n        chunk.waterSideVertexOffset += 4;\r\n      }\r\n    }\r\n\r\n    const result: LODGeometryResultMessage = {\r\n      type: 'lodGeometryResult',\r\n      chunkGeometries\r\n    };\r\n\r\n    self.postMessage(result);\r\n  }\r\n};\r\n\r\nexport {};\r\n"],"names":["calculateTorchLight","x","y","z","torches","totalLight","torch","dx","dy","dz","dist","attenuation","createEmptyChunkGeometry","HexBlockType","depthToRadius","depth","config","getSeaLevelDepth","cachedPrecomputed","cachedTileCount","e","type","tileData","blockData","nearbyTiles","tileToChunk","nearbyTilesSet","tileToChunkMap","k","v","columnsMap","tileIndexStr","tile","tileIndex","blocks","tileCount","column","numVerts","centerLen","normalizedCenter","normalizedVertices","vLen","edgeMidDirs","next","v1","v2","midX","midY","midZ","midLen","edgeNeighborIdx","edgeMidDir","closestNeighbor","closestDist","nIdx","neighborColumn","nc","ncLen","ncNormX","ncNormY","ncNormZ","up","tangentX","tangentY","tangentZ","tangentLen","tangent","bitangentX","bitangentY","bitangentZ","bitangent","localCoords","minU","maxU","minV","maxV","vert","toVertX","toVertY","toVertZ","u","rangeU","rangeV","normalizedUVs","coord","centerUV","chunkGeometries","i","seaLevelDepth","waterRadius","tileInfo","surfaceDepth","surfaceBlockType","terrainDepth","d","isWater","displayRadius","terrainRadius","precomputed","info","chunkIdx","chunk","positions","normals","uvs","skyLight","torchLight","indices","vertexOffset","normal","normalizedVerts","centerIdx","cx","cy","cz","nv","vx","vy","vz","thisRadius","thisIsWater","numSides","neighborTileIdx","neighborInfo","neighborRadius","nv1","nv2","innerV1x","innerV1y","innerV1z","innerV2x","innerV2y","innerV2z","outerV1x","outerV1y","outerV1z","outerV2x","outerV2y","outerV2z","edge1x","edge1y","edge1z","edge2x","edge2y","edge2z","crossX","crossY","crossZ","crossLen","snx","sny","snz","sideTorchLight","baseIdx","bottomRadius","topRadius","result"],"mappings":"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"}