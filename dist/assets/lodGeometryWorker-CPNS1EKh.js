(function(){"use strict";function J(j,_,se,ce){let ne=0;for(const G of ce){const E=j-G.position.x,X=_-G.position.y,H=se-G.position.z,F=Math.sqrt(E*E+X*X+H*H);if(F<G.range){const Y=1/(1+2*F*F/(G.range*G.range));ne+=Y*G.intensity}}return Math.min(ne,1.5)}function xe(){return{grassPositions:[],grassNormals:[],grassUvs:[],grassSkyLight:[],grassTorchLight:[],grassIndices:[],grassVertexOffset:0,dirtPositions:[],dirtNormals:[],dirtUvs:[],dirtSkyLight:[],dirtTorchLight:[],dirtIndices:[],dirtVertexOffset:0,stonePositions:[],stoneNormals:[],stoneUvs:[],stoneSkyLight:[],stoneTorchLight:[],stoneIndices:[],stoneVertexOffset:0,sandPositions:[],sandNormals:[],sandUvs:[],sandSkyLight:[],sandTorchLight:[],sandIndices:[],sandVertexOffset:0,woodPositions:[],woodNormals:[],woodUvs:[],woodSkyLight:[],woodTorchLight:[],woodIndices:[],woodVertexOffset:0,waterPositions:[],waterNormals:[],waterUvs:[],waterIndices:[],waterVertexOffset:0,sidePositions:[],sideNormals:[],sideUvs:[],sideSkyLight:[],sideTorchLight:[],sideIndices:[],sideVertexOffset:0,waterSidePositions:[],waterSideNormals:[],waterSideUvs:[],waterSideIndices:[],waterSideVertexOffset:0,snowPositions:[],snowNormals:[],snowUvs:[],snowSkyLight:[],snowTorchLight:[],snowIndices:[],snowVertexOffset:0,icePositions:[],iceNormals:[],iceUvs:[],iceSkyLight:[],iceTorchLight:[],iceIndices:[],iceVertexOffset:0}}const g={AIR:0,STONE:1,DIRT:2,GRASS:3,WATER:4,SAND:5,WOOD:6,SNOW:15,DIRT_SNOW:16,ICE:17};function ie(j,_){return _.radius-(_.maxDepth-1-j)*_.blockHeight}function ue(j){return j.maxDepth-1-j.seaLevel}let K=null,re=0;self.onmessage=j=>{const{type:_,tileData:se,blockData:ce,nearbyTiles:ne,tileToChunk:G,config:E,torches:X=[]}=j.data;if(_==="buildLODGeometry"){const H=new Set(ne),F=new Map(Object.entries(G).map(([h,p])=>[parseInt(h),p])),Y=new Map;for(const[h,p]of Object.entries(se)){const n=parseInt(h),c=ce[n];c&&Y.set(n,{tileIndex:n,tile:p,blocks:c})}const de=Object.keys(se).length;if(!K||re!==de){K=new Map,re=de;for(const[h,p]of Y){const n=p.tile,c=n.vertices.length,s=Math.sqrt(n.center.x*n.center.x+n.center.y*n.center.y+n.center.z*n.center.z),r=s>0?{x:n.center.x/s,y:n.center.y/s,z:n.center.z/s}:{x:0,y:0,z:0},e=[];for(const i of n.vertices){const m=Math.sqrt(i.x*i.x+i.y*i.y+i.z*i.z);e.push(m>0?{x:i.x/m,y:i.y/m,z:i.z/m}:{x:0,y:0,z:0})}const a=[];for(let i=0;i<c;i++){const m=(i+1)%c,T=n.vertices[i],N=n.vertices[m],S=T.x+N.x,O=T.y+N.y,z=T.z+N.z,w=Math.sqrt(S*S+O*O+z*z);a.push(w>0?{x:S/w,y:O/w,z:z/w}:{x:0,y:0,z:0})}const u=[];for(let i=0;i<c;i++){const m=a[i];let T=-1,N=1/0;for(const S of n.neighbors){const O=Y.get(S);if(!O)continue;const z=O.tile.center,w=Math.sqrt(z.x*z.x+z.y*z.y+z.z*z.z);if(w===0)continue;const B=z.x/w,W=z.y/w,M=z.z/w,A=B-m.x,C=W-m.y,b=M-m.z,oe=A*A+C*C+b*b;oe<N&&(N=oe,T=S)}u.push(T)}const t=Math.abs(r.y)<.9?{x:0,y:1,z:0}:{x:1,y:0,z:0},l=t.y*r.z-t.z*r.y,f=t.z*r.x-t.x*r.z,x=t.x*r.y-t.y*r.x,o=Math.sqrt(l*l+f*f+x*x),d=o>0?{x:l/o,y:f/o,z:x/o}:{x:1,y:0,z:0},V=r.y*d.z-r.z*d.y,v=r.z*d.x-r.x*d.z,U=r.x*d.y-r.y*d.x,I={x:V,y:v,z:U},R=[];let L=1/0,D=-1/0,y=1/0,k=-1/0;for(const i of n.vertices){const m=i.x-n.center.x,T=i.y-n.center.y,N=i.z-n.center.z,S=m*d.x+T*d.y+N*d.z,O=m*I.x+T*I.y+N*I.z;R.push({u:S,v:O}),L=Math.min(L,S),D=Math.max(D,S),y=Math.min(y,O),k=Math.max(k,O)}const P=D-L,q=k-y,Z=R.map(i=>({u:(i.u-L)/P,v:(i.v-y)/q})),$={u:(0-L)/P,v:(0-y)/q};K.set(h,{normalizedCenter:r,normalizedVertices:e,edgeMidDirs:a,edgeNeighborIdx:u,normalizedUVs:Z,centerUV:$})}}const te=[];for(let h=0;h<E.chunkCount;h++)te.push(xe());const ge=ue(E),ae=ie(ge,E)-E.lodOffset,Q=new Map;for(const[h,p]of Y){let n=0,c=g.GRASS,s=0;const r=p.blocks;for(let t=r.length-1;t>=0;t--)if(r[t]!==g.AIR&&(c===g.GRASS&&(n=t,c=r[t]),r[t]!==g.WATER)){s=t;break}const e=c===g.WATER,a=e?ae:ie(n,E)-E.lodOffset,u=ie(s,E)-E.lodOffset;Q.set(h,{radius:a,isWater:e,surfaceBlockType:c,terrainRadius:u})}for(const[h]of Y){if(H.has(h))continue;const p=K.get(h),n=Q.get(h),c=n.radius,s=n.surfaceBlockType,r=F.get(h)??0,e=te[r];let a,u,t,l,f,x,o;s===g.WATER?(a=e.waterPositions,u=e.waterNormals,t=e.waterUvs,l=null,f=null,x=e.waterIndices,o=e.waterVertexOffset):s===g.DIRT?(a=e.dirtPositions,u=e.dirtNormals,t=e.dirtUvs,l=e.dirtSkyLight,f=e.dirtTorchLight,x=e.dirtIndices,o=e.dirtVertexOffset):s===g.STONE?(a=e.stonePositions,u=e.stoneNormals,t=e.stoneUvs,l=e.stoneSkyLight,f=e.stoneTorchLight,x=e.stoneIndices,o=e.stoneVertexOffset):s===g.SAND?(a=e.sandPositions,u=e.sandNormals,t=e.sandUvs,l=e.sandSkyLight,f=e.sandTorchLight,x=e.sandIndices,o=e.sandVertexOffset):s===g.WOOD?(a=e.woodPositions,u=e.woodNormals,t=e.woodUvs,l=e.woodSkyLight,f=e.woodTorchLight,x=e.woodIndices,o=e.woodVertexOffset):s===g.SNOW||s===g.DIRT_SNOW?(a=e.snowPositions,u=e.snowNormals,t=e.snowUvs,l=e.snowSkyLight,f=e.snowTorchLight,x=e.snowIndices,o=e.snowVertexOffset):s===g.ICE?(a=e.icePositions,u=e.iceNormals,t=e.iceUvs,l=e.iceSkyLight,f=e.iceTorchLight,x=e.iceIndices,o=e.iceVertexOffset):(a=e.grassPositions,u=e.grassNormals,t=e.grassUvs,l=e.grassSkyLight,f=e.grassTorchLight,x=e.grassIndices,o=e.grassVertexOffset);const d=p.normalizedCenter,V=p.normalizedVertices,v=p.normalizedUVs,U=p.centerUV,I=o,R=d.x*c,L=d.y*c,D=d.z*c;a.push(R,L,D),u.push(d.x,d.y,d.z),t.push(U.u,U.v),l&&l.push(1),f&&f.push(J(R,L,D,X)),o++;for(let y=0;y<V.length;y++){const k=V[y],P=k.x*c,q=k.y*c,Z=k.z*c;a.push(P,q,Z),u.push(d.x,d.y,d.z),t.push(v[y].u,v[y].v),l&&l.push(1),f&&f.push(J(P,q,Z,X)),o++,x.push(I,I+1+y,I+1+(y+1)%V.length)}s===g.WATER?e.waterVertexOffset=o:s===g.DIRT?e.dirtVertexOffset=o:s===g.STONE?e.stoneVertexOffset=o:s===g.SAND?e.sandVertexOffset=o:s===g.WOOD?e.woodVertexOffset=o:s===g.SNOW||s===g.DIRT_SNOW?e.snowVertexOffset=o:s===g.ICE?e.iceVertexOffset=o:e.grassVertexOffset=o}for(const[h]of Y){if(H.has(h))continue;const p=K.get(h),n=Q.get(h),c=n.radius,s=n.isWater,r=p.normalizedVertices,e=p.edgeNeighborIdx,a=r.length,u=F.get(h)??0,t=te[u];for(let l=0;l<a;l++){const f=e[l];if(f<0)continue;const x=Q.get(f);if(!x)continue;const o=x.radius;if(c<=o)continue;const d=(l+1)%a,V=r[l],v=r[d],U=V.x*o,I=V.y*o,R=V.z*o,L=v.x*o,D=v.y*o,y=v.z*o,k=V.x*c,P=V.y*c,q=V.z*c,Z=v.x*c,$=v.y*c,i=v.z*c,m=L-U,T=D-I,N=y-R,S=k-U,O=P-I,z=q-R,w=T*z-N*O,B=N*S-m*z,W=m*O-T*S,M=Math.sqrt(w*w+B*B+W*W),A=M>0?w/M:0,C=M>0?B/M:0,b=M>0?W/M:0,oe=s?t.waterSidePositions:t.sidePositions,ze=s?t.waterSideNormals:t.sideNormals,Ve=s?t.waterSideUvs:t.sideUvs,fe=s?null:t.sideSkyLight,he=s?null:t.sideTorchLight,le=s?t.waterSideIndices:t.sideIndices,ee=s?t.waterSideVertexOffset:t.sideVertexOffset;oe.push(U,I,R,L,D,y,Z,$,i,k,P,q),ze.push(A,C,b,A,C,b,A,C,b,A,C,b),Ve.push(0,0,1,0,1,1,0,1),fe&&fe.push(1,1,1,1),he&&he.push(J(U,I,R,X),J(L,D,y,X),J(Z,$,i,X),J(k,P,q,X)),le.push(ee,ee+1,ee+2),le.push(ee,ee+2,ee+3),s?t.waterSideVertexOffset+=4:t.sideVertexOffset+=4}}for(const[h]of Y){if(H.has(h))continue;const p=K.get(h),n=Q.get(h);if(!n||!n.isWater)continue;const c=p.normalizedVertices,s=p.edgeNeighborIdx,r=c.length,e=F.get(h)??0,a=te[e];for(let u=0;u<r;u++){const t=s[u];if(t<0||!H.has(t))continue;const l=Q.get(t);if(!l)continue;const f=l.terrainRadius,x=ae;if(f>=x)continue;const o=(u+1)%r,d=c[u],V=c[o],v=d.x*f,U=d.y*f,I=d.z*f,R=V.x*f,L=V.y*f,D=V.z*f,y=d.x*x,k=d.y*x,P=d.z*x,q=V.x*x,Z=V.y*x,$=V.z*x,i=R-v,m=L-U,T=D-I,N=y-v,S=k-U,O=P-I,z=m*O-T*S,w=T*N-i*O,B=i*S-m*N,W=Math.sqrt(z*z+w*w+B*B),M=W>0?z/W:0,A=W>0?w/W:0,C=W>0?B/W:0,b=a.waterSideVertexOffset;a.waterSidePositions.push(v,U,I,R,L,D,q,Z,$,y,k,P),a.waterSideNormals.push(M,A,C,M,A,C,M,A,C,M,A,C),a.waterSideUvs.push(0,0,1,0,1,1,0,1),a.waterSideIndices.push(b,b+1,b+2),a.waterSideIndices.push(b,b+2,b+3),a.waterSideVertexOffset+=4}}const ye={type:"lodGeometryResult",chunkGeometries:te};self.postMessage(ye)}}})();
//# sourceMappingURL=lodGeometryWorker-CPNS1EKh.js.map
