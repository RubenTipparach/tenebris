{"version":3,"file":"lodGeometryWorker-BfBahJRa.js","sources":["../src/workers/lodGeometryWorker.ts"],"sourcesContent":["// LOD Geometry Worker - builds LOD terrain geometry off the main thread\n// Optimized: pre-computed normalizations, cached surface data, reduced passes\n\n// Vector3-like operations using plain objects\ninterface Vec3 {\n  x: number;\n  y: number;\n  z: number;\n}\n\n// Note: Vector operations are inlined in hot loops to avoid function call overhead\n// and object allocations. The raw x/y/z math is faster than helper functions.\n\n// Per-chunk geometry buffers\ninterface ChunkGeometry {\n  grassPositions: number[];\n  grassNormals: number[];\n  grassUvs: number[];\n  grassSkyLight: number[];  // Sky light attribute for terrain shader\n  grassIndices: number[];\n  grassVertexOffset: number;\n  dirtPositions: number[];\n  dirtNormals: number[];\n  dirtUvs: number[];\n  dirtSkyLight: number[];\n  dirtIndices: number[];\n  dirtVertexOffset: number;\n  stonePositions: number[];\n  stoneNormals: number[];\n  stoneUvs: number[];\n  stoneSkyLight: number[];\n  stoneIndices: number[];\n  stoneVertexOffset: number;\n  sandPositions: number[];\n  sandNormals: number[];\n  sandUvs: number[];\n  sandSkyLight: number[];\n  sandIndices: number[];\n  sandVertexOffset: number;\n  woodPositions: number[];\n  woodNormals: number[];\n  woodUvs: number[];\n  woodSkyLight: number[];\n  woodIndices: number[];\n  woodVertexOffset: number;\n  waterPositions: number[];\n  waterNormals: number[];\n  waterUvs: number[];\n  waterIndices: number[];\n  waterVertexOffset: number;\n  sidePositions: number[];\n  sideNormals: number[];\n  sideUvs: number[];\n  sideSkyLight: number[];\n  sideIndices: number[];\n  sideVertexOffset: number;\n  waterSidePositions: number[];\n  waterSideNormals: number[];\n  waterSideUvs: number[];\n  waterSideIndices: number[];\n  waterSideVertexOffset: number;\n}\n\nfunction createEmptyChunkGeometry(): ChunkGeometry {\n  return {\n    grassPositions: [], grassNormals: [], grassUvs: [], grassSkyLight: [], grassIndices: [], grassVertexOffset: 0,\n    dirtPositions: [], dirtNormals: [], dirtUvs: [], dirtSkyLight: [], dirtIndices: [], dirtVertexOffset: 0,\n    stonePositions: [], stoneNormals: [], stoneUvs: [], stoneSkyLight: [], stoneIndices: [], stoneVertexOffset: 0,\n    sandPositions: [], sandNormals: [], sandUvs: [], sandSkyLight: [], sandIndices: [], sandVertexOffset: 0,\n    woodPositions: [], woodNormals: [], woodUvs: [], woodSkyLight: [], woodIndices: [], woodVertexOffset: 0,\n    waterPositions: [], waterNormals: [], waterUvs: [], waterIndices: [], waterVertexOffset: 0,\n    sidePositions: [], sideNormals: [], sideUvs: [], sideSkyLight: [], sideIndices: [], sideVertexOffset: 0,\n    waterSidePositions: [], waterSideNormals: [], waterSideUvs: [], waterSideIndices: [], waterSideVertexOffset: 0\n  };\n}\n\n// Tile data passed from main thread\ninterface TileData {\n  index: number;\n  vertices: Vec3[];\n  center: Vec3;\n  neighbors: number[];\n}\n\n// Column data passed from main thread\ninterface ColumnData {\n  tileIndex: number;\n  tile: TileData;\n  blocks: number[];\n}\n\n// Pre-computed tile data for fast access\ninterface PrecomputedTileData {\n  normalizedCenter: Vec3;\n  normalizedVertices: Vec3[];\n  // Edge midpoint normalized directions (for neighbor lookup)\n  edgeMidDirs: Vec3[];\n  // Which neighbor is across each edge (index into neighbors array, -1 if none found)\n  edgeNeighborIdx: number[];\n  // Pre-computed normalized UVs for each vertex (0-1 range, touching edges)\n  normalizedUVs: { u: number; v: number }[];\n  // Center UV (where the face center maps to in UV space)\n  centerUV: { u: number; v: number };\n}\n\n// Block types (must match HexBlock.ts)\nconst HexBlockType = {\n  AIR: 0,\n  STONE: 1,\n  DIRT: 2,\n  GRASS: 3,\n  WATER: 4,\n  SAND: 5,\n  WOOD: 6,\n  LEAVES: 7\n};\n\n// Config passed from main thread\ninterface LODWorkerConfig {\n  radius: number;\n  blockHeight: number;\n  seaLevel: number;\n  waterSurfaceOffset: number;\n  lodOffset: number;\n  chunkCount: number;\n  // Camera direction from planet center for back-face culling\n  cameraDir?: Vec3;\n}\n\n// Message types\ninterface BuildLODGeometryMessage {\n  type: 'buildLODGeometry';\n  tileData: Record<number, TileData>;\n  blockData: Record<number, number[]>;\n  nearbyTiles: number[];\n  tileToChunk: Record<number, number>;\n  config: LODWorkerConfig;\n}\n\ninterface LODGeometryResultMessage {\n  type: 'lodGeometryResult';\n  chunkGeometries: ChunkGeometry[];\n}\n\n// Cached pre-computed data (persists across messages for same tile structure)\nlet cachedPrecomputed: Map<number, PrecomputedTileData> | null = null;\nlet cachedTileCount = 0;\n\n// Worker message handler\nself.onmessage = (e: MessageEvent<BuildLODGeometryMessage>) => {\n  const { type, tileData, blockData, nearbyTiles, tileToChunk, config } = e.data;\n\n  if (type === 'buildLODGeometry') {\n    const nearbyTilesSet = new Set(nearbyTiles);\n    const tileToChunkMap = new Map(Object.entries(tileToChunk).map(([k, v]) => [parseInt(k), v]));\n\n    // Reconstruct columns from separate tile and block data\n    const columnsMap = new Map<number, ColumnData>();\n    for (const [tileIndexStr, tile] of Object.entries(tileData)) {\n      const tileIndex = parseInt(tileIndexStr);\n      const blocks = blockData[tileIndex];\n      if (blocks) {\n        columnsMap.set(tileIndex, { tileIndex, tile, blocks });\n      }\n    }\n\n    // Pre-compute normalized data if not cached or tile count changed\n    const tileCount = Object.keys(tileData).length;\n    if (!cachedPrecomputed || cachedTileCount !== tileCount) {\n      cachedPrecomputed = new Map();\n      cachedTileCount = tileCount;\n\n      for (const [tileIndex, column] of columnsMap) {\n        const tile = column.tile;\n        const numVerts = tile.vertices.length;\n\n        // Normalize center once\n        const centerLen = Math.sqrt(tile.center.x * tile.center.x + tile.center.y * tile.center.y + tile.center.z * tile.center.z);\n        const normalizedCenter: Vec3 = centerLen > 0\n          ? { x: tile.center.x / centerLen, y: tile.center.y / centerLen, z: tile.center.z / centerLen }\n          : { x: 0, y: 0, z: 0 };\n\n        // Normalize all vertices once\n        const normalizedVertices: Vec3[] = [];\n        for (const v of tile.vertices) {\n          const vLen = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n          normalizedVertices.push(vLen > 0\n            ? { x: v.x / vLen, y: v.y / vLen, z: v.z / vLen }\n            : { x: 0, y: 0, z: 0 });\n        }\n\n        // Pre-compute edge midpoint directions\n        const edgeMidDirs: Vec3[] = [];\n        for (let i = 0; i < numVerts; i++) {\n          const next = (i + 1) % numVerts;\n          const v1 = tile.vertices[i];\n          const v2 = tile.vertices[next];\n          const midX = v1.x + v2.x;\n          const midY = v1.y + v2.y;\n          const midZ = v1.z + v2.z;\n          const midLen = Math.sqrt(midX * midX + midY * midY + midZ * midZ);\n          edgeMidDirs.push(midLen > 0\n            ? { x: midX / midLen, y: midY / midLen, z: midZ / midLen }\n            : { x: 0, y: 0, z: 0 });\n        }\n\n        // Pre-compute which neighbor is across each edge\n        const edgeNeighborIdx: number[] = [];\n        for (let i = 0; i < numVerts; i++) {\n          const edgeMidDir = edgeMidDirs[i];\n          let closestNeighbor = -1;\n          let closestDist = Infinity;\n\n          for (const nIdx of tile.neighbors) {\n            const neighborColumn = columnsMap.get(nIdx);\n            if (!neighborColumn) continue;\n\n            const nc = neighborColumn.tile.center;\n            const ncLen = Math.sqrt(nc.x * nc.x + nc.y * nc.y + nc.z * nc.z);\n            if (ncLen === 0) continue;\n\n            const ncNormX = nc.x / ncLen;\n            const ncNormY = nc.y / ncLen;\n            const ncNormZ = nc.z / ncLen;\n\n            const dx = ncNormX - edgeMidDir.x;\n            const dy = ncNormY - edgeMidDir.y;\n            const dz = ncNormZ - edgeMidDir.z;\n            const dist = dx * dx + dy * dy + dz * dz;\n\n            if (dist < closestDist) {\n              closestDist = dist;\n              closestNeighbor = nIdx;\n            }\n          }\n          edgeNeighborIdx.push(closestNeighbor);\n        }\n\n        // Pre-compute local coordinate system for UV mapping\n        // Create tangent and bitangent vectors perpendicular to the normal\n        const up: Vec3 = Math.abs(normalizedCenter.y) < 0.9\n          ? { x: 0, y: 1, z: 0 }\n          : { x: 1, y: 0, z: 0 };\n\n        // tangent = cross(up, normal)\n        const tangentX = up.y * normalizedCenter.z - up.z * normalizedCenter.y;\n        const tangentY = up.z * normalizedCenter.x - up.x * normalizedCenter.z;\n        const tangentZ = up.x * normalizedCenter.y - up.y * normalizedCenter.x;\n        const tangentLen = Math.sqrt(tangentX * tangentX + tangentY * tangentY + tangentZ * tangentZ);\n        const tangent: Vec3 = tangentLen > 0\n          ? { x: tangentX / tangentLen, y: tangentY / tangentLen, z: tangentZ / tangentLen }\n          : { x: 1, y: 0, z: 0 };\n\n        // bitangent = cross(normal, tangent)\n        const bitangentX = normalizedCenter.y * tangent.z - normalizedCenter.z * tangent.y;\n        const bitangentY = normalizedCenter.z * tangent.x - normalizedCenter.x * tangent.z;\n        const bitangentZ = normalizedCenter.x * tangent.y - normalizedCenter.y * tangent.x;\n        const bitangent: Vec3 = { x: bitangentX, y: bitangentY, z: bitangentZ };\n\n        // Project vertices onto local 2D plane and find bounding box\n        const localCoords: { u: number; v: number }[] = [];\n        let minU = Infinity, maxU = -Infinity, minV = Infinity, maxV = -Infinity;\n\n        for (const vert of tile.vertices) {\n          // Vector from center to vertex\n          const toVertX = vert.x - tile.center.x;\n          const toVertY = vert.y - tile.center.y;\n          const toVertZ = vert.z - tile.center.z;\n\n          // Project onto tangent and bitangent\n          const u = toVertX * tangent.x + toVertY * tangent.y + toVertZ * tangent.z;\n          const v = toVertX * bitangent.x + toVertY * bitangent.y + toVertZ * bitangent.z;\n          localCoords.push({ u, v });\n\n          minU = Math.min(minU, u);\n          maxU = Math.max(maxU, u);\n          minV = Math.min(minV, v);\n          maxV = Math.max(maxV, v);\n        }\n\n        // Normalize UVs to 0-1 range\n        const rangeU = maxU - minU;\n        const rangeV = maxV - minV;\n        const normalizedUVs: { u: number; v: number }[] = localCoords.map(coord => ({\n          u: (coord.u - minU) / rangeU,\n          v: (coord.v - minV) / rangeV\n        }));\n\n        // Center UV (the center vertex at (0,0) in local coords maps to this UV)\n        const centerUV = {\n          u: (0 - minU) / rangeU,\n          v: (0 - minV) / rangeV\n        };\n\n        cachedPrecomputed.set(tileIndex, {\n          normalizedCenter,\n          normalizedVertices,\n          edgeMidDirs,\n          edgeNeighborIdx,\n          normalizedUVs,\n          centerUV\n        });\n      }\n    }\n\n    const chunkGeometries: ChunkGeometry[] = [];\n    for (let i = 0; i < config.chunkCount; i++) {\n      chunkGeometries.push(createEmptyChunkGeometry());\n    }\n\n    const waterRadius = config.radius - config.seaLevel * config.blockHeight - config.lodOffset;\n\n    // Combined first pass: calculate display radius AND surface block type for each tile\n    // This eliminates redundant block array searches\n    interface TileInfo {\n      radius: number;\n      isWater: boolean;\n      surfaceBlockType: number;\n    }\n    const tileInfo = new Map<number, TileInfo>();\n\n    for (const [tileIndex, column] of columnsMap) {\n      let surfaceDepth = 0;\n      let surfaceBlockType = HexBlockType.GRASS;\n      const blocks = column.blocks;\n      for (let d = 0; d < blocks.length; d++) {\n        if (blocks[d] !== HexBlockType.AIR) {\n          surfaceDepth = d;\n          surfaceBlockType = blocks[d];\n          break;\n        }\n      }\n\n      const isWater = surfaceBlockType === HexBlockType.WATER;\n      const displayRadius = isWater\n        ? waterRadius\n        : config.radius - surfaceDepth * config.blockHeight - config.lodOffset;\n\n      tileInfo.set(tileIndex, { radius: displayRadius, isWater, surfaceBlockType });\n    }\n\n    // Back-face culling threshold: skip tiles facing away from camera\n    // Use -0.2 to include tiles slightly past the horizon (for smooth edges)\n    const cameraDir = config.cameraDir;\n    const CULL_THRESHOLD = -0.2;\n\n    // Second pass: build top faces for LOD tiles (uses cached data)\n    for (const [tileIndex] of columnsMap) {\n      if (nearbyTilesSet.has(tileIndex)) continue;\n\n      const precomputed = cachedPrecomputed.get(tileIndex)!;\n\n      // Back-face culling: skip tiles facing away from camera\n      if (cameraDir) {\n        const nc = precomputed.normalizedCenter;\n        const dot = nc.x * cameraDir.x + nc.y * cameraDir.y + nc.z * cameraDir.z;\n        if (dot < CULL_THRESHOLD) continue;\n      }\n\n      const info = tileInfo.get(tileIndex)!\n      const displayRadius = info.radius;\n      const surfaceBlockType = info.surfaceBlockType;\n\n      const chunkIdx = tileToChunkMap.get(tileIndex) ?? 0;\n      const chunk = chunkGeometries[chunkIdx];\n\n      // Select buffer based on surface type\n      let positions: number[], normals: number[], uvs: number[], skyLight: number[] | null, indices: number[];\n      let vertexOffset: number;\n\n      if (surfaceBlockType === HexBlockType.WATER) {\n        positions = chunk.waterPositions;\n        normals = chunk.waterNormals;\n        uvs = chunk.waterUvs;\n        skyLight = null; // Water uses different shader, doesn't need skyLight\n        indices = chunk.waterIndices;\n        vertexOffset = chunk.waterVertexOffset;\n      } else if (surfaceBlockType === HexBlockType.DIRT) {\n        positions = chunk.dirtPositions;\n        normals = chunk.dirtNormals;\n        uvs = chunk.dirtUvs;\n        skyLight = chunk.dirtSkyLight;\n        indices = chunk.dirtIndices;\n        vertexOffset = chunk.dirtVertexOffset;\n      } else if (surfaceBlockType === HexBlockType.STONE) {\n        positions = chunk.stonePositions;\n        normals = chunk.stoneNormals;\n        uvs = chunk.stoneUvs;\n        skyLight = chunk.stoneSkyLight;\n        indices = chunk.stoneIndices;\n        vertexOffset = chunk.stoneVertexOffset;\n      } else if (surfaceBlockType === HexBlockType.SAND) {\n        positions = chunk.sandPositions;\n        normals = chunk.sandNormals;\n        uvs = chunk.sandUvs;\n        skyLight = chunk.sandSkyLight;\n        indices = chunk.sandIndices;\n        vertexOffset = chunk.sandVertexOffset;\n      } else if (surfaceBlockType === HexBlockType.WOOD) {\n        positions = chunk.woodPositions;\n        normals = chunk.woodNormals;\n        uvs = chunk.woodUvs;\n        skyLight = chunk.woodSkyLight;\n        indices = chunk.woodIndices;\n        vertexOffset = chunk.woodVertexOffset;\n      } else {\n        // GRASS, LEAVES, or any other type defaults to grass\n        positions = chunk.grassPositions;\n        normals = chunk.grassNormals;\n        uvs = chunk.grassUvs;\n        skyLight = chunk.grassSkyLight;\n        indices = chunk.grassIndices;\n        vertexOffset = chunk.grassVertexOffset;\n      }\n\n      // Use pre-computed normalized center, vertices, and UVs\n      const normal = precomputed.normalizedCenter;\n      const normalizedVerts = precomputed.normalizedVertices;\n      const normalizedUVs = precomputed.normalizedUVs;\n      const centerUV = precomputed.centerUV;\n\n      // Fan triangulation from center\n      const centerIdx = vertexOffset;\n      positions.push(\n        normal.x * displayRadius,\n        normal.y * displayRadius,\n        normal.z * displayRadius\n      );\n      normals.push(normal.x, normal.y, normal.z);\n      uvs.push(centerUV.u, centerUV.v);\n      if (skyLight) skyLight.push(1.0); // LOD terrain is always at surface, full sky exposure\n      vertexOffset++;\n\n      for (let i = 0; i < normalizedVerts.length; i++) {\n        const nv = normalizedVerts[i];\n        positions.push(nv.x * displayRadius, nv.y * displayRadius, nv.z * displayRadius);\n        normals.push(normal.x, normal.y, normal.z);\n        uvs.push(normalizedUVs[i].u, normalizedUVs[i].v);\n        if (skyLight) skyLight.push(1.0);\n        vertexOffset++;\n\n        indices.push(centerIdx, centerIdx + 1 + i, centerIdx + 1 + ((i + 1) % normalizedVerts.length));\n      }\n\n      // Update offset\n      if (surfaceBlockType === HexBlockType.WATER) {\n        chunk.waterVertexOffset = vertexOffset;\n      } else if (surfaceBlockType === HexBlockType.DIRT) {\n        chunk.dirtVertexOffset = vertexOffset;\n      } else if (surfaceBlockType === HexBlockType.STONE) {\n        chunk.stoneVertexOffset = vertexOffset;\n      } else if (surfaceBlockType === HexBlockType.SAND) {\n        chunk.sandVertexOffset = vertexOffset;\n      } else if (surfaceBlockType === HexBlockType.WOOD) {\n        chunk.woodVertexOffset = vertexOffset;\n      } else {\n        chunk.grassVertexOffset = vertexOffset;\n      }\n    }\n\n    // Third pass: generate side walls (uses cached edge-neighbor mapping)\n    for (const [tileIndex] of columnsMap) {\n      if (nearbyTilesSet.has(tileIndex)) continue;\n\n      const precomputed = cachedPrecomputed.get(tileIndex)!;\n\n      // Back-face culling: skip tiles facing away from camera\n      if (cameraDir) {\n        const nc = precomputed.normalizedCenter;\n        const dot = nc.x * cameraDir.x + nc.y * cameraDir.y + nc.z * cameraDir.z;\n        if (dot < CULL_THRESHOLD) continue;\n      }\n\n      const info = tileInfo.get(tileIndex)!\n      const thisRadius = info.radius;\n      const thisIsWater = info.isWater;\n      const normalizedVerts = precomputed.normalizedVertices;\n      const edgeNeighborIdx = precomputed.edgeNeighborIdx;\n      const numSides = normalizedVerts.length;\n\n      const chunkIdx = tileToChunkMap.get(tileIndex) ?? 0;\n      const chunk = chunkGeometries[chunkIdx];\n\n      for (let i = 0; i < numSides; i++) {\n        const neighborTileIdx = edgeNeighborIdx[i];\n        if (neighborTileIdx < 0) continue;\n\n        const neighborInfo = tileInfo.get(neighborTileIdx);\n        if (!neighborInfo) continue;\n\n        const neighborRadius = neighborInfo.radius;\n\n        // Generate wall only when this tile is higher than neighbor\n        // This applies to both solid and water tiles - walls show height differences\n        if (thisRadius <= neighborRadius) continue;\n\n        const next = (i + 1) % numSides;\n        const nv1 = normalizedVerts[i];\n        const nv2 = normalizedVerts[next];\n\n        // Create wall vertices using pre-normalized directions\n        const innerV1x = nv1.x * neighborRadius, innerV1y = nv1.y * neighborRadius, innerV1z = nv1.z * neighborRadius;\n        const innerV2x = nv2.x * neighborRadius, innerV2y = nv2.y * neighborRadius, innerV2z = nv2.z * neighborRadius;\n        const outerV1x = nv1.x * thisRadius, outerV1y = nv1.y * thisRadius, outerV1z = nv1.z * thisRadius;\n        const outerV2x = nv2.x * thisRadius, outerV2y = nv2.y * thisRadius, outerV2z = nv2.z * thisRadius;\n\n        // Calculate side normal\n        const edge1x = innerV2x - innerV1x, edge1y = innerV2y - innerV1y, edge1z = innerV2z - innerV1z;\n        const edge2x = outerV1x - innerV1x, edge2y = outerV1y - innerV1y, edge2z = outerV1z - innerV1z;\n        const crossX = edge1y * edge2z - edge1z * edge2y;\n        const crossY = edge1z * edge2x - edge1x * edge2z;\n        const crossZ = edge1x * edge2y - edge1y * edge2x;\n        const crossLen = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);\n        const snx = crossLen > 0 ? crossX / crossLen : 0;\n        const sny = crossLen > 0 ? crossY / crossLen : 0;\n        const snz = crossLen > 0 ? crossZ / crossLen : 0;\n\n        const positions = thisIsWater ? chunk.waterSidePositions : chunk.sidePositions;\n        const normals = thisIsWater ? chunk.waterSideNormals : chunk.sideNormals;\n        const uvs = thisIsWater ? chunk.waterSideUvs : chunk.sideUvs;\n        const skyLight = thisIsWater ? null : chunk.sideSkyLight;\n        const indices = thisIsWater ? chunk.waterSideIndices : chunk.sideIndices;\n        const baseIdx = thisIsWater ? chunk.waterSideVertexOffset : chunk.sideVertexOffset;\n\n        positions.push(\n          innerV1x, innerV1y, innerV1z,\n          innerV2x, innerV2y, innerV2z,\n          outerV2x, outerV2y, outerV2z,\n          outerV1x, outerV1y, outerV1z\n        );\n\n        normals.push(snx, sny, snz, snx, sny, snz, snx, sny, snz, snx, sny, snz);\n        uvs.push(0, 0, 1, 0, 1, 1, 0, 1);\n        if (skyLight) skyLight.push(1.0, 1.0, 1.0, 1.0); // Full sky exposure for LOD\n\n        indices.push(baseIdx, baseIdx + 1, baseIdx + 2);\n        indices.push(baseIdx, baseIdx + 2, baseIdx + 3);\n\n        if (thisIsWater) {\n          chunk.waterSideVertexOffset += 4;\n        } else {\n          chunk.sideVertexOffset += 4;\n        }\n      }\n    }\n\n    // Fourth pass: water boundary walls at LOD/terrain edge\n    for (const [tileIndex] of columnsMap) {\n      if (nearbyTilesSet.has(tileIndex)) continue;\n\n      const precomputed = cachedPrecomputed.get(tileIndex)!;\n\n      // Back-face culling: skip tiles facing away from camera\n      if (cameraDir) {\n        const nc = precomputed.normalizedCenter;\n        const dot = nc.x * cameraDir.x + nc.y * cameraDir.y + nc.z * cameraDir.z;\n        if (dot < CULL_THRESHOLD) continue;\n      }\n\n      const info = tileInfo.get(tileIndex);\n      if (!info || !info.isWater) continue;\n      const normalizedVerts = precomputed.normalizedVertices;\n      const edgeNeighborIdx = precomputed.edgeNeighborIdx;\n      const numSides = normalizedVerts.length;\n\n      const chunkIdx = tileToChunkMap.get(tileIndex) ?? 0;\n      const chunk = chunkGeometries[chunkIdx];\n\n      for (let i = 0; i < numSides; i++) {\n        const neighborTileIdx = edgeNeighborIdx[i];\n        if (neighborTileIdx < 0) continue;\n        if (!nearbyTilesSet.has(neighborTileIdx)) continue;\n\n        const neighborInfo = tileInfo.get(neighborTileIdx);\n        if (!neighborInfo) continue;\n\n        const bottomRadius = neighborInfo.radius;\n        const topRadius = waterRadius;\n        if (bottomRadius >= topRadius) continue;\n\n        const next = (i + 1) % numSides;\n        const nv1 = normalizedVerts[i];\n        const nv2 = normalizedVerts[next];\n\n        const innerV1x = nv1.x * bottomRadius, innerV1y = nv1.y * bottomRadius, innerV1z = nv1.z * bottomRadius;\n        const innerV2x = nv2.x * bottomRadius, innerV2y = nv2.y * bottomRadius, innerV2z = nv2.z * bottomRadius;\n        const outerV1x = nv1.x * topRadius, outerV1y = nv1.y * topRadius, outerV1z = nv1.z * topRadius;\n        const outerV2x = nv2.x * topRadius, outerV2y = nv2.y * topRadius, outerV2z = nv2.z * topRadius;\n\n        const edge1x = innerV2x - innerV1x, edge1y = innerV2y - innerV1y, edge1z = innerV2z - innerV1z;\n        const edge2x = outerV1x - innerV1x, edge2y = outerV1y - innerV1y, edge2z = outerV1z - innerV1z;\n        const crossX = edge1y * edge2z - edge1z * edge2y;\n        const crossY = edge1z * edge2x - edge1x * edge2z;\n        const crossZ = edge1x * edge2y - edge1y * edge2x;\n        const crossLen = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);\n        const snx = crossLen > 0 ? crossX / crossLen : 0;\n        const sny = crossLen > 0 ? crossY / crossLen : 0;\n        const snz = crossLen > 0 ? crossZ / crossLen : 0;\n\n        const baseIdx = chunk.waterSideVertexOffset;\n\n        chunk.waterSidePositions.push(\n          innerV1x, innerV1y, innerV1z,\n          innerV2x, innerV2y, innerV2z,\n          outerV2x, outerV2y, outerV2z,\n          outerV1x, outerV1y, outerV1z\n        );\n\n        chunk.waterSideNormals.push(snx, sny, snz, snx, sny, snz, snx, sny, snz, snx, sny, snz);\n        chunk.waterSideUvs.push(0, 0, 1, 0, 1, 1, 0, 1);\n\n        chunk.waterSideIndices.push(baseIdx, baseIdx + 1, baseIdx + 2);\n        chunk.waterSideIndices.push(baseIdx, baseIdx + 2, baseIdx + 3);\n\n        chunk.waterSideVertexOffset += 4;\n      }\n    }\n\n    const result: LODGeometryResultMessage = {\n      type: 'lodGeometryResult',\n      chunkGeometries\n    };\n\n    self.postMessage(result);\n  }\n};\n\nexport {};\n"],"names":["createEmptyChunkGeometry","HexBlockType","cachedPrecomputed","cachedTileCount","e","type","tileData","blockData","nearbyTiles","tileToChunk","config","nearbyTilesSet","tileToChunkMap","k","v","columnsMap","tileIndexStr","tile","tileIndex","blocks","tileCount","column","numVerts","centerLen","normalizedCenter","normalizedVertices","vLen","edgeMidDirs","i","next","v1","v2","midX","midY","midZ","midLen","edgeNeighborIdx","edgeMidDir","closestNeighbor","closestDist","nIdx","neighborColumn","nc","ncLen","ncNormX","ncNormY","ncNormZ","dx","dy","dz","dist","up","tangentX","tangentY","tangentZ","tangentLen","tangent","bitangentX","bitangentY","bitangentZ","bitangent","localCoords","minU","maxU","minV","maxV","vert","toVertX","toVertY","toVertZ","u","rangeU","rangeV","normalizedUVs","coord","centerUV","chunkGeometries","waterRadius","tileInfo","surfaceDepth","surfaceBlockType","d","isWater","displayRadius","cameraDir","CULL_THRESHOLD","precomputed","info","chunkIdx","chunk","positions","normals","uvs","skyLight","indices","vertexOffset","normal","normalizedVerts","centerIdx","nv","thisRadius","thisIsWater","numSides","neighborTileIdx","neighborInfo","neighborRadius","nv1","nv2","innerV1x","innerV1y","innerV1z","innerV2x","innerV2y","innerV2z","outerV1x","outerV1y","outerV1z","outerV2x","outerV2y","outerV2z","edge1x","edge1y","edge1z","edge2x","edge2y","edge2z","crossX","crossY","crossZ","crossLen","snx","sny","snz","baseIdx","bottomRadius","topRadius","result"],"mappings":"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"}