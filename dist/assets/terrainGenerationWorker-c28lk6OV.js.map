{"version":3,"file":"terrainGenerationWorker-c28lk6OV.js","sources":["../src/shared/blockTypes.ts","../src/workers/terrainGenerationWorker.ts"],"sourcesContent":["// Shared block type definitions and helpers\n// This module is used by both main thread and web workers\n\nexport enum HexBlockType {\n  AIR = 0,\n  STONE = 1,\n  DIRT = 2,\n  GRASS = 3,\n  WATER = 4,\n  SAND = 5,\n  WOOD = 6,\n  LEAVES = 7,\n  // Mineral ores (underground)\n  ORE_COAL = 8,\n  ORE_COPPER = 9,\n  ORE_IRON = 10,\n  ORE_GOLD = 11,\n  ORE_LITHIUM = 12,\n  ORE_ALUMINUM = 13,\n  ORE_COBALT = 14,\n  // Snow biome blocks\n  SNOW = 15,\n  DIRT_SNOW = 16,  // Dirt with snow on top\n  ICE = 17,\n  // Technology blocks\n  FURNACE = 18,\n  // Glass (transparent like ice)\n  GLASS = 19,\n  // Advanced technology blocks\n  COMPUTER = 20,\n  PRINTER_3D = 21,\n  // Moon terrain block\n  MOON_ROCK = 22\n}\n\nexport function isSolid(blockType: HexBlockType | number): boolean {\n  return blockType !== HexBlockType.AIR && blockType !== HexBlockType.WATER;\n}\n\nexport function isLiquid(blockType: HexBlockType | number): boolean {\n  return blockType === HexBlockType.WATER;\n}\n\nexport function isTransparent(blockType: HexBlockType | number): boolean {\n  return blockType === HexBlockType.AIR || blockType === HexBlockType.WATER || blockType === HexBlockType.ICE || blockType === HexBlockType.GLASS;\n}\n\nexport function isSemiTransparent(blockType: HexBlockType | number): boolean {\n  return blockType === HexBlockType.ICE || blockType === HexBlockType.GLASS;\n}\n","// Terrain Generation Worker - generates planet terrain blocks off the main thread\n// This allows planet initialization to happen without blocking the UI\n\nimport { HexBlockType } from '../shared/blockTypes';\nimport { Vec3 } from '../shared/vec3';\n\n// Tile data passed from main thread (serializable)\ninterface TileData {\n  index: number;\n  center: Vec3;  // Normalized center position\n  neighbors: number[];\n}\n\n// Planet config passed from main thread\ninterface TerrainConfig {\n  seed: number;\n  maxDepth: number;\n  seaLevel: number;\n  maxHeight: number;\n  hasWater: boolean;\n  isSingleTexturePlanet: boolean;  // Moon-like planets\n  heightVariation: number;\n  polarThreshold: number;\n  // Terrain generation parameters\n  continentScale: number;\n  mountainScale: number;\n  hillScale: number;\n  detailScale: number;\n  continentWeight: number;\n  mountainHeight: number;\n  hillWeight: number;\n  detailWeight: number;\n  oceanDepthPower: number;\n  terrainMaxDepth: number;\n  // Ore configs\n  oreConfigs: OreConfig[];\n}\n\ninterface OreConfig {\n  type: number;  // HexBlockType value\n  minDepth: number;\n  maxDepth: number;\n  veinChance: number;\n  veinSize: number;\n  spreadFactor: number;\n}\n\n// Message types\ninterface GenerateTerrainMessage {\n  type: 'generateTerrain';\n  tiles: TileData[];\n  config: TerrainConfig;\n}\n\n// Result format for postMessage (Maps don't serialize well)\ninterface SerializableTerrainResult {\n  type: 'terrainResult';\n  columns: Array<[number, number[]]>;  // Array of [tileIndex, blocks] pairs\n}\n\n// ============ NOISE FUNCTIONS ============\n// These are pure functions that don't depend on any external state\n\nfunction hash3D(x: number, y: number, z: number, seed: number): number {\n  let h = (x * 374761393 + y * 668265263 + z * 1274126177 + seed) | 0;\n  h = ((h ^ (h >> 13)) * 1274126177) | 0;\n  return h ^ (h >> 16);\n}\n\nfunction grad3D(ix: number, iy: number, iz: number, x: number, y: number, z: number, seed: number): number {\n  const hash = hash3D(ix, iy, iz, seed) & 15;\n  const gradients = [\n    [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],\n    [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],\n    [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1],\n    [1, 1, 0], [-1, 1, 0], [0, -1, 1], [0, -1, -1]\n  ];\n  const g = gradients[hash];\n  return g[0] * x + g[1] * y + g[2] * z;\n}\n\nfunction simplex3D(x: number, y: number, z: number, seed: number): number {\n  const F3 = 1.0 / 3.0;\n  const G3 = 1.0 / 6.0;\n\n  // Incorporate seed\n  x += seed * 0.1;\n  y += seed * 0.13;\n  z += seed * 0.17;\n\n  const s = (x + y + z) * F3;\n  const i = Math.floor(x + s);\n  const j = Math.floor(y + s);\n  const k = Math.floor(z + s);\n\n  const t = (i + j + k) * G3;\n  const X0 = i - t;\n  const Y0 = j - t;\n  const Z0 = k - t;\n\n  const x0 = x - X0;\n  const y0 = y - Y0;\n  const z0 = z - Z0;\n\n  let i1: number, j1: number, k1: number;\n  let i2: number, j2: number, k2: number;\n\n  if (x0 >= y0) {\n    if (y0 >= z0) {\n      i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;\n    } else if (x0 >= z0) {\n      i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1;\n    } else {\n      i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1;\n    }\n  } else {\n    if (y0 < z0) {\n      i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1;\n    } else if (x0 < z0) {\n      i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1;\n    } else {\n      i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0;\n    }\n  }\n\n  const x1 = x0 - i1 + G3;\n  const y1 = y0 - j1 + G3;\n  const z1 = z0 - k1 + G3;\n  const x2 = x0 - i2 + 2.0 * G3;\n  const y2 = y0 - j2 + 2.0 * G3;\n  const z2 = z0 - k2 + 2.0 * G3;\n  const x3 = x0 - 1.0 + 3.0 * G3;\n  const y3 = y0 - 1.0 + 3.0 * G3;\n  const z3 = z0 - 1.0 + 3.0 * G3;\n\n  let n0 = 0, n1 = 0, n2 = 0, n3 = 0;\n\n  let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n  if (t0 >= 0) {\n    t0 *= t0;\n    n0 = t0 * t0 * grad3D(i, j, k, x0, y0, z0, seed);\n  }\n\n  let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n  if (t1 >= 0) {\n    t1 *= t1;\n    n1 = t1 * t1 * grad3D(i + i1, j + j1, k + k1, x1, y1, z1, seed);\n  }\n\n  let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n  if (t2 >= 0) {\n    t2 *= t2;\n    n2 = t2 * t2 * grad3D(i + i2, j + j2, k + k2, x2, y2, z2, seed);\n  }\n\n  let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n  if (t3 >= 0) {\n    t3 *= t3;\n    n3 = t3 * t3 * grad3D(i + 1, j + 1, k + 1, x3, y3, z3, seed);\n  }\n\n  return 32.0 * (n0 + n1 + n2 + n3);\n}\n\nfunction fractalSimplex3D(\n  x: number, y: number, z: number,\n  period: number,\n  octaves: number,\n  persistence: number,\n  lacunarity: number,\n  seed: number\n): number {\n  let value = 0;\n  let amplitude = 1;\n  let frequency = period;\n  let maxValue = 0;\n\n  for (let i = 0; i < octaves; i++) {\n    value += simplex3D(x * frequency, y * frequency, z * frequency, seed) * amplitude;\n    maxValue += amplitude;\n    amplitude *= persistence;\n    frequency *= lacunarity;\n  }\n\n  return value / maxValue;\n}\n\nfunction ridgeSimplex3D(\n  x: number, y: number, z: number,\n  period: number,\n  octaves: number,\n  persistence: number,\n  lacunarity: number,\n  seed: number\n): number {\n  let value = 0;\n  let amplitude = 1;\n  let frequency = period;\n  let maxValue = 0;\n\n  for (let i = 0; i < octaves; i++) {\n    const noise = simplex3D(x * frequency, y * frequency, z * frequency, seed);\n    const ridge = 1.0 - Math.abs(noise);\n    value += ridge * ridge * amplitude;\n    maxValue += amplitude;\n    amplitude *= persistence;\n    frequency *= lacunarity;\n  }\n\n  return value / maxValue;\n}\n\n// ============ HEIGHT VARIATION ============\n\nfunction getHeightVariation(center: Vec3, config: TerrainConfig): number {\n  const variation = config.heightVariation;\n  const len = Math.sqrt(center.x * center.x + center.y * center.y + center.z * center.z);\n  const dirX = center.x / len;\n  const dirY = center.y / len;\n  const dirZ = center.z / len;\n\n  // Layer 1: Continental Base\n  const continentNoise = fractalSimplex3D(\n    dirX, dirY, dirZ,\n    config.continentScale,\n    6, 0.5, 2.0,\n    config.seed\n  );\n  const continentValue = Math.sign(continentNoise) * Math.pow(Math.abs(continentNoise), 0.8);\n\n  // Layer 2: Mountain Ridges\n  const mountainNoise = ridgeSimplex3D(\n    dirX, dirY, dirZ,\n    config.mountainScale,\n    4, 0.5, 2.2,\n    config.seed\n  );\n  const landFactor = Math.max(0, continentValue);\n  const mountainHeight = mountainNoise * landFactor * config.mountainHeight;\n\n  // Layer 3: Hills and Variation\n  const hillNoise = fractalSimplex3D(\n    dirX, dirY, dirZ,\n    config.hillScale,\n    3, 0.5, 2.0,\n    config.seed\n  );\n\n  // Layer 4: Surface Detail\n  const detailNoise = fractalSimplex3D(\n    dirX, dirY, dirZ,\n    config.detailScale,\n    2, 0.5, 2.0,\n    config.seed\n  );\n\n  // Combine all layers\n  let height = continentValue * config.continentWeight;\n  height += mountainHeight;\n  height += hillNoise * config.hillWeight * (landFactor > 0.1 ? 1.0 : 0.3);\n  height += detailNoise * config.detailWeight;\n\n  // Convert height to depth\n  const SEA_LEVEL_DEPTH = config.maxDepth - 1 - config.seaLevel;\n\n  let depth: number;\n  if (height >= 0) {\n    const landHeight = height * config.maxHeight * variation;\n    depth = SEA_LEVEL_DEPTH + landHeight;\n  } else {\n    const oceanFactor = Math.pow(Math.abs(height), config.oceanDepthPower);\n    const oceanDepth = oceanFactor * config.terrainMaxDepth * variation;\n    depth = SEA_LEVEL_DEPTH - oceanDepth;\n  }\n\n  return Math.max(0, Math.min(config.maxDepth - 1, Math.round(depth)));\n}\n\n// ============ ORE GENERATION ============\n\nfunction seededRandom(seed: number): number {\n  const x = Math.sin(seed) * 43758.5453;\n  return x - Math.floor(x);\n}\n\nfunction generateOreVeins(\n  tiles: TileData[],\n  config: TerrainConfig\n): Map<string, number> {\n  const oreVeinCache = new Map<string, number>();\n\n  // Build neighbor lookup\n  const tileNeighbors = new Map<number, number[]>();\n  for (const tile of tiles) {\n    tileNeighbors.set(tile.index, tile.neighbors);\n  }\n\n  // For each ore type, generate vein seed points\n  for (const oreConfig of config.oreConfigs) {\n    const oreSeedOffset = oreConfig.type * 31337;\n\n    for (const tile of tiles) {\n      const tileIndex = tile.index;\n      for (let depth = oreConfig.minDepth; depth <= oreConfig.maxDepth; depth++) {\n        const key = `${tileIndex},${depth}`;\n        if (oreVeinCache.has(key)) continue;\n\n        const seed = config.seed + oreSeedOffset + tileIndex * 7919 + depth * 104729;\n        const random = seededRandom(seed);\n\n        if (random < oreConfig.veinChance) {\n          spreadOreVein(tileIndex, depth, oreConfig, seed, tileNeighbors, oreVeinCache);\n        }\n      }\n    }\n  }\n\n  return oreVeinCache;\n}\n\nfunction spreadOreVein(\n  seedTileIndex: number,\n  seedDepth: number,\n  config: OreConfig,\n  baseSeed: number,\n  tileNeighbors: Map<number, number[]>,\n  oreVeinCache: Map<string, number>\n): void {\n  const toVisit: Array<{ tileIndex: number; depth: number; probability: number }> = [];\n  const visited = new Set<string>();\n\n  toVisit.push({ tileIndex: seedTileIndex, depth: seedDepth, probability: 1.0 });\n\n  let blocksPlaced = 0;\n  const maxBlocks = config.veinSize + Math.floor(seededRandom(baseSeed + 999) * config.veinSize * 0.5);\n\n  while (toVisit.length > 0 && blocksPlaced < maxBlocks) {\n    const current = toVisit.shift()!;\n    const key = `${current.tileIndex},${current.depth}`;\n\n    if (visited.has(key)) continue;\n    visited.add(key);\n\n    if (current.depth < config.minDepth || current.depth > config.maxDepth) continue;\n\n    const placeSeed = baseSeed + current.tileIndex * 13 + current.depth * 17;\n    if (seededRandom(placeSeed) > current.probability) continue;\n\n    if (oreVeinCache.has(key)) continue;\n\n    oreVeinCache.set(key, config.type);\n    blocksPlaced++;\n\n    const neighborProb = current.probability * config.spreadFactor;\n    if (neighborProb < 0.1) continue;\n\n    // Spread to vertical neighbors\n    toVisit.push({ tileIndex: current.tileIndex, depth: current.depth - 1, probability: neighborProb });\n    toVisit.push({ tileIndex: current.tileIndex, depth: current.depth + 1, probability: neighborProb });\n\n    // Spread to horizontal neighbors\n    const neighbors = tileNeighbors.get(current.tileIndex);\n    if (neighbors) {\n      for (const neighborIdx of neighbors) {\n        toVisit.push({ tileIndex: neighborIdx, depth: current.depth, probability: neighborProb * 0.8 });\n      }\n    }\n  }\n}\n\n// ============ TERRAIN GENERATION ============\n\nfunction generateTerrain(tiles: TileData[], config: TerrainConfig): Map<number, number[]> {\n  const columns = new Map<number, number[]>();\n\n  // Generate ore veins first\n  const oreVeinCache = generateOreVeins(tiles, config);\n\n  // First pass: Generate height map\n  const heightMap = new Map<number, number>();\n  for (const tile of tiles) {\n    const surfaceDepth = getHeightVariation(tile.center, config);\n    heightMap.set(tile.index, surfaceDepth);\n  }\n\n  // Second pass: Identify beach tiles\n  const SEA_LEVEL_DEPTH = config.maxDepth - 1 - config.seaLevel;\n  const beachTiles = new Set<number>();\n\n  if (config.hasWater) {\n    for (const tile of tiles) {\n      const surfaceDepth = heightMap.get(tile.index) ?? SEA_LEVEL_DEPTH;\n      if (surfaceDepth >= SEA_LEVEL_DEPTH) {\n        for (const neighborIndex of tile.neighbors) {\n          const neighborDepth = heightMap.get(neighborIndex) ?? SEA_LEVEL_DEPTH;\n          if (neighborDepth < SEA_LEVEL_DEPTH) {\n            beachTiles.add(tile.index);\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  // Third pass: Create blocks based on height map\n  for (const tile of tiles) {\n    const blocks: number[] = [];\n    const surfaceDepth = heightMap.get(tile.index) ?? SEA_LEVEL_DEPTH;\n    const isBeach = beachTiles.has(tile.index);\n\n    // Polar biome detection\n    const len = Math.sqrt(tile.center.x * tile.center.x + tile.center.y * tile.center.y + tile.center.z * tile.center.z);\n    const normalizedY = tile.center.y / len;\n    const isPolar = !config.isSingleTexturePlanet && Math.abs(normalizedY) > config.polarThreshold;\n    const isUnderwater = config.hasWater && surfaceDepth < SEA_LEVEL_DEPTH;\n\n    for (let depth = 0; depth < config.maxDepth; depth++) {\n      if (depth > surfaceDepth) {\n        blocks.push(HexBlockType.AIR);\n      } else if (config.isSingleTexturePlanet) {\n        blocks.push(HexBlockType.MOON_ROCK);\n      } else if (depth === surfaceDepth) {\n        if (isBeach && !isPolar) {\n          blocks.push(HexBlockType.SAND);\n        } else if (isUnderwater) {\n          blocks.push(HexBlockType.DIRT);\n        } else if (isPolar) {\n          blocks.push(HexBlockType.SNOW);\n        } else {\n          blocks.push(HexBlockType.GRASS);\n        }\n      } else if (depth > surfaceDepth - 3) {\n        if (isBeach && !isPolar) {\n          blocks.push(HexBlockType.SAND);\n        } else {\n          blocks.push(HexBlockType.DIRT);\n        }\n      } else {\n        // Deep underground = stone or ore\n        const key = `${tile.index},${depth}`;\n        const oreType = oreVeinCache.get(key);\n        if (oreType !== undefined) {\n          blocks.push(oreType);\n        } else {\n          blocks.push(HexBlockType.STONE);\n        }\n      }\n    }\n\n    columns.set(tile.index, blocks);\n  }\n\n  // Fill oceans with water\n  if (config.hasWater) {\n    for (const tile of tiles) {\n      const blocks = columns.get(tile.index)!;\n      for (let depth = 0; depth < config.maxDepth; depth++) {\n        if (blocks[depth] === HexBlockType.AIR && depth <= SEA_LEVEL_DEPTH) {\n          blocks[depth] = HexBlockType.WATER;\n        }\n      }\n    }\n  }\n\n  return columns;\n}\n\n// Worker message handler\nself.onmessage = (e: MessageEvent<GenerateTerrainMessage>) => {\n  const { type, tiles, config } = e.data;\n\n  if (type === 'generateTerrain') {\n    console.log(`[TerrainWorker] Generating terrain for ${tiles.length} tiles...`);\n    const startTime = performance.now();\n\n    const columns = generateTerrain(tiles, config);\n\n    const elapsed = performance.now() - startTime;\n    console.log(`[TerrainWorker] Generated terrain in ${elapsed.toFixed(0)}ms`);\n\n    // Convert Map to array for serialization\n    const result: SerializableTerrainResult = {\n      type: 'terrainResult',\n      columns: Array.from(columns.entries())\n    };\n\n    self.postMessage(result);\n  }\n};\n\nexport {};\n"],"names":["HexBlockType","hash3D","x","y","z","seed","h","grad3D","ix","iy","iz","hash","g","simplex3D","F3","G3","s","i","j","k","t","X0","Y0","Z0","x0","y0","z0","i1","j1","k1","i2","j2","k2","x1","y1","z1","x2","y2","z2","x3","y3","z3","n0","n1","n2","n3","t0","t1","t2","t3","fractalSimplex3D","period","octaves","persistence","lacunarity","value","amplitude","frequency","maxValue","ridgeSimplex3D","noise","ridge","getHeightVariation","center","config","variation","len","dirX","dirY","dirZ","continentNoise","continentValue","mountainNoise","landFactor","mountainHeight","hillNoise","detailNoise","height","SEA_LEVEL_DEPTH","depth","landHeight","oceanDepth","seededRandom","generateOreVeins","tiles","oreVeinCache","tileNeighbors","tile","oreConfig","oreSeedOffset","tileIndex","key","spreadOreVein","seedTileIndex","seedDepth","baseSeed","toVisit","visited","blocksPlaced","maxBlocks","current","placeSeed","neighborProb","neighbors","neighborIdx","generateTerrain","columns","heightMap","surfaceDepth","beachTiles","neighborIndex","blocks","isBeach","normalizedY","isPolar","isUnderwater","oreType","e","type","startTime","elapsed","result"],"mappings":"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"}