(function(){"use strict";function K(j,H,st,rt){let nt=0;for(const G of rt){const E=j-G.position.x,X=H-G.position.y,F=st-G.position.z,J=Math.sqrt(E*E+X*X+F*F);if(J<G.range){const Y=1/(1+2*J*J/(G.range*G.range));nt+=Y*G.intensity}}return Math.min(nt,1.5)}function ut(){return{grassPositions:[],grassNormals:[],grassUvs:[],grassSkyLight:[],grassTorchLight:[],grassIndices:[],grassVertexOffset:0,dirtPositions:[],dirtNormals:[],dirtUvs:[],dirtSkyLight:[],dirtTorchLight:[],dirtIndices:[],dirtVertexOffset:0,stonePositions:[],stoneNormals:[],stoneUvs:[],stoneSkyLight:[],stoneTorchLight:[],stoneIndices:[],stoneVertexOffset:0,sandPositions:[],sandNormals:[],sandUvs:[],sandSkyLight:[],sandTorchLight:[],sandIndices:[],sandVertexOffset:0,woodPositions:[],woodNormals:[],woodUvs:[],woodSkyLight:[],woodTorchLight:[],woodIndices:[],woodVertexOffset:0,waterPositions:[],waterNormals:[],waterUvs:[],waterIndices:[],waterVertexOffset:0,sidePositions:[],sideNormals:[],sideUvs:[],sideSkyLight:[],sideTorchLight:[],sideIndices:[],sideVertexOffset:0,waterSidePositions:[],waterSideNormals:[],waterSideUvs:[],waterSideIndices:[],waterSideVertexOffset:0}}const v={AIR:0,STONE:1,DIRT:2,GRASS:3,WATER:4,SAND:5,WOOD:6};function it(j,H){return H.radius-(H.maxDepth-1-j)*H.blockHeight}function xt(j){return j.maxDepth-1-j.seaLevel}let Q=null,ct=0;self.onmessage=j=>{const{type:H,tileData:st,blockData:rt,nearbyTiles:nt,tileToChunk:G,config:E,torches:X=[]}=j.data;if(H==="buildLODGeometry"){const F=new Set(nt),J=new Map(Object.entries(G).map(([a,V])=>[parseInt(a),V])),Y=new Map;for(const[a,V]of Object.entries(st)){const s=parseInt(a),o=rt[s];o&&Y.set(s,{tileIndex:s,tile:V,blocks:o})}const dt=Object.keys(st).length;if(!Q||ct!==dt){Q=new Map,ct=dt;for(const[a,V]of Y){const s=V.tile,o=s.vertices.length,r=Math.sqrt(s.center.x*s.center.x+s.center.y*s.center.y+s.center.z*s.center.z),c=r>0?{x:s.center.x/r,y:s.center.y/r,z:s.center.z/r}:{x:0,y:0,z:0},t=[];for(const n of s.vertices){const m=Math.sqrt(n.x*n.x+n.y*n.y+n.z*n.z);t.push(m>0?{x:n.x/m,y:n.y/m,z:n.z/m}:{x:0,y:0,z:0})}const f=[];for(let n=0;n<o;n++){const m=(n+1)%o,T=s.vertices[n],k=s.vertices[m],w=T.x+k.x,S=T.y+k.y,y=T.z+k.z,p=Math.sqrt(w*w+S*S+y*y);f.push(p>0?{x:w/p,y:S/p,z:y/p}:{x:0,y:0,z:0})}const x=[];for(let n=0;n<o;n++){const m=f[n];let T=-1,k=1/0;for(const w of s.neighbors){const S=Y.get(w);if(!S)continue;const y=S.tile.center,p=Math.sqrt(y.x*y.x+y.y*y.y+y.z*y.z);if(p===0)continue;const B=y.x/p,A=y.y/p,D=y.z/p,W=B-m.x,C=A-m.y,N=D-m.z,ot=W*W+C*C+N*N;ot<k&&(k=ot,T=w)}x.push(T)}const e=Math.abs(c.y)<.9?{x:0,y:1,z:0}:{x:1,y:0,z:0},l=e.y*c.z-e.z*c.y,h=e.z*c.x-e.x*c.z,u=e.x*c.y-e.y*c.x,i=Math.sqrt(l*l+h*h+u*u),d=i>0?{x:l/i,y:h/i,z:u/i}:{x:1,y:0,z:0},z=c.y*d.z-c.z*d.y,O=c.z*d.x-c.x*d.z,U=c.x*d.y-c.y*d.x,I={x:z,y:O,z:U},R=[];let L=1/0,M=-1/0,g=1/0,b=-1/0;for(const n of s.vertices){const m=n.x-s.center.x,T=n.y-s.center.y,k=n.z-s.center.z,w=m*d.x+T*d.y+k*d.z,S=m*I.x+T*I.y+k*I.z;R.push({u:w,v:S}),L=Math.min(L,w),M=Math.max(M,w),g=Math.min(g,S),b=Math.max(b,S)}const P=M-L,q=b-g,Z=R.map(n=>({u:(n.u-L)/P,v:(n.v-g)/q})),$={u:(0-L)/P,v:(0-g)/q};Q.set(a,{normalizedCenter:c,normalizedVertices:t,edgeMidDirs:f,edgeNeighborIdx:x,normalizedUVs:Z,centerUV:$})}}const et=[];for(let a=0;a<E.chunkCount;a++)et.push(ut());const gt=xt(E),at=it(gt,E)-E.lodOffset,_=new Map;for(const[a,V]of Y){let s=0,o=v.GRASS,r=0;const c=V.blocks;for(let e=c.length-1;e>=0;e--)if(c[e]!==v.AIR&&(o===v.GRASS&&(s=e,o=c[e]),c[e]!==v.WATER)){r=e;break}const t=o===v.WATER,f=t?at:it(s,E)-E.lodOffset,x=it(r,E)-E.lodOffset;_.set(a,{radius:f,isWater:t,surfaceBlockType:o,terrainRadius:x})}for(const[a]of Y){if(F.has(a))continue;const V=Q.get(a),s=_.get(a),o=s.radius,r=s.surfaceBlockType,c=J.get(a)??0,t=et[c];let f,x,e,l,h,u,i;r===v.WATER?(f=t.waterPositions,x=t.waterNormals,e=t.waterUvs,l=null,h=null,u=t.waterIndices,i=t.waterVertexOffset):r===v.DIRT?(f=t.dirtPositions,x=t.dirtNormals,e=t.dirtUvs,l=t.dirtSkyLight,h=t.dirtTorchLight,u=t.dirtIndices,i=t.dirtVertexOffset):r===v.STONE?(f=t.stonePositions,x=t.stoneNormals,e=t.stoneUvs,l=t.stoneSkyLight,h=t.stoneTorchLight,u=t.stoneIndices,i=t.stoneVertexOffset):r===v.SAND?(f=t.sandPositions,x=t.sandNormals,e=t.sandUvs,l=t.sandSkyLight,h=t.sandTorchLight,u=t.sandIndices,i=t.sandVertexOffset):r===v.WOOD?(f=t.woodPositions,x=t.woodNormals,e=t.woodUvs,l=t.woodSkyLight,h=t.woodTorchLight,u=t.woodIndices,i=t.woodVertexOffset):(f=t.grassPositions,x=t.grassNormals,e=t.grassUvs,l=t.grassSkyLight,h=t.grassTorchLight,u=t.grassIndices,i=t.grassVertexOffset);const d=V.normalizedCenter,z=V.normalizedVertices,O=V.normalizedUVs,U=V.centerUV,I=i,R=d.x*o,L=d.y*o,M=d.z*o;f.push(R,L,M),x.push(d.x,d.y,d.z),e.push(U.u,U.v),l&&l.push(1),h&&h.push(K(R,L,M,X)),i++;for(let g=0;g<z.length;g++){const b=z[g],P=b.x*o,q=b.y*o,Z=b.z*o;f.push(P,q,Z),x.push(d.x,d.y,d.z),e.push(O[g].u,O[g].v),l&&l.push(1),h&&h.push(K(P,q,Z,X)),i++,u.push(I,I+1+g,I+1+(g+1)%z.length)}r===v.WATER?t.waterVertexOffset=i:r===v.DIRT?t.dirtVertexOffset=i:r===v.STONE?t.stoneVertexOffset=i:r===v.SAND?t.sandVertexOffset=i:r===v.WOOD?t.woodVertexOffset=i:t.grassVertexOffset=i}for(const[a]of Y){if(F.has(a))continue;const V=Q.get(a),s=_.get(a),o=s.radius,r=s.isWater,c=V.normalizedVertices,t=V.edgeNeighborIdx,f=c.length,x=J.get(a)??0,e=et[x];for(let l=0;l<f;l++){const h=t[l];if(h<0)continue;const u=_.get(h);if(!u)continue;const i=u.radius;if(o<=i)continue;const d=(l+1)%f,z=c[l],O=c[d],U=z.x*i,I=z.y*i,R=z.z*i,L=O.x*i,M=O.y*i,g=O.z*i,b=z.x*o,P=z.y*o,q=z.z*o,Z=O.x*o,$=O.y*o,n=O.z*o,m=L-U,T=M-I,k=g-R,w=b-U,S=P-I,y=q-R,p=T*y-k*S,B=k*w-m*y,A=m*S-T*w,D=Math.sqrt(p*p+B*B+A*A),W=D>0?p/D:0,C=D>0?B/D:0,N=D>0?A/D:0,ot=r?e.waterSidePositions:e.sidePositions,zt=r?e.waterSideNormals:e.sideNormals,mt=r?e.waterSideUvs:e.sideUvs,ft=r?null:e.sideSkyLight,ht=r?null:e.sideTorchLight,lt=r?e.waterSideIndices:e.sideIndices,tt=r?e.waterSideVertexOffset:e.sideVertexOffset;ot.push(U,I,R,L,M,g,Z,$,n,b,P,q),zt.push(W,C,N,W,C,N,W,C,N,W,C,N),mt.push(0,0,1,0,1,1,0,1),ft&&ft.push(1,1,1,1),ht&&ht.push(K(U,I,R,X),K(L,M,g,X),K(Z,$,n,X),K(b,P,q,X)),lt.push(tt,tt+1,tt+2),lt.push(tt,tt+2,tt+3),r?e.waterSideVertexOffset+=4:e.sideVertexOffset+=4}}for(const[a]of Y){if(F.has(a))continue;const V=Q.get(a),s=_.get(a);if(!s||!s.isWater)continue;const o=V.normalizedVertices,r=V.edgeNeighborIdx,c=o.length,t=J.get(a)??0,f=et[t];for(let x=0;x<c;x++){const e=r[x];if(e<0||!F.has(e))continue;const l=_.get(e);if(!l)continue;const h=l.terrainRadius,u=at;if(h>=u)continue;const i=(x+1)%c,d=o[x],z=o[i],O=d.x*h,U=d.y*h,I=d.z*h,R=z.x*h,L=z.y*h,M=z.z*h,g=d.x*u,b=d.y*u,P=d.z*u,q=z.x*u,Z=z.y*u,$=z.z*u,n=R-O,m=L-U,T=M-I,k=g-O,w=b-U,S=P-I,y=m*S-T*w,p=T*k-n*S,B=n*w-m*k,A=Math.sqrt(y*y+p*p+B*B),D=A>0?y/A:0,W=A>0?p/A:0,C=A>0?B/A:0,N=f.waterSideVertexOffset;f.waterSidePositions.push(O,U,I,R,L,M,q,Z,$,g,b,P),f.waterSideNormals.push(D,W,C,D,W,C,D,W,C,D,W,C),f.waterSideUvs.push(0,0,1,0,1,1,0,1),f.waterSideIndices.push(N,N+1,N+2),f.waterSideIndices.push(N,N+2,N+3),f.waterSideVertexOffset+=4}}const yt={type:"lodGeometryResult",chunkGeometries:et};self.postMessage(yt)}}})();
//# sourceMappingURL=lodGeometryWorker-FVfZBWG4.js.map
