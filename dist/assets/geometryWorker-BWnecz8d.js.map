{"version":3,"file":"geometryWorker-BWnecz8d.js","sources":["../src/shared/blockTypes.ts","../src/shared/vec3.ts","../src/shared/geometry.ts","../src/workers/geometryWorker.ts"],"sourcesContent":["// Shared block type definitions and helpers\n// This module is used by both main thread and web workers\n\nexport enum HexBlockType {\n  AIR = 0,\n  STONE = 1,\n  DIRT = 2,\n  GRASS = 3,\n  WATER = 4,\n  SAND = 5,\n  WOOD = 6,\n  LEAVES = 7,\n  // Mineral ores (underground)\n  ORE_COAL = 8,\n  ORE_COPPER = 9,\n  ORE_IRON = 10,\n  ORE_GOLD = 11,\n  ORE_LITHIUM = 12,\n  ORE_ALUMINUM = 13,\n  ORE_COBALT = 14,\n  // Snow biome blocks\n  SNOW = 15,\n  DIRT_SNOW = 16,  // Dirt with snow on top\n  ICE = 17,\n  // Technology blocks\n  FURNACE = 18,\n  // Glass (transparent like ice)\n  GLASS = 19,\n  // Advanced technology blocks\n  COMPUTER = 20,\n  PRINTER_3D = 21,\n  // Moon terrain block\n  MOON_ROCK = 22\n}\n\nexport function isSolid(blockType: HexBlockType | number): boolean {\n  return blockType !== HexBlockType.AIR && blockType !== HexBlockType.WATER;\n}\n\nexport function isLiquid(blockType: HexBlockType | number): boolean {\n  return blockType === HexBlockType.WATER;\n}\n\nexport function isTransparent(blockType: HexBlockType | number): boolean {\n  return blockType === HexBlockType.AIR || blockType === HexBlockType.WATER || blockType === HexBlockType.ICE || blockType === HexBlockType.GLASS;\n}\n\nexport function isSemiTransparent(blockType: HexBlockType | number): boolean {\n  return blockType === HexBlockType.ICE || blockType === HexBlockType.GLASS;\n}\n","// Shared Vec3 math operations for use in web workers\n// These are pure functions that don't depend on THREE.js\n\nexport interface Vec3 {\n  x: number;\n  y: number;\n  z: number;\n}\n\nexport function vec3(x: number, y: number, z: number): Vec3 {\n  return { x, y, z };\n}\n\nexport function vec3Clone(v: Vec3): Vec3 {\n  return { x: v.x, y: v.y, z: v.z };\n}\n\nexport function vec3Add(a: Vec3, b: Vec3): Vec3 {\n  return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };\n}\n\nexport function vec3Sub(a: Vec3, b: Vec3): Vec3 {\n  return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };\n}\n\nexport function vec3Scale(v: Vec3, s: number): Vec3 {\n  return { x: v.x * s, y: v.y * s, z: v.z * s };\n}\n\nexport function vec3Dot(a: Vec3, b: Vec3): number {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nexport function vec3Cross(a: Vec3, b: Vec3): Vec3 {\n  return {\n    x: a.y * b.z - a.z * b.y,\n    y: a.z * b.x - a.x * b.z,\n    z: a.x * b.y - a.y * b.x\n  };\n}\n\nexport function vec3Length(v: Vec3): number {\n  return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n}\n\nexport function vec3LengthSquared(v: Vec3): number {\n  return v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\nexport function vec3Normalize(v: Vec3): Vec3 {\n  const len = vec3Length(v);\n  if (len === 0) return { x: 0, y: 0, z: 0 };\n  return { x: v.x / len, y: v.y / len, z: v.z / len };\n}\n\nexport function vec3Negate(v: Vec3): Vec3 {\n  return { x: -v.x, y: -v.y, z: -v.z };\n}\n\nexport function vec3Distance(a: Vec3, b: Vec3): number {\n  return vec3Length(vec3Sub(a, b));\n}\n\nexport function vec3DistanceSquared(a: Vec3, b: Vec3): number {\n  return vec3LengthSquared(vec3Sub(a, b));\n}\n","// Shared geometry generation functions for use in web workers\n// Pure functions that don't depend on THREE.js\n\nimport { Vec3, vec3, vec3Add, vec3Sub, vec3Scale, vec3Dot, vec3Cross, vec3Normalize, vec3Negate, vec3Length, vec3Distance } from './vec3';\nimport { HexBlockType } from './blockTypes';\n\n// Tile data structure compatible with both main thread and workers\nexport interface TileVertexData {\n  index: number;\n  center: Vec3;\n  vertices: Vec3[];\n}\n\n// Raw geometry data before converting to typed arrays\nexport interface RawGeometry {\n  positions: number[];\n  normals: number[];\n  uvs: number[];\n  indices: number[];\n}\n\n// Geometry data with lighting info\nexport interface GeometryData {\n  positions: number[];\n  normals: number[];\n  uvs: number[];\n  colors: number[];\n  skyLight: number[];\n  indices: number[];\n  vertexOffset: number;\n}\n\nexport function createEmptyGeometryData(): GeometryData {\n  return { positions: [], normals: [], uvs: [], colors: [], skyLight: [], indices: [], vertexOffset: 0 };\n}\n\n// Sky light constants\nexport const SKY_LIGHT_FALLOFF = 0.8;\nexport const MIN_SKY_LIGHT = 0.05;\n\n// Calculate sky light level based on depth from surface\nexport function calculateSkyLight(depthFromSurface: number): number {\n  if (depthFromSurface <= 0) return 1.0;\n  return Math.max(MIN_SKY_LIGHT, Math.pow(SKY_LIGHT_FALLOFF, depthFromSurface));\n}\n\n// Pre-compute regular polygon UVs for hexagons/pentagons\nexport function computePolygonUVs(numSides: number, uvRadius: number = 0.5): { u: number; v: number }[] {\n  const uvs: { u: number; v: number }[] = [];\n  for (let i = 0; i < numSides; i++) {\n    const angle = (i / numSides) * Math.PI * 2 - Math.PI / 2; // Start from top\n    uvs.push({\n      u: 0.5 + Math.cos(angle) * uvRadius,\n      v: 0.5 + Math.sin(angle) * uvRadius\n    });\n  }\n  return uvs;\n}\n\n// Create local tangent space for a tile\nexport function createTangentSpace(radialDir: Vec3): { right: Vec3; forward: Vec3 } {\n  let localRight = vec3(1, 0, 0);\n  if (Math.abs(vec3Dot(radialDir, localRight)) > 0.9) {\n    localRight = vec3(0, 0, 1);\n  }\n  const localForward = vec3Normalize(vec3Cross(radialDir, localRight));\n  localRight = vec3Normalize(vec3Cross(localForward, radialDir));\n  return { right: localRight, forward: localForward };\n}\n\n// Scale tile vertices to specific radius\nexport function scaleVerticesToRadius(\n  vertices: Vec3[],\n  planetCenter: Vec3,\n  radius: number\n): Vec3[] {\n  return vertices.map(v => {\n    const dir = vec3Normalize(vec3Sub(v, planetCenter));\n    return vec3Scale(dir, radius);\n  });\n}\n\n// Create separate geometries for top, bottom, and sides of a hex prism\nexport function createSeparateGeometries(\n  tile: TileVertexData,\n  innerRadius: number,\n  outerRadius: number,\n  planetCenter: Vec3,\n  isTopExposed: boolean,\n  isBottomExposed: boolean,\n  areSidesExposed: boolean\n): { top: RawGeometry | null; bottom: RawGeometry | null; sides: RawGeometry | null } {\n  const numSides = tile.vertices.length;\n\n  // Calculate radial direction\n  const radialDir = vec3Normalize(vec3Sub(tile.center, planetCenter));\n\n  // Scale vertices to inner and outer radii\n  const innerVerts = scaleVerticesToRadius(tile.vertices, planetCenter, innerRadius);\n  const outerVerts = scaleVerticesToRadius(tile.vertices, planetCenter, outerRadius);\n\n  const innerCenter = vec3Scale(radialDir, innerRadius);\n  const outerCenter = vec3Scale(radialDir, outerRadius);\n\n  let topGeom: RawGeometry | null = null;\n  let bottomGeom: RawGeometry | null = null;\n  let sidesGeom: RawGeometry | null = null;\n\n  // Pre-compute regular polygon UVs\n  const tileUVs = computePolygonUVs(numSides);\n\n  // Top face\n  if (isTopExposed) {\n    const positions: number[] = [];\n    const normals: number[] = [];\n    const uvs: number[] = [];\n    const indices: number[] = [];\n\n    positions.push(outerCenter.x, outerCenter.y, outerCenter.z);\n    normals.push(radialDir.x, radialDir.y, radialDir.z);\n    uvs.push(0.5, 0.5);\n\n    for (let i = 0; i < numSides; i++) {\n      const v = outerVerts[i];\n      positions.push(v.x, v.y, v.z);\n      normals.push(radialDir.x, radialDir.y, radialDir.z);\n      uvs.push(tileUVs[i].u, tileUVs[i].v);\n    }\n\n    for (let i = 0; i < numSides; i++) {\n      const next = (i + 1) % numSides;\n      indices.push(0, 1 + i, 1 + next);\n    }\n\n    topGeom = { positions, normals, uvs, indices };\n  }\n\n  // Bottom face\n  if (isBottomExposed) {\n    const positions: number[] = [];\n    const normals: number[] = [];\n    const uvs: number[] = [];\n    const indices: number[] = [];\n\n    const bottomNormal = vec3Negate(radialDir);\n\n    positions.push(innerCenter.x, innerCenter.y, innerCenter.z);\n    normals.push(bottomNormal.x, bottomNormal.y, bottomNormal.z);\n    uvs.push(0.5, 0.5);\n\n    for (let i = 0; i < numSides; i++) {\n      const v = innerVerts[i];\n      positions.push(v.x, v.y, v.z);\n      normals.push(bottomNormal.x, bottomNormal.y, bottomNormal.z);\n      uvs.push(tileUVs[i].u, tileUVs[i].v);\n    }\n\n    for (let i = 0; i < numSides; i++) {\n      const next = (i + 1) % numSides;\n      indices.push(0, 1 + next, 1 + i);\n    }\n\n    bottomGeom = { positions, normals, uvs, indices };\n  }\n\n  // Side faces\n  if (areSidesExposed) {\n    const positions: number[] = [];\n    const normals: number[] = [];\n    const uvs: number[] = [];\n    const indices: number[] = [];\n    let vertexIndex = 0;\n\n    for (let i = 0; i < numSides; i++) {\n      const next = (i + 1) % numSides;\n\n      const outerV1 = outerVerts[i];\n      const outerV2 = outerVerts[next];\n      const innerV1 = innerVerts[i];\n      const innerV2 = innerVerts[next];\n\n      // Calculate side normal\n      const edge = vec3Sub(outerV2, outerV1);\n      const edgeLen = vec3Length(edge);\n\n      const midPoint = vec3Scale(vec3Add(outerV1, outerV2), 0.5);\n      let sideNormal = vec3Normalize(vec3Sub(midPoint, planetCenter));\n\n      // Remove component parallel to edge to get perpendicular normal\n      const tangent = vec3Scale(edge, 1 / edgeLen);\n      const dot = vec3Dot(sideNormal, tangent);\n      sideNormal = vec3Normalize({\n        x: sideNormal.x - tangent.x * dot,\n        y: sideNormal.y - tangent.y * dot,\n        z: sideNormal.z - tangent.z * dot\n      });\n\n      positions.push(\n        innerV1.x, innerV1.y, innerV1.z,\n        innerV2.x, innerV2.y, innerV2.z,\n        outerV2.x, outerV2.y, outerV2.z,\n        outerV1.x, outerV1.y, outerV1.z\n      );\n\n      for (let j = 0; j < 4; j++) {\n        normals.push(sideNormal.x, sideNormal.y, sideNormal.z);\n      }\n\n      uvs.push(0, 0,\n         1, 0,\n         1, 1,\n         0, 1);\n\n      const baseIdx = vertexIndex;\n      indices.push(baseIdx, baseIdx + 1, baseIdx + 2, baseIdx, baseIdx + 2, baseIdx + 3);\n      vertexIndex += 4;\n    }\n\n    sidesGeom = { positions, normals, uvs, indices };\n  }\n\n  return { top: topGeom, bottom: bottomGeom, sides: sidesGeom };\n}\n\n// Merge raw geometry into target with sky light\nexport function mergeGeometry(\n  target: GeometryData,\n  source: RawGeometry,\n  skyLightLevel: number = 1.0\n): void {\n  const vertexCount = source.positions.length / 3;\n  const baseIndex = target.vertexOffset;\n\n  // Batch push arrays\n  target.positions.push(...source.positions);\n  target.normals.push(...source.normals);\n  target.uvs.push(...source.uvs);\n\n  // Add vertex colors (white, lighting handled in shader)\n  for (let i = 0; i < vertexCount; i++) {\n    target.colors.push(1, 1, 1);\n  }\n\n  // Add sky light for each vertex\n  for (let i = 0; i < vertexCount; i++) {\n    target.skyLight.push(skyLightLevel);\n  }\n\n  // Add indices with offset\n  for (const idx of source.indices) {\n    target.indices.push(idx + baseIndex);\n  }\n\n  target.vertexOffset += vertexCount;\n}\n\n// Water wall tile data for worker communication\nexport interface WaterWallTileData {\n  vertices: Vec3[];\n  neighbors: number[];\n}\n\n// Water wall configuration\nexport interface WaterWallConfig {\n  radius: number;\n  blockHeight: number;\n  maxDepth: number;\n  waterSurfaceOffset: number;\n}\n\n// Build water wall for a single depth level where this tile has water adjacent to neighbor's air\n// This is called for every water block to create walls where water meets air horizontally\nexport function buildWaterWallAtDepth(\n  tileVertices: Vec3[],\n  tileNeighbors: number[],\n  ownBlocks: number[],\n  neighborBlocksMap: Map<number, { blocks: number[]; vertices: Vec3[] }>,\n  depth: number,\n  config: WaterWallConfig,\n  waterData: GeometryData\n): void {\n  // Only process if this tile has water at this depth\n  if (ownBlocks[depth] !== HexBlockType.WATER) return;\n\n  const numSides = tileVertices.length;\n  const edgeThreshold = 0.001;\n\n  // Check each edge\n  for (let i = 0; i < numSides; i++) {\n    const next = (i + 1) % numSides;\n    const edgeV1 = tileVertices[i];\n    const edgeV2 = tileVertices[next];\n\n    // Find which neighbor shares this edge\n    let neighborData: { blocks: number[]; vertices: Vec3[] } | undefined;\n    for (const neighborIndex of tileNeighbors) {\n      const candidate = neighborBlocksMap.get(neighborIndex);\n      if (!candidate) continue;\n\n      // Check if this neighbor has both edge vertices\n      let hasV1 = false;\n      let hasV2 = false;\n      for (const nv of candidate.vertices) {\n        if (vec3Distance(nv, edgeV1) < edgeThreshold) hasV1 = true;\n        if (vec3Distance(nv, edgeV2) < edgeThreshold) hasV2 = true;\n      }\n\n      if (hasV1 && hasV2) {\n        neighborData = candidate;\n        break;\n      }\n    }\n\n    if (!neighborData) continue;\n\n    // Check if neighbor has air at this depth - if not, no wall needed on this edge\n    if (neighborData.blocks[depth] !== HexBlockType.AIR) continue;\n\n    // Check if this is the water surface (no water above) or underwater (water above)\n    const blockAbove = depth < ownBlocks.length - 1 ? ownBlocks[depth + 1] : HexBlockType.AIR;\n    const isWaterSurface = blockAbove !== HexBlockType.WATER;\n\n    // Wall spans one block height\n    // Top of wall: top of this block's space\n    // - If water surface: subtract waterSurfaceOffset (water sits slightly below block top)\n    // - If underwater: use full block top (connects to bottom of block above)\n    const blockTopRadius = config.radius - (config.maxDepth - 1 - depth) * config.blockHeight;\n    const wallTopRadius = isWaterSurface ? blockTopRadius - config.waterSurfaceOffset : blockTopRadius;\n\n    // Bottom of wall: bottom of this block's space\n    const wallBottomRadius = config.radius - (config.maxDepth - depth) * config.blockHeight;\n\n    if (wallBottomRadius >= wallTopRadius) continue;\n\n    // Scale vertices for top and bottom of wall\n    const dir1 = vec3Normalize(edgeV1);\n    const dir2 = vec3Normalize(edgeV2);\n\n    const topV1 = vec3Scale(dir1, wallTopRadius);\n    const topV2 = vec3Scale(dir2, wallTopRadius);\n    const bottomV1 = vec3Scale(dir1, wallBottomRadius);\n    const bottomV2 = vec3Scale(dir2, wallBottomRadius);\n\n    // Calculate side normal\n    const edge1 = vec3Sub(bottomV2, bottomV1);\n    const edge2 = vec3Sub(topV1, bottomV1);\n    const sideNormal = vec3Normalize(vec3Cross(edge1, edge2));\n\n    const baseIdx = waterData.vertexOffset;\n\n    // Four vertices for this side face\n    waterData.positions.push(\n      bottomV1.x, bottomV1.y, bottomV1.z,\n      bottomV2.x, bottomV2.y, bottomV2.z,\n      topV2.x, topV2.y, topV2.z,\n      topV1.x, topV1.y, topV1.z\n    );\n\n    for (let j = 0; j < 4; j++) {\n      waterData.normals.push(sideNormal.x, sideNormal.y, sideNormal.z);\n    }\n\n    waterData.uvs.push(0, 0, 1, 0, 1, 1, 0, 1);\n    waterData.skyLight.push(1.0, 1.0, 1.0, 1.0);\n    waterData.colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n\n    waterData.indices.push(\n      baseIdx, baseIdx + 1, baseIdx + 2,\n      baseIdx, baseIdx + 2, baseIdx + 3\n    );\n\n    waterData.vertexOffset += 4;\n  }\n}\n\n// Build water side faces that extend from water surface down to exposed air\n// This creates walls where water meets air gaps in neighboring columns\n// Pure function version for use in workers\nexport function buildWaterWallGeometry(\n  tileVertices: Vec3[],\n  tileNeighbors: number[],\n  ownBlocks: number[],\n  neighborBlocksMap: Map<number, { blocks: number[]; vertices: Vec3[] }>,\n  waterSurfaceDepth: number,\n  outerRadius: number,\n  config: WaterWallConfig,\n  waterData: GeometryData\n): void {\n  const numSides = tileVertices.length;\n  const edgeThreshold = 0.001;\n\n  // Check each edge\n  for (let i = 0; i < numSides; i++) {\n    const next = (i + 1) % numSides;\n    const edgeV1 = tileVertices[i];\n    const edgeV2 = tileVertices[next];\n\n    // Find which neighbor shares this edge\n    let neighborData: { blocks: number[]; vertices: Vec3[] } | undefined;\n    for (const neighborIndex of tileNeighbors) {\n      const candidate = neighborBlocksMap.get(neighborIndex);\n      if (!candidate) continue;\n\n      // Check if this neighbor has both edge vertices\n      let hasV1 = false;\n      let hasV2 = false;\n      for (const nv of candidate.vertices) {\n        if (vec3Distance(nv, edgeV1) < edgeThreshold) hasV1 = true;\n        if (vec3Distance(nv, edgeV2) < edgeThreshold) hasV2 = true;\n      }\n\n      if (hasV1 && hasV2) {\n        neighborData = candidate;\n        break;\n      }\n    }\n\n    if (!neighborData) continue;\n\n    // Check if neighbor has air at water surface level - if not, skip this edge\n    if (neighborData.blocks[waterSurfaceDepth] !== HexBlockType.AIR) continue;\n\n    // Find where this water column has solid blocks below the water\n    // Depth system: 0 = bedrock (bottom), higher = toward sky\n    // Solid blocks (ocean floor) are at LOWER depth values than water\n    let ownSolidDepth = 0;\n    for (let d = waterSurfaceDepth - 1; d >= 0; d--) {\n      const ownBlock = ownBlocks[d];\n      if (ownBlock !== HexBlockType.AIR && ownBlock !== HexBlockType.WATER) {\n        ownSolidDepth = d;\n        break;\n      }\n    }\n\n    // Find the neighbor's first solid block depth (searching downward)\n    let neighborSolidDepth = 0;\n    for (let d = waterSurfaceDepth - 1; d >= 0; d--) {\n      const neighborBlock = neighborData.blocks[d];\n      if (neighborBlock !== HexBlockType.AIR && neighborBlock !== HexBlockType.WATER) {\n        neighborSolidDepth = d;\n        break;\n      }\n    }\n\n    // Water wall extends to the maximum of own solid depth or neighbor solid depth\n    // (higher depth = closer to water surface, so we take max to get the shallowest floor)\n    const wallBottomDepth = Math.max(ownSolidDepth, neighborSolidDepth);\n\n    // Calculate wall geometry\n    // Use correct depth formula: depthToRadius(d) = radius - (maxDepth - 1 - d) * blockHeight\n    const wallTopRadius = outerRadius;\n    const wallBottomRadius = config.radius - (config.maxDepth - 1 - wallBottomDepth) * config.blockHeight;\n\n    if (wallBottomRadius >= wallTopRadius) continue;\n\n    // Scale vertices for top and bottom of wall\n    const dir1 = vec3Normalize(edgeV1);\n    const dir2 = vec3Normalize(edgeV2);\n\n    const topV1 = vec3Scale(dir1, wallTopRadius);\n    const topV2 = vec3Scale(dir2, wallTopRadius);\n    const bottomV1 = vec3Scale(dir1, wallBottomRadius);\n    const bottomV2 = vec3Scale(dir2, wallBottomRadius);\n\n    // Calculate side normal\n    const edge1 = vec3Sub(bottomV2, bottomV1);\n    const edge2 = vec3Sub(topV1, bottomV1);\n    const sideNormal = vec3Normalize(vec3Cross(edge1, edge2));\n\n    const baseIdx = waterData.vertexOffset;\n\n    // Four vertices for this side face\n    waterData.positions.push(\n      bottomV1.x, bottomV1.y, bottomV1.z,\n      bottomV2.x, bottomV2.y, bottomV2.z,\n      topV2.x, topV2.y, topV2.z,\n      topV1.x, topV1.y, topV1.z\n    );\n\n    for (let j = 0; j < 4; j++) {\n      waterData.normals.push(sideNormal.x, sideNormal.y, sideNormal.z);\n    }\n\n    waterData.uvs.push(0, 0, 1, 0, 1, 1, 0, 1);\n    waterData.skyLight.push(1.0, 1.0, 1.0, 1.0);\n    waterData.colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n\n    waterData.indices.push(\n      baseIdx, baseIdx + 1, baseIdx + 2,\n      baseIdx, baseIdx + 2, baseIdx + 3\n    );\n\n    waterData.vertexOffset += 4;\n  }\n}\n\n","// Geometry Worker - builds terrain geometry off the main thread\n// Uses plain JavaScript math instead of THREE.js (not available in workers)\n\nimport { HexBlockType } from '../shared/blockTypes';\nimport {\n  Vec3,\n  vec3,\n  vec3Clone,\n  vec3Sub,\n  vec3Scale,\n  vec3Dot,\n  vec3Cross,\n  vec3Normalize,\n  vec3Negate\n} from '../shared/vec3';\nimport { SKY_LIGHT_FALLOFF, MIN_SKY_LIGHT, buildWaterWallAtDepth } from '../shared/geometry';\n\n// Torch data for vertex lighting calculation\ninterface TorchData {\n  position: Vec3;\n  range: number;\n  intensity: number;\n}\n\n// Geometry data structure (matches Planet.ts)\ninterface GeometryData {\n  positions: number[];\n  normals: number[];\n  uvs: number[];\n  colors: number[];\n  skyLight: number[];\n  torchLight: number[];  // Baked torch light level per vertex\n  indices: number[];\n  vertexOffset: number;\n}\n\nfunction createEmptyGeometryData(): GeometryData {\n  return { positions: [], normals: [], uvs: [], colors: [], skyLight: [], torchLight: [], indices: [], vertexOffset: 0 };\n}\n\n// Tile data passed from main thread\ninterface TileData {\n  index: number;\n  vertices: Vec3[];  // Tile corner vertices\n  center: Vec3;      // Tile center\n  neighbors: number[];\n}\n\n// Column data passed from main thread\ninterface ColumnData {\n  tileIndex: number;\n  tile: TileData;\n  blocks: number[];  // HexBlockType values\n}\n\n// HexBlockType is imported from shared/blockTypes\n\n// Config passed from main thread\ninterface WorkerConfig {\n  radius: number;\n  blockHeight: number;\n  seaLevel: number;\n  maxDepth: number;  // Total depth (for radius calculation)\n  deepThreshold: number;\n  waterSurfaceOffset: number;\n  sunDirection: Vec3;\n  uvScale: number;  // Texture tiling scale\n  torches?: TorchData[];  // Nearby torches for vertex lighting (optional)\n}\n\n// Helper to convert depth to radius (0 = bedrock, maxDepth-1 = sky)\nfunction depthToRadius(depth: number, config: WorkerConfig): number {\n  return config.radius - (config.maxDepth - 1 - depth) * config.blockHeight;\n}\n\n// Calculate torch light contribution at a point\nfunction calculateTorchLight(x: number, y: number, z: number, torches: TorchData[]): number {\n  let totalLight = 0;\n  for (const torch of torches) {\n    const dx = x - torch.position.x;\n    const dy = y - torch.position.y;\n    const dz = z - torch.position.z;\n    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n    if (dist < torch.range) {\n      // Quadratic falloff matching the shader formula\n      const attenuation = 1.0 / (1.0 + 2.0 * dist * dist / (torch.range * torch.range));\n      totalLight += attenuation * torch.intensity;\n    }\n  }\n  return Math.min(totalLight, 1.5); // Cap at 1.5 like the shader\n}\n\n// Neighbor data includes both blocks and vertices for water wall generation\ninterface NeighborData {\n  blocks: number[];\n  vertices: Vec3[];\n}\n\n// Message types\ninterface BuildGeometryMessage {\n  type: 'buildGeometry';\n  columns: ColumnData[];\n  neighborData: Record<string, NeighborData>; // tileIndex -> blocks and vertices for neighbor lookup\n  config: WorkerConfig;\n}\n\n// New chunk-aware build message\ninterface BuildChunkGeometryMessage {\n  type: 'buildChunkGeometry';\n  columns: ColumnData[];\n  neighborData: Record<string, NeighborData>;\n  tileToChunk: Record<number, number>;  // Tile index -> chunk index mapping\n  chunksToRebuild: number[];  // Which chunks are being rebuilt\n  config: WorkerConfig;\n}\n\ninterface GeometryResultMessage {\n  type: 'geometryResult';\n  topData: GeometryData;\n  sideData: GeometryData;\n  grassSideData: GeometryData;  // Grass block sides use dirt_grass texture\n  stoneData: GeometryData;\n  sandData: GeometryData;\n  woodData: GeometryData;\n  waterData: GeometryData;\n  // Mineral ore data\n  oreCoalData: GeometryData;\n  oreCopperData: GeometryData;\n  oreIronData: GeometryData;\n  oreGoldData: GeometryData;\n  oreLithiumData: GeometryData;\n  oreAluminumData: GeometryData;\n  oreCobaltData: GeometryData;\n  // Snow biome data\n  snowData: GeometryData;\n  snowSideData: GeometryData;  // Snow block sides use dirt_snow texture\n  dirtSnowData: GeometryData;\n  iceData: GeometryData;\n  // Glass data\n  glassData: GeometryData;\n  // Moon terrain data\n  moonRockData: GeometryData;\n}\n\n// Per-chunk geometry data for chunk rebuilds\ninterface ChunkGeometryData {\n  topData: GeometryData;\n  sideData: GeometryData;\n  grassSideData: GeometryData;\n  stoneData: GeometryData;\n  sandData: GeometryData;\n  woodData: GeometryData;\n  waterData: GeometryData;\n  oreCoalData: GeometryData;\n  oreCopperData: GeometryData;\n  oreIronData: GeometryData;\n  oreGoldData: GeometryData;\n  oreLithiumData: GeometryData;\n  oreAluminumData: GeometryData;\n  oreCobaltData: GeometryData;\n  snowData: GeometryData;\n  snowSideData: GeometryData;\n  dirtSnowData: GeometryData;\n  iceData: GeometryData;\n  glassData: GeometryData;\n  moonRockData: GeometryData;\n}\n\ninterface ChunkGeometryResultMessage {\n  type: 'chunkGeometryResult';\n  chunkGeometries: Record<number, ChunkGeometryData>;  // chunk index -> geometry\n  chunksRebuilt: number[];  // Which chunks were rebuilt\n}\n\nfunction createEmptyChunkGeometryData(): ChunkGeometryData {\n  return {\n    topData: createEmptyGeometryData(),\n    sideData: createEmptyGeometryData(),\n    grassSideData: createEmptyGeometryData(),\n    stoneData: createEmptyGeometryData(),\n    sandData: createEmptyGeometryData(),\n    woodData: createEmptyGeometryData(),\n    waterData: createEmptyGeometryData(),\n    oreCoalData: createEmptyGeometryData(),\n    oreCopperData: createEmptyGeometryData(),\n    oreIronData: createEmptyGeometryData(),\n    oreGoldData: createEmptyGeometryData(),\n    oreLithiumData: createEmptyGeometryData(),\n    oreAluminumData: createEmptyGeometryData(),\n    oreCobaltData: createEmptyGeometryData(),\n    snowData: createEmptyGeometryData(),\n    snowSideData: createEmptyGeometryData(),\n    dirtSnowData: createEmptyGeometryData(),\n    iceData: createEmptyGeometryData(),\n    glassData: createEmptyGeometryData(),\n    moonRockData: createEmptyGeometryData()\n  };\n}\n\n// Check if a block type is transparent (air, water, ice, or glass)\nfunction isTransparentBlock(blockType: HexBlockType): boolean {\n  return blockType === HexBlockType.AIR || blockType === HexBlockType.WATER || blockType === HexBlockType.ICE || blockType === HexBlockType.GLASS;\n}\n\n// Check if a column has an exposed side at the given depth\nfunction hasExposedSide(\n  column: ColumnData,\n  depth: number,\n  neighborDataMap: Map<number, NeighborData>\n): boolean {\n  const blockType = column.blocks[depth];\n  if (blockType === HexBlockType.AIR || blockType === HexBlockType.WATER) return false;\n\n  for (const neighborIndex of column.tile.neighbors) {\n    const neighborInfo = neighborDataMap.get(neighborIndex);\n    if (!neighborInfo) return true; // No neighbor data = edge of loaded area\n\n    const neighborBlock = neighborInfo.blocks[depth];\n    if (neighborBlock === undefined) return true;\n    if (isTransparentBlock(neighborBlock)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Merge geometry into target data (simplified version without THREE.js)\n// Optimized: uses push.apply for batch operations instead of individual pushes\nfunction mergeGeometry(\n  target: GeometryData,\n  positions: number[],\n  normals: number[],\n  uvs: number[],\n  indices: number[],\n  _sunDirection: Vec3,\n  skyLightLevel: number,\n  torches: TorchData[] = []\n): void {\n  const vertexCount = positions.length / 3;\n  const baseIndex = target.vertexOffset;\n\n  // Batch push arrays (much faster than individual pushes)\n  // Note: push.apply has a limit (~100k args) but face geometry is small\n  target.positions.push.apply(target.positions, positions);\n  target.normals.push.apply(target.normals, normals);\n  target.uvs.push.apply(target.uvs, uvs);\n\n  // Add vertex colors (white, lighting handled in shader)\n  // Pre-build array then batch push\n  const colorsToAdd = new Array(vertexCount * 3);\n  for (let i = 0; i < vertexCount; i++) {\n    const idx = i * 3;\n    colorsToAdd[idx] = 1;\n    colorsToAdd[idx + 1] = 1;\n    colorsToAdd[idx + 2] = 1;\n  }\n  target.colors.push.apply(target.colors, colorsToAdd);\n\n  // Add sky light - pre-build array\n  const skyLightToAdd = new Array(vertexCount);\n  for (let i = 0; i < vertexCount; i++) {\n    skyLightToAdd[i] = skyLightLevel;\n  }\n  target.skyLight.push.apply(target.skyLight, skyLightToAdd);\n\n  // Add torch light - calculate per vertex based on position\n  const torchLightToAdd = new Array(vertexCount);\n  for (let i = 0; i < vertexCount; i++) {\n    const px = positions[i * 3];\n    const py = positions[i * 3 + 1];\n    const pz = positions[i * 3 + 2];\n    torchLightToAdd[i] = calculateTorchLight(px, py, pz, torches);\n  }\n  target.torchLight.push.apply(target.torchLight, torchLightToAdd);\n\n  // Add indices with offset - pre-build array\n  const indicesToAdd = new Array(indices.length);\n  for (let i = 0; i < indices.length; i++) {\n    indicesToAdd[i] = indices[i] + baseIndex;\n  }\n  target.indices.push.apply(target.indices, indicesToAdd);\n\n  target.vertexOffset += vertexCount;\n}\n\n// Create geometry for a hex column face (top, bottom, or sides)\nfunction createFaceGeometry(\n  tile: TileData,\n  innerRadius: number,\n  outerRadius: number,\n  isTop: boolean,\n  isBottom: boolean,\n  isSides: boolean,\n  _uvScale: number = 10\n): { positions: number[]; normals: number[]; uvs: number[]; indices: number[] } | null {\n  const numSides = tile.vertices.length;\n  const radialDir = vec3Normalize(tile.center);\n\n  // Scale vertices to inner and outer radii\n  const innerVerts: Vec3[] = [];\n  const outerVerts: Vec3[] = [];\n\n  for (const v of tile.vertices) {\n    const dir = vec3Normalize(v);\n    innerVerts.push(vec3Scale(dir, innerRadius));\n    outerVerts.push(vec3Scale(dir, outerRadius));\n  }\n\n  const innerCenter = vec3Scale(radialDir, innerRadius);\n  const outerCenter = vec3Scale(radialDir, outerRadius);\n\n  // Create local tangent space for UV mapping\n  const localUp = vec3Clone(radialDir);\n  let localRight = vec3(1, 0, 0);\n  if (Math.abs(vec3Dot(localUp, localRight)) > 0.9) {\n    localRight = vec3(0, 0, 1);\n  }\n  const localForward = vec3Normalize(vec3Cross(localUp, localRight));\n  localRight = vec3Normalize(vec3Cross(localForward, localUp));\n\n  const positions: number[] = [];\n  const normals: number[] = [];\n  const uvs: number[] = [];\n  const indices: number[] = [];\n\n  if (isTop) {\n    // Top face - use regular polygon UVs regardless of 3D distortion\n    const topNormal = vec3Clone(radialDir);\n\n    // Center vertex at UV center\n    positions.push(outerCenter.x, outerCenter.y, outerCenter.z);\n    normals.push(topNormal.x, topNormal.y, topNormal.z);\n    uvs.push(0.5, 0.5);\n\n    // Edge vertices with regular polygon UVs (same for all hexagons/pentagons)\n    const uvRadius = 0.5; // UV radius from center\n    for (let i = 0; i < numSides; i++) {\n      const v = outerVerts[i];\n      positions.push(v.x, v.y, v.z);\n      normals.push(topNormal.x, topNormal.y, topNormal.z);\n\n      // Generate regular polygon UV based on vertex index\n      const angle = (i / numSides) * Math.PI * 2 - Math.PI / 2; // Start from top\n      const u = 0.5 + Math.cos(angle) * uvRadius;\n      const vCoord = 0.5 + Math.sin(angle) * uvRadius;\n      uvs.push(u, vCoord);\n    }\n\n    for (let i = 0; i < numSides; i++) {\n      const next = (i + 1) % numSides;\n      indices.push(0, 1 + i, 1 + next);\n    }\n  } else if (isBottom) {\n    // Bottom face - use regular polygon UVs\n    const bottomNormal = vec3Negate(radialDir);\n\n    positions.push(innerCenter.x, innerCenter.y, innerCenter.z);\n    normals.push(bottomNormal.x, bottomNormal.y, bottomNormal.z);\n    uvs.push(0.5, 0.5);\n\n    const uvRadius = 0.5;\n    for (let i = 0; i < numSides; i++) {\n      const v = innerVerts[i];\n      positions.push(v.x, v.y, v.z);\n      normals.push(bottomNormal.x, bottomNormal.y, bottomNormal.z);\n\n      // Generate regular polygon UV based on vertex index\n      const angle = (i / numSides) * Math.PI * 2 - Math.PI / 2;\n      const u = 0.5 + Math.cos(angle) * uvRadius;\n      const vCoord = 0.5 + Math.sin(angle) * uvRadius;\n      uvs.push(u, vCoord);\n    }\n\n    for (let i = 0; i < numSides; i++) {\n      const next = (i + 1) % numSides;\n      indices.push(0, 1 + next, 1 + i);\n    }\n  } else if (isSides) {\n    // Side faces\n    let vertexIndex = 0;\n\n    for (let i = 0; i < numSides; i++) {\n      const next = (i + 1) % numSides;\n\n      const outerV1 = outerVerts[i];\n      const outerV2 = outerVerts[next];\n      const innerV1 = innerVerts[i];\n      const innerV2 = innerVerts[next];\n\n      // Calculate side normal using cross product\n      const edge1 = vec3Sub(innerV2, innerV1);\n      const edge2 = vec3Sub(outerV1, innerV1);\n      const sideNormal = vec3Normalize(vec3Cross(edge1, edge2));\n\n      positions.push(\n        innerV1.x, innerV1.y, innerV1.z,\n        innerV2.x, innerV2.y, innerV2.z,\n        outerV2.x, outerV2.y, outerV2.z,\n        outerV1.x, outerV1.y, outerV1.z\n      );\n\n      for (let j = 0; j < 4; j++) {\n        normals.push(sideNormal.x, sideNormal.y, sideNormal.z);\n      }\n\n      uvs.push(0, 0, 1, 0, 1, 1, 0, 1);\n\n      indices.push(\n        vertexIndex, vertexIndex + 1, vertexIndex + 2,\n        vertexIndex, vertexIndex + 2, vertexIndex + 3\n      );\n      vertexIndex += 4;\n    }\n  }\n\n  if (positions.length === 0) return null;\n  return { positions, normals, uvs, indices };\n}\n\n// Build geometry for a single column\nfunction buildColumnGeometry(\n  column: ColumnData,\n  neighborDataMap: Map<number, NeighborData>,\n  config: WorkerConfig,\n  topData: GeometryData,\n  sideData: GeometryData,\n  grassSideData: GeometryData,\n  stoneData: GeometryData,\n  sandData: GeometryData,\n  woodData: GeometryData,\n  waterData: GeometryData,\n  oreCoalData: GeometryData,\n  oreCopperData: GeometryData,\n  oreIronData: GeometryData,\n  oreGoldData: GeometryData,\n  oreLithiumData: GeometryData,\n  oreAluminumData: GeometryData,\n  oreCobaltData: GeometryData,\n  snowData: GeometryData,\n  snowSideData: GeometryData,\n  dirtSnowData: GeometryData,\n  iceData: GeometryData,\n  glassData: GeometryData,\n  moonRockData: GeometryData\n): void {\n  // Find surface depth (topmost solid block, searching from top down)\n  // Depth system: 0 = bedrock, maxDepth-1 = sky\n  let surfaceDepth = 0;\n  for (let d = column.blocks.length - 1; d >= 0; d--) {\n    if (column.blocks[d] !== HexBlockType.AIR && column.blocks[d] !== HexBlockType.WATER) {\n      surfaceDepth = d;\n      break;\n    }\n  }\n\n  for (let depth = 0; depth < column.blocks.length; depth++) {\n    const blockType = column.blocks[depth];\n    if (blockType === HexBlockType.AIR) continue;\n\n    const isWater = blockType === HexBlockType.WATER;\n    const isIce = blockType === HexBlockType.ICE;\n    const isGlass = blockType === HexBlockType.GLASS;\n    // In new depth system: \"above\" = higher depth (toward sky), \"below\" = lower depth (toward bedrock)\n    const blockAbove = depth >= column.blocks.length - 1 ? HexBlockType.AIR : column.blocks[depth + 1];\n    const blockBelow = depth === 0 ? HexBlockType.AIR : column.blocks[depth - 1];\n\n    // For face culling: a face is exposed if adjacent block is AIR, or WATER (for non-water blocks), or ICE/GLASS (for non-ice/glass blocks)\n    const hasTopExposed = blockAbove === HexBlockType.AIR ||\n      (!isWater && blockAbove === HexBlockType.WATER) ||\n      (!isIce && !isGlass && (blockAbove === HexBlockType.ICE || blockAbove === HexBlockType.GLASS));\n    const hasBottomExposed = blockBelow === HexBlockType.AIR ||\n      (!isWater && blockBelow === HexBlockType.WATER) ||\n      (!isIce && !isGlass && (blockBelow === HexBlockType.ICE || blockBelow === HexBlockType.GLASS));\n\n    // Water only renders if air is above; Ice/Glass render like solid blocks\n    if (isWater && blockAbove !== HexBlockType.AIR && blockAbove !== HexBlockType.ICE && blockAbove !== HexBlockType.GLASS) continue;\n\n    // Ice needs to check for exposed sides too (treated like a solid block for rendering)\n    const hasSideExposed = !isWater && hasExposedSide(column, depth, neighborDataMap);\n\n    // Skip if no faces are exposed (water handled separately above)\n    if (!isWater && !hasTopExposed && !hasBottomExposed && !hasSideExposed) continue;\n\n    // In new system: higher depth = larger radius (closer to surface)\n    let outerRadius = depthToRadius(depth, config);\n    let innerRadius = outerRadius - config.blockHeight;\n\n    if (isWater) {\n      outerRadius -= config.waterSurfaceOffset;\n      innerRadius -= config.waterSurfaceOffset;\n    }\n\n    if (innerRadius <= 0) continue;\n\n    // depthFromSurface: positive = below surface (lower depth)\n    const depthFromSurface = surfaceDepth - depth;\n\n    // Get the geometry buffer for this block type\n    // Ore blocks use their specific ore textures, other blocks use their standard textures\n    let blockGeomData: GeometryData;\n    switch (blockType) {\n      case HexBlockType.ORE_COAL: blockGeomData = oreCoalData; break;\n      case HexBlockType.ORE_COPPER: blockGeomData = oreCopperData; break;\n      case HexBlockType.ORE_IRON: blockGeomData = oreIronData; break;\n      case HexBlockType.ORE_GOLD: blockGeomData = oreGoldData; break;\n      case HexBlockType.ORE_LITHIUM: blockGeomData = oreLithiumData; break;\n      case HexBlockType.ORE_ALUMINUM: blockGeomData = oreAluminumData; break;\n      case HexBlockType.ORE_COBALT: blockGeomData = oreCobaltData; break;\n      case HexBlockType.STONE: blockGeomData = stoneData; break;\n      case HexBlockType.SAND: blockGeomData = sandData; break;\n      case HexBlockType.DIRT: blockGeomData = sideData; break;\n      case HexBlockType.WOOD: blockGeomData = woodData; break;\n      case HexBlockType.SNOW: blockGeomData = snowData; break;\n      case HexBlockType.DIRT_SNOW: blockGeomData = dirtSnowData; break;\n      case HexBlockType.ICE: blockGeomData = iceData; break;\n      case HexBlockType.GLASS: blockGeomData = glassData; break;\n      case HexBlockType.MOON_ROCK: blockGeomData = moonRockData; break;\n      default: blockGeomData = topData; break; // Grass and others use top (grass) texture\n    }\n\n    // Calculate sky light (constants imported from shared/geometry)\n    let skyLightLevel = 1.0;\n    if (depthFromSurface > 0) {\n      skyLightLevel = Math.max(MIN_SKY_LIGHT, Math.pow(SKY_LIGHT_FALLOFF, depthFromSurface));\n    }\n\n    // Get torches array (default to empty)\n    const torches = config.torches || [];\n\n    // Create top face\n    if (isWater ? true : hasTopExposed) {\n      const topGeom = createFaceGeometry(column.tile, innerRadius, outerRadius, true, false, false, config.uvScale);\n      if (topGeom) {\n        if (isWater) {\n          mergeGeometry(waterData, topGeom.positions, topGeom.normals, topGeom.uvs, topGeom.indices, config.sunDirection, 1.0, torches);\n        } else {\n          mergeGeometry(blockGeomData, topGeom.positions, topGeom.normals, topGeom.uvs, topGeom.indices, config.sunDirection, skyLightLevel, torches);\n        }\n      }\n    }\n\n    // Create bottom face\n    if (!isWater && hasBottomExposed) {\n      const bottomGeom = createFaceGeometry(column.tile, innerRadius, outerRadius, false, true, false, config.uvScale);\n      if (bottomGeom) {\n        const bottomSkyLight = Math.max(MIN_SKY_LIGHT, skyLightLevel * SKY_LIGHT_FALLOFF);\n        // Grass and snow blocks show dirt on bottom, everything else shows its own texture\n        if (blockType === HexBlockType.GRASS) {\n          mergeGeometry(sideData, bottomGeom.positions, bottomGeom.normals, bottomGeom.uvs, bottomGeom.indices, config.sunDirection, bottomSkyLight, torches);\n        } else if (blockType === HexBlockType.SNOW) {\n          mergeGeometry(dirtSnowData, bottomGeom.positions, bottomGeom.normals, bottomGeom.uvs, bottomGeom.indices, config.sunDirection, bottomSkyLight, torches);\n        } else {\n          mergeGeometry(blockGeomData, bottomGeom.positions, bottomGeom.normals, bottomGeom.uvs, bottomGeom.indices, config.sunDirection, bottomSkyLight, torches);\n        }\n      }\n    }\n\n    // Create side faces\n    if (!isWater && hasSideExposed) {\n      const sidesGeom = createFaceGeometry(column.tile, innerRadius, outerRadius, false, false, true, config.uvScale);\n      if (sidesGeom) {\n        // Grass blocks use grassSideData (dirt_grass texture) for sides\n        // Snow blocks use snowSideData (dirt_snow texture) for sides\n        if (blockType === HexBlockType.GRASS) {\n          mergeGeometry(grassSideData, sidesGeom.positions, sidesGeom.normals, sidesGeom.uvs, sidesGeom.indices, config.sunDirection, skyLightLevel, torches);\n        } else if (blockType === HexBlockType.SNOW) {\n          mergeGeometry(snowSideData, sidesGeom.positions, sidesGeom.normals, sidesGeom.uvs, sidesGeom.indices, config.sunDirection, skyLightLevel, torches);\n        } else {\n          mergeGeometry(blockGeomData, sidesGeom.positions, sidesGeom.normals, sidesGeom.uvs, sidesGeom.indices, config.sunDirection, skyLightLevel, torches);\n        }\n      }\n    }\n  }\n}\n\n// Worker message handler\nself.onmessage = (e: MessageEvent<BuildGeometryMessage | BuildChunkGeometryMessage>) => {\n  const { type, columns, neighborData, config } = e.data;\n\n  if (type === 'buildGeometry') {\n    const topData = createEmptyGeometryData();\n    const sideData = createEmptyGeometryData();\n    const grassSideData = createEmptyGeometryData();\n    const stoneData = createEmptyGeometryData();\n    const sandData = createEmptyGeometryData();\n    const woodData = createEmptyGeometryData();\n    const waterData = createEmptyGeometryData();\n    // Mineral ore geometry data\n    const oreCoalData = createEmptyGeometryData();\n    const oreCopperData = createEmptyGeometryData();\n    const oreIronData = createEmptyGeometryData();\n    const oreGoldData = createEmptyGeometryData();\n    const oreLithiumData = createEmptyGeometryData();\n    const oreAluminumData = createEmptyGeometryData();\n    const oreCobaltData = createEmptyGeometryData();\n    // Snow biome geometry data\n    const snowData = createEmptyGeometryData();\n    const snowSideData = createEmptyGeometryData();\n    const dirtSnowData = createEmptyGeometryData();\n    const iceData = createEmptyGeometryData();\n    // Glass geometry data\n    const glassData = createEmptyGeometryData();\n    // Moon terrain geometry data\n    const moonRockData = createEmptyGeometryData();\n\n    // Convert neighborData back to Map (it gets serialized as object)\n    const neighborDataMap = new Map<number, NeighborData>(\n      Object.entries(neighborData as unknown as Record<string, NeighborData>).map(([k, v]) => [parseInt(k), v])\n    );\n\n    for (const column of columns) {\n      buildColumnGeometry(\n        column, neighborDataMap, config,\n        topData, sideData, grassSideData, stoneData, sandData, woodData, waterData,\n        oreCoalData, oreCopperData, oreIronData, oreGoldData, oreLithiumData, oreAluminumData, oreCobaltData,\n        snowData, snowSideData, dirtSnowData, iceData, glassData, moonRockData\n      );\n\n      // Generate water walls for water blocks adjacent to air in neighbors\n      for (let depth = 0; depth < column.blocks.length; depth++) {\n        if (column.blocks[depth] === HexBlockType.WATER) {\n          // Generate walls at each depth where water is adjacent to neighbor's air\n          buildWaterWallAtDepth(\n            column.tile.vertices,\n            column.tile.neighbors,\n            column.blocks,\n            neighborDataMap,\n            depth,\n            config,\n            waterData\n          );\n        }\n      }\n    }\n\n    // Debug: count non-zero torch light values across all geometry\n    let totalNonZero = 0;\n    for (const data of [topData, sideData, grassSideData, stoneData, sandData, woodData]) {\n      totalNonZero += data.torchLight.filter(v => v > 0).length;\n    }\n    if (totalNonZero > 0 || (config.torches && config.torches.length > 0)) {\n      console.log(`[GeometryWorker] Total non-zero torchLight values: ${totalNonZero}`);\n    }\n\n    const result: GeometryResultMessage = {\n      type: 'geometryResult',\n      topData,\n      sideData,\n      grassSideData,\n      stoneData,\n      sandData,\n      woodData,\n      waterData,\n      oreCoalData,\n      oreCopperData,\n      oreIronData,\n      oreGoldData,\n      oreLithiumData,\n      oreAluminumData,\n      oreCobaltData,\n      snowData,\n      snowSideData,\n      dirtSnowData,\n      iceData,\n      glassData,\n      moonRockData\n    };\n\n    // Transfer arrays for better performance\n    self.postMessage(result);\n  } else if (type === 'buildChunkGeometry') {\n    // Per-chunk geometry build - only rebuild specified chunks\n    const chunkData = e.data as BuildChunkGeometryMessage;\n    const tileToChunkMap = new Map(\n      Object.entries(chunkData.tileToChunk).map(([k, v]) => [parseInt(k), v])\n    );\n\n    // Convert neighborData back to Map\n    const neighborDataMap = new Map<number, NeighborData>(\n      Object.entries(neighborData as unknown as Record<string, NeighborData>).map(([k, v]) => [parseInt(k), v])\n    );\n\n    // Create geometry data for each chunk being rebuilt\n    const chunkGeometries: Record<number, ChunkGeometryData> = {};\n    for (const chunkIndex of chunkData.chunksToRebuild) {\n      chunkGeometries[chunkIndex] = createEmptyChunkGeometryData();\n    }\n\n    // Build geometry, routing each column to its chunk's buffers\n    for (const column of columns) {\n      const chunkIndex = tileToChunkMap.get(column.tileIndex);\n      if (chunkIndex === undefined || !chunkGeometries[chunkIndex]) continue;\n\n      const chunk = chunkGeometries[chunkIndex];\n      buildColumnGeometry(\n        column, neighborDataMap, config,\n        chunk.topData, chunk.sideData, chunk.grassSideData,\n        chunk.stoneData, chunk.sandData, chunk.woodData, chunk.waterData,\n        chunk.oreCoalData, chunk.oreCopperData, chunk.oreIronData,\n        chunk.oreGoldData, chunk.oreLithiumData, chunk.oreAluminumData, chunk.oreCobaltData,\n        chunk.snowData, chunk.snowSideData, chunk.dirtSnowData,\n        chunk.iceData, chunk.glassData, chunk.moonRockData\n      );\n\n      // Generate water walls for water blocks\n      for (let depth = 0; depth < column.blocks.length; depth++) {\n        if (column.blocks[depth] === HexBlockType.WATER) {\n          buildWaterWallAtDepth(\n            column.tile.vertices,\n            column.tile.neighbors,\n            column.blocks,\n            neighborDataMap,\n            depth,\n            config,\n            chunk.waterData\n          );\n        }\n      }\n    }\n\n    const result: ChunkGeometryResultMessage = {\n      type: 'chunkGeometryResult',\n      chunkGeometries,\n      chunksRebuilt: chunkData.chunksToRebuild\n    };\n\n    self.postMessage(result);\n  }\n};\n\nexport {};\n"],"names":["HexBlockType","vec3","x","y","z","vec3Clone","v","vec3Sub","a","b","vec3Scale","s","vec3Dot","vec3Cross","vec3Length","vec3Normalize","len","vec3Negate","vec3Distance","SKY_LIGHT_FALLOFF","MIN_SKY_LIGHT","buildWaterWallAtDepth","tileVertices","tileNeighbors","ownBlocks","neighborBlocksMap","depth","config","waterData","numSides","edgeThreshold","i","next","edgeV1","edgeV2","neighborData","neighborIndex","candidate","hasV1","hasV2","nv","isWaterSurface","blockTopRadius","wallTopRadius","wallBottomRadius","dir1","dir2","topV1","topV2","bottomV1","bottomV2","edge1","edge2","sideNormal","baseIdx","j","createEmptyGeometryData","depthToRadius","calculateTorchLight","torches","totalLight","torch","dx","dy","dz","dist","attenuation","createEmptyChunkGeometryData","isTransparentBlock","blockType","hasExposedSide","column","neighborDataMap","neighborInfo","neighborBlock","mergeGeometry","target","positions","normals","uvs","indices","_sunDirection","skyLightLevel","vertexCount","baseIndex","colorsToAdd","idx","skyLightToAdd","torchLightToAdd","px","py","pz","indicesToAdd","createFaceGeometry","tile","innerRadius","outerRadius","isTop","isBottom","isSides","_uvScale","radialDir","innerVerts","outerVerts","dir","innerCenter","outerCenter","localUp","localRight","localForward","topNormal","uvRadius","angle","u","vCoord","bottomNormal","vertexIndex","outerV1","outerV2","innerV1","innerV2","buildColumnGeometry","topData","sideData","grassSideData","stoneData","sandData","woodData","oreCoalData","oreCopperData","oreIronData","oreGoldData","oreLithiumData","oreAluminumData","oreCobaltData","snowData","snowSideData","dirtSnowData","iceData","glassData","moonRockData","surfaceDepth","d","isWater","isIce","isGlass","blockAbove","blockBelow","hasTopExposed","hasBottomExposed","hasSideExposed","depthFromSurface","blockGeomData","topGeom","bottomGeom","bottomSkyLight","sidesGeom","e","type","columns","k","totalNonZero","data","result","chunkData","tileToChunkMap","chunkGeometries","chunkIndex","chunk"],"mappings":"yBAGO,IAAKA,GAAAA,IACVA,EAAAA,EAAA,IAAM,CAAA,EAAN,MACAA,EAAAA,EAAA,MAAQ,CAAA,EAAR,QACAA,EAAAA,EAAA,KAAO,CAAA,EAAP,OACAA,EAAAA,EAAA,MAAQ,CAAA,EAAR,QACAA,EAAAA,EAAA,MAAQ,CAAA,EAAR,QACAA,EAAAA,EAAA,KAAO,CAAA,EAAP,OACAA,EAAAA,EAAA,KAAO,CAAA,EAAP,OACAA,EAAAA,EAAA,OAAS,CAAA,EAAT,SAEAA,EAAAA,EAAA,SAAW,CAAA,EAAX,WACAA,EAAAA,EAAA,WAAa,CAAA,EAAb,aACAA,EAAAA,EAAA,SAAW,EAAA,EAAX,WACAA,EAAAA,EAAA,SAAW,EAAA,EAAX,WACAA,EAAAA,EAAA,YAAc,EAAA,EAAd,cACAA,EAAAA,EAAA,aAAe,EAAA,EAAf,eACAA,EAAAA,EAAA,WAAa,EAAA,EAAb,aAEAA,EAAAA,EAAA,KAAO,EAAA,EAAP,OACAA,EAAAA,EAAA,UAAY,EAAA,EAAZ,YACAA,EAAAA,EAAA,IAAM,EAAA,EAAN,MAEAA,EAAAA,EAAA,QAAU,EAAA,EAAV,UAEAA,EAAAA,EAAA,MAAQ,EAAA,EAAR,QAEAA,EAAAA,EAAA,SAAW,EAAA,EAAX,WACAA,EAAAA,EAAA,WAAa,EAAA,EAAb,aAEAA,EAAAA,EAAA,UAAY,EAAA,EAAZ,YA7BUA,IAAAA,GAAA,CAAA,CAAA,ECML,SAASC,EAAKC,EAAWC,EAAWC,EAAiB,CAC1D,MAAO,CAAE,EAAAF,EAAG,EAAAC,EAAG,EAAAC,CAAA,CACjB,CAEO,SAASC,EAAUC,EAAe,CACvC,MAAO,CAAE,EAAGA,EAAE,EAAG,EAAGA,EAAE,EAAG,EAAGA,EAAE,CAAA,CAChC,CAMO,SAASC,EAAQC,EAASC,EAAe,CAC9C,MAAO,CAAE,EAAGD,EAAE,EAAIC,EAAE,EAAG,EAAGD,EAAE,EAAIC,EAAE,EAAG,EAAGD,EAAE,EAAIC,EAAE,CAAA,CAClD,CAEO,SAASC,EAAUJ,EAASK,EAAiB,CAClD,MAAO,CAAE,EAAGL,EAAE,EAAIK,EAAG,EAAGL,EAAE,EAAIK,EAAG,EAAGL,EAAE,EAAIK,CAAA,CAC5C,CAEO,SAASC,GAAQJ,EAASC,EAAiB,CAChD,OAAOD,EAAE,EAAIC,EAAE,EAAID,EAAE,EAAIC,EAAE,EAAID,EAAE,EAAIC,EAAE,CACzC,CAEO,SAASI,EAAUL,EAASC,EAAe,CAChD,MAAO,CACL,EAAGD,EAAE,EAAIC,EAAE,EAAID,EAAE,EAAIC,EAAE,EACvB,EAAGD,EAAE,EAAIC,EAAE,EAAID,EAAE,EAAIC,EAAE,EACvB,EAAGD,EAAE,EAAIC,EAAE,EAAID,EAAE,EAAIC,EAAE,CAAA,CAE3B,CAEO,SAASK,EAAWR,EAAiB,CAC1C,OAAO,KAAK,KAAKA,EAAE,EAAIA,EAAE,EAAIA,EAAE,EAAIA,EAAE,EAAIA,EAAE,EAAIA,EAAE,CAAC,CACpD,CAMO,SAASS,EAAcT,EAAe,CAC3C,MAAMU,EAAMF,EAAWR,CAAC,EACxB,OAAIU,IAAQ,EAAU,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,CAAA,EAChC,CAAE,EAAGV,EAAE,EAAIU,EAAK,EAAGV,EAAE,EAAIU,EAAK,EAAGV,EAAE,EAAIU,CAAA,CAChD,CAEO,SAASC,GAAWX,EAAe,CACxC,MAAO,CAAE,EAAG,CAACA,EAAE,EAAG,EAAG,CAACA,EAAE,EAAG,EAAG,CAACA,EAAE,CAAA,CACnC,CAEO,SAASY,EAAaV,EAASC,EAAiB,CACrD,OAAOK,EAAWP,EAAQC,EAAGC,CAAC,CAAC,CACjC,CCxBO,MAAMU,EAAoB,GACpBC,GAAgB,IA0OtB,SAASC,GACdC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACM,CAEN,GAAIJ,EAAUE,CAAK,IAAM1B,EAAa,MAAO,OAE7C,MAAM6B,EAAWP,EAAa,OACxBQ,EAAgB,KAGtB,QAASC,EAAI,EAAGA,EAAIF,EAAUE,IAAK,CACjC,MAAMC,GAAQD,EAAI,GAAKF,EACjBI,EAASX,EAAaS,CAAC,EACvBG,EAASZ,EAAaU,CAAI,EAGhC,IAAIG,EACJ,UAAWC,KAAiBb,EAAe,CACzC,MAAMc,EAAYZ,EAAkB,IAAIW,CAAa,EACrD,GAAI,CAACC,EAAW,SAGhB,IAAIC,EAAQ,GACRC,EAAQ,GACZ,UAAWC,KAAMH,EAAU,SACrBnB,EAAasB,EAAIP,CAAM,EAAIH,IAAeQ,EAAQ,IAClDpB,EAAasB,EAAIN,CAAM,EAAIJ,IAAeS,EAAQ,IAGxD,GAAID,GAASC,EAAO,CAClBJ,EAAeE,EACf,KACF,CACF,CAKA,GAHI,CAACF,GAGDA,EAAa,OAAOT,CAAK,IAAM1B,EAAa,IAAK,SAIrD,MAAMyC,GADaf,EAAQF,EAAU,OAAS,EAAIA,EAAUE,EAAQ,CAAC,EAAI1B,EAAa,OAChDA,EAAa,MAM7C0C,EAAiBf,EAAO,QAAUA,EAAO,SAAW,EAAID,GAASC,EAAO,YACxEgB,EAAgBF,EAAiBC,EAAiBf,EAAO,mBAAqBe,EAG9EE,EAAmBjB,EAAO,QAAUA,EAAO,SAAWD,GAASC,EAAO,YAE5E,GAAIiB,GAAoBD,EAAe,SAGvC,MAAME,EAAO9B,EAAckB,CAAM,EAC3Ba,EAAO/B,EAAcmB,CAAM,EAE3Ba,EAAQrC,EAAUmC,EAAMF,CAAa,EACrCK,EAAQtC,EAAUoC,EAAMH,CAAa,EACrCM,EAAWvC,EAAUmC,EAAMD,CAAgB,EAC3CM,EAAWxC,EAAUoC,EAAMF,CAAgB,EAG3CO,EAAQ5C,EAAQ2C,EAAUD,CAAQ,EAClCG,EAAQ7C,EAAQwC,EAAOE,CAAQ,EAC/BI,EAAatC,EAAcF,EAAUsC,EAAOC,CAAK,CAAC,EAElDE,EAAU1B,EAAU,aAG1BA,EAAU,UAAU,KAClBqB,EAAS,EAAGA,EAAS,EAAGA,EAAS,EACjCC,EAAS,EAAGA,EAAS,EAAGA,EAAS,EACjCF,EAAM,EAAGA,EAAM,EAAGA,EAAM,EACxBD,EAAM,EAAGA,EAAM,EAAGA,EAAM,CAAA,EAG1B,QAASQ,EAAI,EAAGA,EAAI,EAAGA,IACrB3B,EAAU,QAAQ,KAAKyB,EAAW,EAAGA,EAAW,EAAGA,EAAW,CAAC,EAGjEzB,EAAU,IAAI,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EACzCA,EAAU,SAAS,KAAK,EAAK,EAAK,EAAK,CAAG,EAC1CA,EAAU,OAAO,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAExDA,EAAU,QAAQ,KAChB0B,EAASA,EAAU,EAAGA,EAAU,EAChCA,EAASA,EAAU,EAAGA,EAAU,CAAA,EAGlC1B,EAAU,cAAgB,CAC5B,CACF,CCjVA,SAAS4B,GAAwC,CAC/C,MAAO,CAAE,UAAW,GAAI,QAAS,CAAA,EAAI,IAAK,CAAA,EAAI,OAAQ,CAAA,EAAI,SAAU,CAAA,EAAI,WAAY,CAAA,EAAI,QAAS,CAAA,EAAI,aAAc,CAAA,CACrH,CAiCA,SAASC,GAAc/B,EAAeC,EAA8B,CAClE,OAAOA,EAAO,QAAUA,EAAO,SAAW,EAAID,GAASC,EAAO,WAChE,CAGA,SAAS+B,GAAoBxD,EAAWC,EAAWC,EAAWuD,EAA8B,CAC1F,IAAIC,EAAa,EACjB,UAAWC,KAASF,EAAS,CAC3B,MAAMG,EAAK5D,EAAI2D,EAAM,SAAS,EACxBE,EAAK5D,EAAI0D,EAAM,SAAS,EACxBG,EAAK5D,EAAIyD,EAAM,SAAS,EACxBI,EAAO,KAAK,KAAKH,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,CAAE,EAElD,GAAIC,EAAOJ,EAAM,MAAO,CAEtB,MAAMK,EAAc,GAAO,EAAM,EAAMD,EAAOA,GAAQJ,EAAM,MAAQA,EAAM,QAC1ED,GAAcM,EAAcL,EAAM,SACpC,CACF,CACA,OAAO,KAAK,IAAID,EAAY,GAAG,CACjC,CAoFA,SAASO,IAAkD,CACzD,MAAO,CACL,QAASX,EAAA,EACT,SAAUA,EAAA,EACV,cAAeA,EAAA,EACf,UAAWA,EAAA,EACX,SAAUA,EAAA,EACV,SAAUA,EAAA,EACV,UAAWA,EAAA,EACX,YAAaA,EAAA,EACb,cAAeA,EAAA,EACf,YAAaA,EAAA,EACb,YAAaA,EAAA,EACb,eAAgBA,EAAA,EAChB,gBAAiBA,EAAA,EACjB,cAAeA,EAAA,EACf,SAAUA,EAAA,EACV,aAAcA,EAAA,EACd,aAAcA,EAAA,EACd,QAASA,EAAA,EACT,UAAWA,EAAA,EACX,aAAcA,EAAA,CAAwB,CAE1C,CAGA,SAASY,GAAmBC,EAAkC,CAC5D,OAAOA,IAAcrE,EAAa,KAAOqE,IAAcrE,EAAa,OAASqE,IAAcrE,EAAa,KAAOqE,IAAcrE,EAAa,KAC5I,CAGA,SAASsE,GACPC,EACA7C,EACA8C,EACS,CACT,MAAMH,EAAYE,EAAO,OAAO7C,CAAK,EACrC,GAAI2C,IAAcrE,EAAa,KAAOqE,IAAcrE,EAAa,MAAO,MAAO,GAE/E,UAAWoC,KAAiBmC,EAAO,KAAK,UAAW,CACjD,MAAME,EAAeD,EAAgB,IAAIpC,CAAa,EACtD,GAAI,CAACqC,EAAc,MAAO,GAE1B,MAAMC,EAAgBD,EAAa,OAAO/C,CAAK,EAE/C,GADIgD,IAAkB,QAClBN,GAAmBM,CAAa,EAClC,MAAO,EAEX,CACA,MAAO,EACT,CAIA,SAASC,EACPC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAvB,EAAuB,GACjB,CACN,MAAMwB,EAAcN,EAAU,OAAS,EACjCO,EAAYR,EAAO,aAIzBA,EAAO,UAAU,KAAK,MAAMA,EAAO,UAAWC,CAAS,EACvDD,EAAO,QAAQ,KAAK,MAAMA,EAAO,QAASE,CAAO,EACjDF,EAAO,IAAI,KAAK,MAAMA,EAAO,IAAKG,CAAG,EAIrC,MAAMM,EAAc,IAAI,MAAMF,EAAc,CAAC,EAC7C,QAASpD,EAAI,EAAGA,EAAIoD,EAAapD,IAAK,CACpC,MAAMuD,EAAMvD,EAAI,EAChBsD,EAAYC,CAAG,EAAI,EACnBD,EAAYC,EAAM,CAAC,EAAI,EACvBD,EAAYC,EAAM,CAAC,EAAI,CACzB,CACAV,EAAO,OAAO,KAAK,MAAMA,EAAO,OAAQS,CAAW,EAGnD,MAAME,EAAgB,IAAI,MAAMJ,CAAW,EAC3C,QAASpD,EAAI,EAAGA,EAAIoD,EAAapD,IAC/BwD,EAAcxD,CAAC,EAAImD,EAErBN,EAAO,SAAS,KAAK,MAAMA,EAAO,SAAUW,CAAa,EAGzD,MAAMC,EAAkB,IAAI,MAAML,CAAW,EAC7C,QAASpD,EAAI,EAAGA,EAAIoD,EAAapD,IAAK,CACpC,MAAM0D,EAAKZ,EAAU9C,EAAI,CAAC,EACpB2D,EAAKb,EAAU9C,EAAI,EAAI,CAAC,EACxB4D,EAAKd,EAAU9C,EAAI,EAAI,CAAC,EAC9ByD,EAAgBzD,CAAC,EAAI2B,GAAoB+B,EAAIC,EAAIC,EAAIhC,CAAO,CAC9D,CACAiB,EAAO,WAAW,KAAK,MAAMA,EAAO,WAAYY,CAAe,EAG/D,MAAMI,EAAe,IAAI,MAAMZ,EAAQ,MAAM,EAC7C,QAASjD,EAAI,EAAGA,EAAIiD,EAAQ,OAAQjD,IAClC6D,EAAa7D,CAAC,EAAIiD,EAAQjD,CAAC,EAAIqD,EAEjCR,EAAO,QAAQ,KAAK,MAAMA,EAAO,QAASgB,CAAY,EAEtDhB,EAAO,cAAgBO,CACzB,CAGA,SAASU,EACPC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAAmB,GACkE,CACrF,MAAMvE,EAAWiE,EAAK,SAAS,OACzBO,EAAYtF,EAAc+E,EAAK,MAAM,EAGrCQ,EAAqB,CAAA,EACrBC,EAAqB,CAAA,EAE3B,UAAWjG,KAAKwF,EAAK,SAAU,CAC7B,MAAMU,EAAMzF,EAAcT,CAAC,EAC3BgG,EAAW,KAAK5F,EAAU8F,EAAKT,CAAW,CAAC,EAC3CQ,EAAW,KAAK7F,EAAU8F,EAAKR,CAAW,CAAC,CAC7C,CAEA,MAAMS,EAAc/F,EAAU2F,EAAWN,CAAW,EAC9CW,EAAchG,EAAU2F,EAAWL,CAAW,EAG9CW,EAAUtG,EAAUgG,CAAS,EACnC,IAAIO,EAAa3G,EAAK,EAAG,EAAG,CAAC,EACzB,KAAK,IAAIW,GAAQ+F,EAASC,CAAU,CAAC,EAAI,KAC3CA,EAAa3G,EAAK,EAAG,EAAG,CAAC,GAE3B,MAAM4G,EAAe9F,EAAcF,EAAU8F,EAASC,CAAU,CAAC,EACjEA,EAAa7F,EAAcF,EAAUgG,EAAcF,CAAO,CAAC,EAE3D,MAAM9B,EAAsB,CAAA,EACtBC,EAAoB,CAAA,EACpBC,EAAgB,CAAA,EAChBC,EAAoB,CAAA,EAE1B,GAAIiB,EAAO,CAET,MAAMa,EAAYzG,EAAUgG,CAAS,EAGrCxB,EAAU,KAAK6B,EAAY,EAAGA,EAAY,EAAGA,EAAY,CAAC,EAC1D5B,EAAQ,KAAKgC,EAAU,EAAGA,EAAU,EAAGA,EAAU,CAAC,EAClD/B,EAAI,KAAK,GAAK,EAAG,EAGjB,MAAMgC,EAAW,GACjB,QAAShF,EAAI,EAAGA,EAAIF,EAAUE,IAAK,CACjC,MAAMzB,EAAIiG,EAAWxE,CAAC,EACtB8C,EAAU,KAAKvE,EAAE,EAAGA,EAAE,EAAGA,EAAE,CAAC,EAC5BwE,EAAQ,KAAKgC,EAAU,EAAGA,EAAU,EAAGA,EAAU,CAAC,EAGlD,MAAME,EAASjF,EAAIF,EAAY,KAAK,GAAK,EAAI,KAAK,GAAK,EACjDoF,EAAI,GAAM,KAAK,IAAID,CAAK,EAAID,EAC5BG,EAAS,GAAM,KAAK,IAAIF,CAAK,EAAID,EACvChC,EAAI,KAAKkC,EAAGC,CAAM,CACpB,CAEA,QAASnF,EAAI,EAAGA,EAAIF,EAAUE,IAAK,CACjC,MAAMC,GAAQD,EAAI,GAAKF,EACvBmD,EAAQ,KAAK,EAAG,EAAIjD,EAAG,EAAIC,CAAI,CACjC,CACF,SAAWkE,EAAU,CAEnB,MAAMiB,EAAelG,GAAWoF,CAAS,EAEzCxB,EAAU,KAAK4B,EAAY,EAAGA,EAAY,EAAGA,EAAY,CAAC,EAC1D3B,EAAQ,KAAKqC,EAAa,EAAGA,EAAa,EAAGA,EAAa,CAAC,EAC3DpC,EAAI,KAAK,GAAK,EAAG,EAEjB,MAAMgC,EAAW,GACjB,QAAShF,EAAI,EAAGA,EAAIF,EAAUE,IAAK,CACjC,MAAMzB,EAAIgG,EAAWvE,CAAC,EACtB8C,EAAU,KAAKvE,EAAE,EAAGA,EAAE,EAAGA,EAAE,CAAC,EAC5BwE,EAAQ,KAAKqC,EAAa,EAAGA,EAAa,EAAGA,EAAa,CAAC,EAG3D,MAAMH,EAASjF,EAAIF,EAAY,KAAK,GAAK,EAAI,KAAK,GAAK,EACjDoF,EAAI,GAAM,KAAK,IAAID,CAAK,EAAID,EAC5BG,EAAS,GAAM,KAAK,IAAIF,CAAK,EAAID,EACvChC,EAAI,KAAKkC,EAAGC,CAAM,CACpB,CAEA,QAASnF,EAAI,EAAGA,EAAIF,EAAUE,IAAK,CACjC,MAAMC,GAAQD,EAAI,GAAKF,EACvBmD,EAAQ,KAAK,EAAG,EAAIhD,EAAM,EAAID,CAAC,CACjC,CACF,SAAWoE,EAAS,CAElB,IAAIiB,EAAc,EAElB,QAASrF,EAAI,EAAGA,EAAIF,EAAUE,IAAK,CACjC,MAAMC,GAAQD,EAAI,GAAKF,EAEjBwF,EAAUd,EAAWxE,CAAC,EACtBuF,EAAUf,EAAWvE,CAAI,EACzBuF,EAAUjB,EAAWvE,CAAC,EACtByF,EAAUlB,EAAWtE,CAAI,EAGzBmB,EAAQ5C,EAAQiH,EAASD,CAAO,EAChCnE,EAAQ7C,EAAQ8G,EAASE,CAAO,EAChClE,EAAatC,EAAcF,EAAUsC,EAAOC,CAAK,CAAC,EAExDyB,EAAU,KACR0C,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAC9BC,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAC9BF,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAC9BD,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,CAAA,EAGhC,QAAS9D,EAAI,EAAGA,EAAI,EAAGA,IACrBuB,EAAQ,KAAKzB,EAAW,EAAGA,EAAW,EAAGA,EAAW,CAAC,EAGvD0B,EAAI,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAE/BC,EAAQ,KACNoC,EAAaA,EAAc,EAAGA,EAAc,EAC5CA,EAAaA,EAAc,EAAGA,EAAc,CAAA,EAE9CA,GAAe,CACjB,CACF,CAEA,OAAIvC,EAAU,SAAW,EAAU,KAC5B,CAAE,UAAAA,EAAW,QAAAC,EAAS,IAAAC,EAAK,QAAAC,CAAA,CACpC,CAGA,SAASyC,GACPlD,EACAC,EACA7C,EACA+F,EACAC,EACAC,EACAC,EACAC,EACAC,EACAnG,EACAoG,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACM,CAGN,IAAIC,EAAe,EACnB,QAASC,EAAIvE,EAAO,OAAO,OAAS,EAAGuE,GAAK,EAAGA,IAC7C,GAAIvE,EAAO,OAAOuE,CAAC,IAAM9I,EAAa,KAAOuE,EAAO,OAAOuE,CAAC,IAAM9I,EAAa,MAAO,CACpF6I,EAAeC,EACf,KACF,CAGF,QAASpH,EAAQ,EAAGA,EAAQ6C,EAAO,OAAO,OAAQ7C,IAAS,CACzD,MAAM2C,EAAYE,EAAO,OAAO7C,CAAK,EACrC,GAAI2C,IAAcrE,EAAa,IAAK,SAEpC,MAAM+I,EAAU1E,IAAcrE,EAAa,MACrCgJ,EAAQ3E,IAAcrE,EAAa,IACnCiJ,EAAU5E,IAAcrE,EAAa,MAErCkJ,EAAaxH,GAAS6C,EAAO,OAAO,OAAS,EAAIvE,EAAa,IAAMuE,EAAO,OAAO7C,EAAQ,CAAC,EAC3FyH,EAAazH,IAAU,EAAI1B,EAAa,IAAMuE,EAAO,OAAO7C,EAAQ,CAAC,EAGrE0H,EAAgBF,IAAelJ,EAAa,KAC/C,CAAC+I,GAAWG,IAAelJ,EAAa,OACxC,CAACgJ,GAAS,CAACC,IAAYC,IAAelJ,EAAa,KAAOkJ,IAAelJ,EAAa,OACnFqJ,EAAmBF,IAAenJ,EAAa,KAClD,CAAC+I,GAAWI,IAAenJ,EAAa,OACxC,CAACgJ,GAAS,CAACC,IAAYE,IAAenJ,EAAa,KAAOmJ,IAAenJ,EAAa,OAGzF,GAAI+I,GAAWG,IAAelJ,EAAa,KAAOkJ,IAAelJ,EAAa,KAAOkJ,IAAelJ,EAAa,MAAO,SAGxH,MAAMsJ,EAAiB,CAACP,GAAWzE,GAAeC,EAAQ7C,EAAO8C,CAAe,EAGhF,GAAI,CAACuE,GAAW,CAACK,GAAiB,CAACC,GAAoB,CAACC,EAAgB,SAGxE,IAAItD,EAAcvC,GAAc/B,EAAOC,CAAM,EACzCoE,EAAcC,EAAcrE,EAAO,YAOvC,GALIoH,IACF/C,GAAerE,EAAO,mBACtBoE,GAAepE,EAAO,oBAGpBoE,GAAe,EAAG,SAGtB,MAAMwD,GAAmBV,EAAenH,EAIxC,IAAI8H,EACJ,OAAQnF,EAAA,CACN,KAAKrE,EAAa,SAAUwJ,EAAgBxB,EAAa,MACzD,KAAKhI,EAAa,WAAYwJ,EAAgBvB,EAAe,MAC7D,KAAKjI,EAAa,SAAUwJ,EAAgBtB,EAAa,MACzD,KAAKlI,EAAa,SAAUwJ,EAAgBrB,EAAa,MACzD,KAAKnI,EAAa,YAAawJ,EAAgBpB,EAAgB,MAC/D,KAAKpI,EAAa,aAAcwJ,EAAgBnB,EAAiB,MACjE,KAAKrI,EAAa,WAAYwJ,EAAgBlB,EAAe,MAC7D,KAAKtI,EAAa,MAAOwJ,EAAgB3B,EAAW,MACpD,KAAK7H,EAAa,KAAMwJ,EAAgB1B,EAAU,MAClD,KAAK9H,EAAa,KAAMwJ,EAAgB7B,EAAU,MAClD,KAAK3H,EAAa,KAAMwJ,EAAgBzB,EAAU,MAClD,KAAK/H,EAAa,KAAMwJ,EAAgBjB,EAAU,MAClD,KAAKvI,EAAa,UAAWwJ,EAAgBf,EAAc,MAC3D,KAAKzI,EAAa,IAAKwJ,EAAgBd,EAAS,MAChD,KAAK1I,EAAa,MAAOwJ,EAAgBb,EAAW,MACpD,KAAK3I,EAAa,UAAWwJ,EAAgBZ,EAAc,MAC3D,QAASY,EAAgB9B,EAAS,KAAA,CAIpC,IAAIxC,EAAgB,EAChBqE,GAAmB,IACrBrE,EAAgB,KAAK,IAAI9D,GAAe,KAAK,IAAID,EAAmBoI,EAAgB,CAAC,GAIvF,MAAM5F,EAAUhC,EAAO,SAAW,CAAA,EAGlC,GAAIoH,GAAiBK,EAAe,CAClC,MAAMK,EAAU5D,EAAmBtB,EAAO,KAAMwB,EAAaC,EAAa,GAAM,GAAO,GAAOrE,EAAO,OAAO,EACxG8H,IACEV,EACFpE,EAAc/C,EAAW6H,EAAQ,UAAWA,EAAQ,QAASA,EAAQ,IAAKA,EAAQ,QAAS9H,EAAO,aAAc,EAAKgC,CAAO,EAE5HgB,EAAc6E,EAAeC,EAAQ,UAAWA,EAAQ,QAASA,EAAQ,IAAKA,EAAQ,QAAS9H,EAAO,aAAcuD,EAAevB,CAAO,EAGhJ,CAGA,GAAI,CAACoF,GAAWM,EAAkB,CAChC,MAAMK,EAAa7D,EAAmBtB,EAAO,KAAMwB,EAAaC,EAAa,GAAO,GAAM,GAAOrE,EAAO,OAAO,EAC/G,GAAI+H,EAAY,CACd,MAAMC,EAAiB,KAAK,IAAIvI,GAAe8D,EAAgB/D,CAAiB,EAE5EkD,IAAcrE,EAAa,MAC7B2E,EAAcgD,EAAU+B,EAAW,UAAWA,EAAW,QAASA,EAAW,IAAKA,EAAW,QAAS/H,EAAO,aAAcgI,EAAgBhG,CAAO,EACzIU,IAAcrE,EAAa,KACpC2E,EAAc8D,EAAciB,EAAW,UAAWA,EAAW,QAASA,EAAW,IAAKA,EAAW,QAAS/H,EAAO,aAAcgI,EAAgBhG,CAAO,EAEtJgB,EAAc6E,EAAeE,EAAW,UAAWA,EAAW,QAASA,EAAW,IAAKA,EAAW,QAAS/H,EAAO,aAAcgI,EAAgBhG,CAAO,CAE3J,CACF,CAGA,GAAI,CAACoF,GAAWO,EAAgB,CAC9B,MAAMM,EAAY/D,EAAmBtB,EAAO,KAAMwB,EAAaC,EAAa,GAAO,GAAO,GAAMrE,EAAO,OAAO,EAC1GiI,IAGEvF,IAAcrE,EAAa,MAC7B2E,EAAciD,EAAegC,EAAU,UAAWA,EAAU,QAASA,EAAU,IAAKA,EAAU,QAASjI,EAAO,aAAcuD,EAAevB,CAAO,EACzIU,IAAcrE,EAAa,KACpC2E,EAAc6D,EAAcoB,EAAU,UAAWA,EAAU,QAASA,EAAU,IAAKA,EAAU,QAASjI,EAAO,aAAcuD,EAAevB,CAAO,EAEjJgB,EAAc6E,EAAeI,EAAU,UAAWA,EAAU,QAASA,EAAU,IAAKA,EAAU,QAASjI,EAAO,aAAcuD,EAAevB,CAAO,EAGxJ,CACF,CACF,CAGA,KAAK,UAAakG,GAAsE,CACtF,KAAM,CAAE,KAAAC,EAAM,QAAAC,EAAS,aAAA5H,EAAc,OAAAR,CAAA,EAAWkI,EAAE,KAElD,GAAIC,IAAS,gBAAiB,CAC5B,MAAMpC,EAAUlE,EAAA,EACVmE,EAAWnE,EAAA,EACXoE,EAAgBpE,EAAA,EAChBqE,EAAYrE,EAAA,EACZsE,EAAWtE,EAAA,EACXuE,EAAWvE,EAAA,EACX5B,EAAY4B,EAAA,EAEZwE,EAAcxE,EAAA,EACdyE,EAAgBzE,EAAA,EAChB0E,EAAc1E,EAAA,EACd2E,EAAc3E,EAAA,EACd4E,EAAiB5E,EAAA,EACjB6E,EAAkB7E,EAAA,EAClB8E,EAAgB9E,EAAA,EAEhB+E,EAAW/E,EAAA,EACXgF,EAAehF,EAAA,EACfiF,EAAejF,EAAA,EACfkF,EAAUlF,EAAA,EAEVmF,EAAYnF,EAAA,EAEZoF,EAAepF,EAAA,EAGfgB,EAAkB,IAAI,IAC1B,OAAO,QAAQrC,CAAuD,EAAE,IAAI,CAAC,CAAC6H,EAAG1J,CAAC,IAAM,CAAC,SAAS0J,CAAC,EAAG1J,CAAC,CAAC,CAAA,EAG1G,UAAWiE,KAAUwF,EAAS,CAC5BtC,GACElD,EAAQC,EAAiB7C,EACzB+F,EAASC,EAAUC,EAAeC,EAAWC,EAAUC,EAAUnG,EACjEoG,EAAaC,EAAeC,EAAaC,EAAaC,EAAgBC,EAAiBC,EACvFC,EAAUC,EAAcC,EAAcC,EAASC,EAAWC,CAAA,EAI5D,QAASlH,EAAQ,EAAGA,EAAQ6C,EAAO,OAAO,OAAQ7C,IAC5C6C,EAAO,OAAO7C,CAAK,IAAM1B,EAAa,OAExCqB,GACEkD,EAAO,KAAK,SACZA,EAAO,KAAK,UACZA,EAAO,OACPC,EACA9C,EACAC,EACAC,CAAA,CAIR,CAGA,IAAIqI,EAAe,EACnB,UAAWC,IAAQ,CAACxC,EAASC,EAAUC,EAAeC,EAAWC,EAAUC,CAAQ,EACjFkC,GAAgBC,EAAK,WAAW,OAAO5J,GAAKA,EAAI,CAAC,EAAE,QAEjD2J,EAAe,GAAMtI,EAAO,SAAWA,EAAO,QAAQ,OAAS,IACjE,QAAQ,IAAI,sDAAsDsI,CAAY,EAAE,EAGlF,MAAME,EAAgC,CACpC,KAAM,iBACN,QAAAzC,EACA,SAAAC,EACA,cAAAC,EACA,UAAAC,EACA,SAAAC,EACA,SAAAC,EACA,UAAAnG,EACA,YAAAoG,EACA,cAAAC,EACA,YAAAC,EACA,YAAAC,EACA,eAAAC,EACA,gBAAAC,EACA,cAAAC,EACA,SAAAC,EACA,aAAAC,EACA,aAAAC,EACA,QAAAC,EACA,UAAAC,EACA,aAAAC,CAAA,EAIF,KAAK,YAAYuB,CAAM,CACzB,SAAWL,IAAS,qBAAsB,CAExC,MAAMM,EAAYP,EAAE,KACdQ,EAAiB,IAAI,IACzB,OAAO,QAAQD,EAAU,WAAW,EAAE,IAAI,CAAC,CAACJ,EAAG1J,CAAC,IAAM,CAAC,SAAS0J,CAAC,EAAG1J,CAAC,CAAC,CAAA,EAIlEkE,EAAkB,IAAI,IAC1B,OAAO,QAAQrC,CAAuD,EAAE,IAAI,CAAC,CAAC6H,EAAG1J,CAAC,IAAM,CAAC,SAAS0J,CAAC,EAAG1J,CAAC,CAAC,CAAA,EAIpGgK,EAAqD,CAAA,EAC3D,UAAWC,KAAcH,EAAU,gBACjCE,EAAgBC,CAAU,EAAIpG,GAAA,EAIhC,UAAWI,KAAUwF,EAAS,CAC5B,MAAMQ,EAAaF,EAAe,IAAI9F,EAAO,SAAS,EACtD,GAAIgG,IAAe,QAAa,CAACD,EAAgBC,CAAU,EAAG,SAE9D,MAAMC,EAAQF,EAAgBC,CAAU,EACxC9C,GACElD,EAAQC,EAAiB7C,EACzB6I,EAAM,QAASA,EAAM,SAAUA,EAAM,cACrCA,EAAM,UAAWA,EAAM,SAAUA,EAAM,SAAUA,EAAM,UACvDA,EAAM,YAAaA,EAAM,cAAeA,EAAM,YAC9CA,EAAM,YAAaA,EAAM,eAAgBA,EAAM,gBAAiBA,EAAM,cACtEA,EAAM,SAAUA,EAAM,aAAcA,EAAM,aAC1CA,EAAM,QAASA,EAAM,UAAWA,EAAM,YAAA,EAIxC,QAAS9I,EAAQ,EAAGA,EAAQ6C,EAAO,OAAO,OAAQ7C,IAC5C6C,EAAO,OAAO7C,CAAK,IAAM1B,EAAa,OACxCqB,GACEkD,EAAO,KAAK,SACZA,EAAO,KAAK,UACZA,EAAO,OACPC,EACA9C,EACAC,EACA6I,EAAM,SAAA,CAId,CAEA,MAAML,EAAqC,CACzC,KAAM,sBACN,gBAAAG,EACA,cAAeF,EAAU,eAAA,EAG3B,KAAK,YAAYD,CAAM,CACzB,CACF"}