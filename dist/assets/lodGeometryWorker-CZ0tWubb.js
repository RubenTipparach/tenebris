(function(){"use strict";function ae(){return{grassPositions:[],grassNormals:[],grassUvs:[],grassSkyLight:[],grassIndices:[],grassVertexOffset:0,dirtPositions:[],dirtNormals:[],dirtUvs:[],dirtSkyLight:[],dirtIndices:[],dirtVertexOffset:0,stonePositions:[],stoneNormals:[],stoneUvs:[],stoneSkyLight:[],stoneIndices:[],stoneVertexOffset:0,sandPositions:[],sandNormals:[],sandUvs:[],sandSkyLight:[],sandIndices:[],sandVertexOffset:0,woodPositions:[],woodNormals:[],woodUvs:[],woodSkyLight:[],woodIndices:[],woodVertexOffset:0,waterPositions:[],waterNormals:[],waterUvs:[],waterIndices:[],waterVertexOffset:0,sidePositions:[],sideNormals:[],sideUvs:[],sideSkyLight:[],sideIndices:[],sideVertexOffset:0,waterSidePositions:[],waterSideNormals:[],waterSideUvs:[],waterSideIndices:[],waterSideVertexOffset:0}}const N={AIR:0,STONE:1,DIRT:2,GRASS:3,WATER:4,SAND:5,WOOD:6};function se(B,_){return _.radius-(_.maxDepth-1-B)*_.blockHeight}function fe(B){return B.maxDepth-1-B.seaLevel}let G=null,ne=0;self.onmessage=B=>{const{type:_,tileData:oe,blockData:le,nearbyTiles:xe,tileToChunk:ue,config:X}=B.data;if(_==="buildLODGeometry"){const Q=new Set(xe),ee=new Map(Object.entries(ue).map(([f,g])=>[parseInt(f),g])),Y=new Map;for(const[f,g]of Object.entries(oe)){const t=parseInt(f),i=le[t];i&&Y.set(t,{tileIndex:t,tile:g,blocks:i})}const ie=Object.keys(oe).length;if(!G||ne!==ie){G=new Map,ne=ie;for(const[f,g]of Y){const t=g.tile,i=t.vertices.length,r=Math.sqrt(t.center.x*t.center.x+t.center.y*t.center.y+t.center.z*t.center.z),a=r>0?{x:t.center.x/r,y:t.center.y/r,z:t.center.z/r}:{x:0,y:0,z:0},e=[];for(const o of t.vertices){const m=Math.sqrt(o.x*o.x+o.y*o.y+o.z*o.z);e.push(m>0?{x:o.x/m,y:o.y/m,z:o.z/m}:{x:0,y:0,z:0})}const c=[];for(let o=0;o<i;o++){const m=(o+1)%i,v=t.vertices[o],O=t.vertices[m],I=v.x+O.x,w=v.y+O.y,z=v.z+O.z,p=Math.sqrt(I*I+w*w+z*z);c.push(p>0?{x:I/p,y:w/p,z:z/p}:{x:0,y:0,z:0})}const x=[];for(let o=0;o<i;o++){const m=c[o];let v=-1,O=1/0;for(const I of t.neighbors){const w=Y.get(I);if(!w)continue;const z=w.tile.center,p=Math.sqrt(z.x*z.x+z.y*z.y+z.z*z.z);if(p===0)continue;const E=z.x/p,T=z.y/p,U=z.z/p,M=E-m.x,R=T-m.y,b=U-m.z,$=M*M+R*R+b*b;$<O&&(O=$,v=I)}x.push(v)}const s=Math.abs(a.y)<.9?{x:0,y:1,z:0}:{x:1,y:0,z:0},d=s.y*a.z-s.z*a.y,u=s.z*a.x-s.x*a.z,n=s.x*a.y-s.y*a.x,l=Math.sqrt(d*d+u*u+n*n),h=l>0?{x:d/l,y:u/l,z:n/l}:{x:1,y:0,z:0},V=a.y*h.z-a.z*h.y,S=a.z*h.x-a.x*h.z,L=a.x*h.y-a.y*h.x,y={x:V,y:S,z:L},k=[];let P=1/0,A=-1/0,C=1/0,W=-1/0;for(const o of t.vertices){const m=o.x-t.center.x,v=o.y-t.center.y,O=o.z-t.center.z,I=m*h.x+v*h.y+O*h.z,w=m*y.x+v*y.y+O*y.z;k.push({u:I,v:w}),P=Math.min(P,I),A=Math.max(A,I),C=Math.min(C,w),W=Math.max(W,w)}const q=A-P,Z=W-C,J=k.map(o=>({u:(o.u-P)/q,v:(o.v-C)/Z})),K={u:(0-P)/q,v:(0-C)/Z};G.set(f,{normalizedCenter:a,normalizedVertices:e,edgeMidDirs:c,edgeNeighborIdx:x,normalizedUVs:J,centerUV:K})}}const F=[];for(let f=0;f<X.chunkCount;f++)F.push(ae());const ye=fe(X),re=se(ye,X)-X.lodOffset,H=new Map;for(const[f,g]of Y){let t=0,i=N.GRASS;const r=g.blocks;for(let c=r.length-1;c>=0;c--)if(r[c]!==N.AIR){t=c,i=r[c];break}const a=i===N.WATER,e=a?re:se(t,X)-X.lodOffset;H.set(f,{radius:e,isWater:a,surfaceBlockType:i})}const D=X.cameraDir,te=-.2;for(const[f]of Y){if(Q.has(f))continue;const g=G.get(f);if(D){const y=g.normalizedCenter;if(y.x*D.x+y.y*D.y+y.z*D.z<te)continue}const t=H.get(f),i=t.radius,r=t.surfaceBlockType,a=ee.get(f)??0,e=F[a];let c,x,s,d,u,n;r===N.WATER?(c=e.waterPositions,x=e.waterNormals,s=e.waterUvs,d=null,u=e.waterIndices,n=e.waterVertexOffset):r===N.DIRT?(c=e.dirtPositions,x=e.dirtNormals,s=e.dirtUvs,d=e.dirtSkyLight,u=e.dirtIndices,n=e.dirtVertexOffset):r===N.STONE?(c=e.stonePositions,x=e.stoneNormals,s=e.stoneUvs,d=e.stoneSkyLight,u=e.stoneIndices,n=e.stoneVertexOffset):r===N.SAND?(c=e.sandPositions,x=e.sandNormals,s=e.sandUvs,d=e.sandSkyLight,u=e.sandIndices,n=e.sandVertexOffset):r===N.WOOD?(c=e.woodPositions,x=e.woodNormals,s=e.woodUvs,d=e.woodSkyLight,u=e.woodIndices,n=e.woodVertexOffset):(c=e.grassPositions,x=e.grassNormals,s=e.grassUvs,d=e.grassSkyLight,u=e.grassIndices,n=e.grassVertexOffset);const l=g.normalizedCenter,h=g.normalizedVertices,V=g.normalizedUVs,S=g.centerUV,L=n;c.push(l.x*i,l.y*i,l.z*i),x.push(l.x,l.y,l.z),s.push(S.u,S.v),d&&d.push(1),n++;for(let y=0;y<h.length;y++){const k=h[y];c.push(k.x*i,k.y*i,k.z*i),x.push(l.x,l.y,l.z),s.push(V[y].u,V[y].v),d&&d.push(1),n++,u.push(L,L+1+y,L+1+(y+1)%h.length)}r===N.WATER?e.waterVertexOffset=n:r===N.DIRT?e.dirtVertexOffset=n:r===N.STONE?e.stoneVertexOffset=n:r===N.SAND?e.sandVertexOffset=n:r===N.WOOD?e.woodVertexOffset=n:e.grassVertexOffset=n}for(const[f]of Y){if(Q.has(f))continue;const g=G.get(f);if(D){const d=g.normalizedCenter;if(d.x*D.x+d.y*D.y+d.z*D.z<te)continue}const t=H.get(f),i=t.radius,r=t.isWater,a=g.normalizedVertices,e=g.edgeNeighborIdx,c=a.length,x=ee.get(f)??0,s=F[x];for(let d=0;d<c;d++){const u=e[d];if(u<0)continue;const n=H.get(u);if(!n)continue;const l=n.radius;if(i<=l)continue;const h=(d+1)%c,V=a[d],S=a[h],L=V.x*l,y=V.y*l,k=V.z*l,P=S.x*l,A=S.y*l,C=S.z*l,W=V.x*i,q=V.y*i,Z=V.z*i,J=S.x*i,K=S.y*i,o=S.z*i,m=P-L,v=A-y,O=C-k,I=W-L,w=q-y,z=Z-k,p=v*z-O*w,E=O*I-m*z,T=m*w-v*I,U=Math.sqrt(p*p+E*E+T*T),M=U>0?p/U:0,R=U>0?E/U:0,b=U>0?T/U:0,$=r?s.waterSidePositions:s.sidePositions,ge=r?s.waterSideNormals:s.sideNormals,ze=r?s.waterSideUvs:s.sideUvs,ce=r?null:s.sideSkyLight,de=r?s.waterSideIndices:s.sideIndices,j=r?s.waterSideVertexOffset:s.sideVertexOffset;$.push(L,y,k,P,A,C,J,K,o,W,q,Z),ge.push(M,R,b,M,R,b,M,R,b,M,R,b),ze.push(0,0,1,0,1,1,0,1),ce&&ce.push(1,1,1,1),de.push(j,j+1,j+2),de.push(j,j+2,j+3),r?s.waterSideVertexOffset+=4:s.sideVertexOffset+=4}}for(const[f]of Y){if(Q.has(f))continue;const g=G.get(f);if(D){const x=g.normalizedCenter;if(x.x*D.x+x.y*D.y+x.z*D.z<te)continue}const t=H.get(f);if(!t||!t.isWater)continue;const i=g.normalizedVertices,r=g.edgeNeighborIdx,a=i.length,e=ee.get(f)??0,c=F[e];for(let x=0;x<a;x++){const s=r[x];if(s<0||!Q.has(s))continue;const d=H.get(s);if(!d)continue;const u=d.radius,n=re;if(u>=n)continue;const l=(x+1)%a,h=i[x],V=i[l],S=h.x*u,L=h.y*u,y=h.z*u,k=V.x*u,P=V.y*u,A=V.z*u,C=h.x*n,W=h.y*n,q=h.z*n,Z=V.x*n,J=V.y*n,K=V.z*n,o=k-S,m=P-L,v=A-y,O=C-S,I=W-L,w=q-y,z=m*w-v*I,p=v*O-o*w,E=o*I-m*O,T=Math.sqrt(z*z+p*p+E*E),U=T>0?z/T:0,M=T>0?p/T:0,R=T>0?E/T:0,b=c.waterSideVertexOffset;c.waterSidePositions.push(S,L,y,k,P,A,Z,J,K,C,W,q),c.waterSideNormals.push(U,M,R,U,M,R,U,M,R,U,M,R),c.waterSideUvs.push(0,0,1,0,1,1,0,1),c.waterSideIndices.push(b,b+1,b+2),c.waterSideIndices.push(b,b+2,b+3),c.waterSideVertexOffset+=4}}const he={type:"lodGeometryResult",chunkGeometries:F};self.postMessage(he)}}})();
//# sourceMappingURL=lodGeometryWorker-CZ0tWubb.js.map
