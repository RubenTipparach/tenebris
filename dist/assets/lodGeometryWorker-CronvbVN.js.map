{"version":3,"file":"lodGeometryWorker-CronvbVN.js","sources":["../src/workers/lodGeometryWorker.ts"],"sourcesContent":["// LOD Geometry Worker - builds LOD terrain geometry off the main thread\r\n// Optimized: pre-computed normalizations, cached surface data, reduced passes\r\n\r\n// Vector3-like operations using plain objects\r\ninterface Vec3 {\r\n  x: number;\r\n  y: number;\r\n  z: number;\r\n}\r\n\r\n// Note: Vector operations are inlined in hot loops to avoid function call overhead\r\n// and object allocations. The raw x/y/z math is faster than helper functions.\r\n\r\n// Per-chunk geometry buffers\r\ninterface ChunkGeometry {\r\n  grassPositions: number[];\r\n  grassNormals: number[];\r\n  grassUvs: number[];\r\n  grassSkyLight: number[];  // Sky light attribute for terrain shader\r\n  grassIndices: number[];\r\n  grassVertexOffset: number;\r\n  dirtPositions: number[];\r\n  dirtNormals: number[];\r\n  dirtUvs: number[];\r\n  dirtSkyLight: number[];\r\n  dirtIndices: number[];\r\n  dirtVertexOffset: number;\r\n  stonePositions: number[];\r\n  stoneNormals: number[];\r\n  stoneUvs: number[];\r\n  stoneSkyLight: number[];\r\n  stoneIndices: number[];\r\n  stoneVertexOffset: number;\r\n  sandPositions: number[];\r\n  sandNormals: number[];\r\n  sandUvs: number[];\r\n  sandSkyLight: number[];\r\n  sandIndices: number[];\r\n  sandVertexOffset: number;\r\n  woodPositions: number[];\r\n  woodNormals: number[];\r\n  woodUvs: number[];\r\n  woodSkyLight: number[];\r\n  woodIndices: number[];\r\n  woodVertexOffset: number;\r\n  waterPositions: number[];\r\n  waterNormals: number[];\r\n  waterUvs: number[];\r\n  waterIndices: number[];\r\n  waterVertexOffset: number;\r\n  sidePositions: number[];\r\n  sideNormals: number[];\r\n  sideUvs: number[];\r\n  sideSkyLight: number[];\r\n  sideIndices: number[];\r\n  sideVertexOffset: number;\r\n  waterSidePositions: number[];\r\n  waterSideNormals: number[];\r\n  waterSideUvs: number[];\r\n  waterSideIndices: number[];\r\n  waterSideVertexOffset: number;\r\n}\r\n\r\nfunction createEmptyChunkGeometry(): ChunkGeometry {\r\n  return {\r\n    grassPositions: [], grassNormals: [], grassUvs: [], grassSkyLight: [], grassIndices: [], grassVertexOffset: 0,\r\n    dirtPositions: [], dirtNormals: [], dirtUvs: [], dirtSkyLight: [], dirtIndices: [], dirtVertexOffset: 0,\r\n    stonePositions: [], stoneNormals: [], stoneUvs: [], stoneSkyLight: [], stoneIndices: [], stoneVertexOffset: 0,\r\n    sandPositions: [], sandNormals: [], sandUvs: [], sandSkyLight: [], sandIndices: [], sandVertexOffset: 0,\r\n    woodPositions: [], woodNormals: [], woodUvs: [], woodSkyLight: [], woodIndices: [], woodVertexOffset: 0,\r\n    waterPositions: [], waterNormals: [], waterUvs: [], waterIndices: [], waterVertexOffset: 0,\r\n    sidePositions: [], sideNormals: [], sideUvs: [], sideSkyLight: [], sideIndices: [], sideVertexOffset: 0,\r\n    waterSidePositions: [], waterSideNormals: [], waterSideUvs: [], waterSideIndices: [], waterSideVertexOffset: 0\r\n  };\r\n}\r\n\r\n// Tile data passed from main thread\r\ninterface TileData {\r\n  index: number;\r\n  vertices: Vec3[];\r\n  center: Vec3;\r\n  neighbors: number[];\r\n}\r\n\r\n// Column data passed from main thread\r\ninterface ColumnData {\r\n  tileIndex: number;\r\n  tile: TileData;\r\n  blocks: number[];\r\n}\r\n\r\n// Pre-computed tile data for fast access\r\ninterface PrecomputedTileData {\r\n  normalizedCenter: Vec3;\r\n  normalizedVertices: Vec3[];\r\n  // Edge midpoint normalized directions (for neighbor lookup)\r\n  edgeMidDirs: Vec3[];\r\n  // Which neighbor is across each edge (index into neighbors array, -1 if none found)\r\n  edgeNeighborIdx: number[];\r\n  // Pre-computed normalized UVs for each vertex (0-1 range, touching edges)\r\n  normalizedUVs: { u: number; v: number }[];\r\n  // Center UV (where the face center maps to in UV space)\r\n  centerUV: { u: number; v: number };\r\n}\r\n\r\n// Block types (must match HexBlock.ts)\r\nconst HexBlockType = {\r\n  AIR: 0,\r\n  STONE: 1,\r\n  DIRT: 2,\r\n  GRASS: 3,\r\n  WATER: 4,\r\n  SAND: 5,\r\n  WOOD: 6,\r\n  LEAVES: 7\r\n};\r\n\r\n// Config passed from main thread\r\ninterface LODWorkerConfig {\r\n  radius: number;\r\n  blockHeight: number;\r\n  seaLevel: number;\r\n  maxDepth: number;  // Total depth (for radius calculation)\r\n  waterSurfaceOffset: number;\r\n  lodOffset: number;\r\n  chunkCount: number;\r\n  // Camera direction from planet center for back-face culling\r\n  cameraDir?: Vec3;\r\n}\r\n\r\n// Helper to convert depth to radius (0 = bedrock, maxDepth-1 = sky)\r\nfunction depthToRadius(depth: number, config: LODWorkerConfig): number {\r\n  return config.radius - (config.maxDepth - 1 - depth) * config.blockHeight;\r\n}\r\n\r\n// Get sea level depth in new system (0 = bedrock)\r\nfunction getSeaLevelDepth(config: LODWorkerConfig): number {\r\n  return config.maxDepth - 1 - config.seaLevel;\r\n}\r\n\r\n// Message types\r\ninterface BuildLODGeometryMessage {\r\n  type: 'buildLODGeometry';\r\n  tileData: Record<number, TileData>;\r\n  blockData: Record<number, number[]>;\r\n  nearbyTiles: number[];\r\n  tileToChunk: Record<number, number>;\r\n  config: LODWorkerConfig;\r\n}\r\n\r\ninterface LODGeometryResultMessage {\r\n  type: 'lodGeometryResult';\r\n  chunkGeometries: ChunkGeometry[];\r\n}\r\n\r\n// Cached pre-computed data (persists across messages for same tile structure)\r\nlet cachedPrecomputed: Map<number, PrecomputedTileData> | null = null;\r\nlet cachedTileCount = 0;\r\n\r\n// Worker message handler\r\nself.onmessage = (e: MessageEvent<BuildLODGeometryMessage>) => {\r\n  const { type, tileData, blockData, nearbyTiles, tileToChunk, config } = e.data;\r\n\r\n  if (type === 'buildLODGeometry') {\r\n    const nearbyTilesSet = new Set(nearbyTiles);\r\n    const tileToChunkMap = new Map(Object.entries(tileToChunk).map(([k, v]) => [parseInt(k), v]));\r\n\r\n    // Reconstruct columns from separate tile and block data\r\n    const columnsMap = new Map<number, ColumnData>();\r\n    for (const [tileIndexStr, tile] of Object.entries(tileData)) {\r\n      const tileIndex = parseInt(tileIndexStr);\r\n      const blocks = blockData[tileIndex];\r\n      if (blocks) {\r\n        columnsMap.set(tileIndex, { tileIndex, tile, blocks });\r\n      }\r\n    }\r\n\r\n    // Pre-compute normalized data if not cached or tile count changed\r\n    const tileCount = Object.keys(tileData).length;\r\n    if (!cachedPrecomputed || cachedTileCount !== tileCount) {\r\n      cachedPrecomputed = new Map();\r\n      cachedTileCount = tileCount;\r\n\r\n      for (const [tileIndex, column] of columnsMap) {\r\n        const tile = column.tile;\r\n        const numVerts = tile.vertices.length;\r\n\r\n        // Normalize center once\r\n        const centerLen = Math.sqrt(tile.center.x * tile.center.x + tile.center.y * tile.center.y + tile.center.z * tile.center.z);\r\n        const normalizedCenter: Vec3 = centerLen > 0\r\n          ? { x: tile.center.x / centerLen, y: tile.center.y / centerLen, z: tile.center.z / centerLen }\r\n          : { x: 0, y: 0, z: 0 };\r\n\r\n        // Normalize all vertices once\r\n        const normalizedVertices: Vec3[] = [];\r\n        for (const v of tile.vertices) {\r\n          const vLen = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\r\n          normalizedVertices.push(vLen > 0\r\n            ? { x: v.x / vLen, y: v.y / vLen, z: v.z / vLen }\r\n            : { x: 0, y: 0, z: 0 });\r\n        }\r\n\r\n        // Pre-compute edge midpoint directions\r\n        const edgeMidDirs: Vec3[] = [];\r\n        for (let i = 0; i < numVerts; i++) {\r\n          const next = (i + 1) % numVerts;\r\n          const v1 = tile.vertices[i];\r\n          const v2 = tile.vertices[next];\r\n          const midX = v1.x + v2.x;\r\n          const midY = v1.y + v2.y;\r\n          const midZ = v1.z + v2.z;\r\n          const midLen = Math.sqrt(midX * midX + midY * midY + midZ * midZ);\r\n          edgeMidDirs.push(midLen > 0\r\n            ? { x: midX / midLen, y: midY / midLen, z: midZ / midLen }\r\n            : { x: 0, y: 0, z: 0 });\r\n        }\r\n\r\n        // Pre-compute which neighbor is across each edge\r\n        const edgeNeighborIdx: number[] = [];\r\n        for (let i = 0; i < numVerts; i++) {\r\n          const edgeMidDir = edgeMidDirs[i];\r\n          let closestNeighbor = -1;\r\n          let closestDist = Infinity;\r\n\r\n          for (const nIdx of tile.neighbors) {\r\n            const neighborColumn = columnsMap.get(nIdx);\r\n            if (!neighborColumn) continue;\r\n\r\n            const nc = neighborColumn.tile.center;\r\n            const ncLen = Math.sqrt(nc.x * nc.x + nc.y * nc.y + nc.z * nc.z);\r\n            if (ncLen === 0) continue;\r\n\r\n            const ncNormX = nc.x / ncLen;\r\n            const ncNormY = nc.y / ncLen;\r\n            const ncNormZ = nc.z / ncLen;\r\n\r\n            const dx = ncNormX - edgeMidDir.x;\r\n            const dy = ncNormY - edgeMidDir.y;\r\n            const dz = ncNormZ - edgeMidDir.z;\r\n            const dist = dx * dx + dy * dy + dz * dz;\r\n\r\n            if (dist < closestDist) {\r\n              closestDist = dist;\r\n              closestNeighbor = nIdx;\r\n            }\r\n          }\r\n          edgeNeighborIdx.push(closestNeighbor);\r\n        }\r\n\r\n        // Pre-compute local coordinate system for UV mapping\r\n        // Create tangent and bitangent vectors perpendicular to the normal\r\n        const up: Vec3 = Math.abs(normalizedCenter.y) < 0.9\r\n          ? { x: 0, y: 1, z: 0 }\r\n          : { x: 1, y: 0, z: 0 };\r\n\r\n        // tangent = cross(up, normal)\r\n        const tangentX = up.y * normalizedCenter.z - up.z * normalizedCenter.y;\r\n        const tangentY = up.z * normalizedCenter.x - up.x * normalizedCenter.z;\r\n        const tangentZ = up.x * normalizedCenter.y - up.y * normalizedCenter.x;\r\n        const tangentLen = Math.sqrt(tangentX * tangentX + tangentY * tangentY + tangentZ * tangentZ);\r\n        const tangent: Vec3 = tangentLen > 0\r\n          ? { x: tangentX / tangentLen, y: tangentY / tangentLen, z: tangentZ / tangentLen }\r\n          : { x: 1, y: 0, z: 0 };\r\n\r\n        // bitangent = cross(normal, tangent)\r\n        const bitangentX = normalizedCenter.y * tangent.z - normalizedCenter.z * tangent.y;\r\n        const bitangentY = normalizedCenter.z * tangent.x - normalizedCenter.x * tangent.z;\r\n        const bitangentZ = normalizedCenter.x * tangent.y - normalizedCenter.y * tangent.x;\r\n        const bitangent: Vec3 = { x: bitangentX, y: bitangentY, z: bitangentZ };\r\n\r\n        // Project vertices onto local 2D plane and find bounding box\r\n        const localCoords: { u: number; v: number }[] = [];\r\n        let minU = Infinity, maxU = -Infinity, minV = Infinity, maxV = -Infinity;\r\n\r\n        for (const vert of tile.vertices) {\r\n          // Vector from center to vertex\r\n          const toVertX = vert.x - tile.center.x;\r\n          const toVertY = vert.y - tile.center.y;\r\n          const toVertZ = vert.z - tile.center.z;\r\n\r\n          // Project onto tangent and bitangent\r\n          const u = toVertX * tangent.x + toVertY * tangent.y + toVertZ * tangent.z;\r\n          const v = toVertX * bitangent.x + toVertY * bitangent.y + toVertZ * bitangent.z;\r\n          localCoords.push({ u, v });\r\n\r\n          minU = Math.min(minU, u);\r\n          maxU = Math.max(maxU, u);\r\n          minV = Math.min(minV, v);\r\n          maxV = Math.max(maxV, v);\r\n        }\r\n\r\n        // Normalize UVs to 0-1 range\r\n        const rangeU = maxU - minU;\r\n        const rangeV = maxV - minV;\r\n        const normalizedUVs: { u: number; v: number }[] = localCoords.map(coord => ({\r\n          u: (coord.u - minU) / rangeU,\r\n          v: (coord.v - minV) / rangeV\r\n        }));\r\n\r\n        // Center UV (the center vertex at (0,0) in local coords maps to this UV)\r\n        const centerUV = {\r\n          u: (0 - minU) / rangeU,\r\n          v: (0 - minV) / rangeV\r\n        };\r\n\r\n        cachedPrecomputed.set(tileIndex, {\r\n          normalizedCenter,\r\n          normalizedVertices,\r\n          edgeMidDirs,\r\n          edgeNeighborIdx,\r\n          normalizedUVs,\r\n          centerUV\r\n        });\r\n      }\r\n    }\r\n\r\n    const chunkGeometries: ChunkGeometry[] = [];\r\n    for (let i = 0; i < config.chunkCount; i++) {\r\n      chunkGeometries.push(createEmptyChunkGeometry());\r\n    }\r\n\r\n    const seaLevelDepth = getSeaLevelDepth(config);\r\n    const waterRadius = depthToRadius(seaLevelDepth, config) - config.lodOffset;\r\n\r\n    // Combined first pass: calculate display radius AND surface block type for each tile\r\n    // This eliminates redundant block array searches\r\n    interface TileInfo {\r\n      radius: number;           // Display radius for LOD rendering\r\n      isWater: boolean;         // True if surface is water\r\n      surfaceBlockType: number; // The topmost non-air block type\r\n      terrainRadius: number;    // Radius of actual solid terrain (for water walls)\r\n    }\r\n    const tileInfo = new Map<number, TileInfo>();\r\n\r\n    for (const [tileIndex, column] of columnsMap) {\r\n      // Find surface depth (topmost non-air block, searching from top down)\r\n      let surfaceDepth = 0;\r\n      let surfaceBlockType = HexBlockType.GRASS;\r\n      let terrainDepth = 0; // Topmost solid block (ignoring water)\r\n      const blocks = column.blocks;\r\n      for (let d = blocks.length - 1; d >= 0; d--) {\r\n        if (blocks[d] !== HexBlockType.AIR) {\r\n          if (surfaceBlockType === HexBlockType.GRASS) {\r\n            // First non-air block found\r\n            surfaceDepth = d;\r\n            surfaceBlockType = blocks[d];\r\n          }\r\n          if (blocks[d] !== HexBlockType.WATER) {\r\n            // First solid (non-water) block found\r\n            terrainDepth = d;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      const isWater = surfaceBlockType === HexBlockType.WATER;\r\n      const displayRadius = isWater\r\n        ? waterRadius\r\n        : depthToRadius(surfaceDepth, config) - config.lodOffset;\r\n      const terrainRadius = depthToRadius(terrainDepth, config) - config.lodOffset;\r\n\r\n      tileInfo.set(tileIndex, { radius: displayRadius, isWater, surfaceBlockType, terrainRadius });\r\n    }\r\n\r\n    // Back-face culling threshold: skip tiles facing away from camera\r\n    // Use -0.2 to include tiles slightly past the horizon (for smooth edges)\r\n    const cameraDir = config.cameraDir;\r\n    const CULL_THRESHOLD = -0.2;\r\n\r\n    // Second pass: build top faces for LOD tiles (uses cached data)\r\n    for (const [tileIndex] of columnsMap) {\r\n      if (nearbyTilesSet.has(tileIndex)) continue;\r\n\r\n      const precomputed = cachedPrecomputed.get(tileIndex)!;\r\n\r\n      // Back-face culling: skip tiles facing away from camera\r\n      if (cameraDir) {\r\n        const nc = precomputed.normalizedCenter;\r\n        const dot = nc.x * cameraDir.x + nc.y * cameraDir.y + nc.z * cameraDir.z;\r\n        if (dot < CULL_THRESHOLD) continue;\r\n      }\r\n\r\n      const info = tileInfo.get(tileIndex)!\r\n      const displayRadius = info.radius;\r\n      const surfaceBlockType = info.surfaceBlockType;\r\n\r\n      const chunkIdx = tileToChunkMap.get(tileIndex) ?? 0;\r\n      const chunk = chunkGeometries[chunkIdx];\r\n\r\n      // Select buffer based on surface type\r\n      let positions: number[], normals: number[], uvs: number[], skyLight: number[] | null, indices: number[];\r\n      let vertexOffset: number;\r\n\r\n      if (surfaceBlockType === HexBlockType.WATER) {\r\n        positions = chunk.waterPositions;\r\n        normals = chunk.waterNormals;\r\n        uvs = chunk.waterUvs;\r\n        skyLight = null; // Water uses different shader, doesn't need skyLight\r\n        indices = chunk.waterIndices;\r\n        vertexOffset = chunk.waterVertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.DIRT) {\r\n        positions = chunk.dirtPositions;\r\n        normals = chunk.dirtNormals;\r\n        uvs = chunk.dirtUvs;\r\n        skyLight = chunk.dirtSkyLight;\r\n        indices = chunk.dirtIndices;\r\n        vertexOffset = chunk.dirtVertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.STONE) {\r\n        positions = chunk.stonePositions;\r\n        normals = chunk.stoneNormals;\r\n        uvs = chunk.stoneUvs;\r\n        skyLight = chunk.stoneSkyLight;\r\n        indices = chunk.stoneIndices;\r\n        vertexOffset = chunk.stoneVertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.SAND) {\r\n        positions = chunk.sandPositions;\r\n        normals = chunk.sandNormals;\r\n        uvs = chunk.sandUvs;\r\n        skyLight = chunk.sandSkyLight;\r\n        indices = chunk.sandIndices;\r\n        vertexOffset = chunk.sandVertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.WOOD) {\r\n        positions = chunk.woodPositions;\r\n        normals = chunk.woodNormals;\r\n        uvs = chunk.woodUvs;\r\n        skyLight = chunk.woodSkyLight;\r\n        indices = chunk.woodIndices;\r\n        vertexOffset = chunk.woodVertexOffset;\r\n      } else {\r\n        // GRASS, LEAVES, or any other type defaults to grass\r\n        positions = chunk.grassPositions;\r\n        normals = chunk.grassNormals;\r\n        uvs = chunk.grassUvs;\r\n        skyLight = chunk.grassSkyLight;\r\n        indices = chunk.grassIndices;\r\n        vertexOffset = chunk.grassVertexOffset;\r\n      }\r\n\r\n      // Use pre-computed normalized center, vertices, and UVs\r\n      const normal = precomputed.normalizedCenter;\r\n      const normalizedVerts = precomputed.normalizedVertices;\r\n      const normalizedUVs = precomputed.normalizedUVs;\r\n      const centerUV = precomputed.centerUV;\r\n\r\n      // Fan triangulation from center\r\n      const centerIdx = vertexOffset;\r\n      positions.push(\r\n        normal.x * displayRadius,\r\n        normal.y * displayRadius,\r\n        normal.z * displayRadius\r\n      );\r\n      normals.push(normal.x, normal.y, normal.z);\r\n      uvs.push(centerUV.u, centerUV.v);\r\n      if (skyLight) skyLight.push(1.0); // LOD terrain is always at surface, full sky exposure\r\n      vertexOffset++;\r\n\r\n      for (let i = 0; i < normalizedVerts.length; i++) {\r\n        const nv = normalizedVerts[i];\r\n        positions.push(nv.x * displayRadius, nv.y * displayRadius, nv.z * displayRadius);\r\n        normals.push(normal.x, normal.y, normal.z);\r\n        uvs.push(normalizedUVs[i].u, normalizedUVs[i].v);\r\n        if (skyLight) skyLight.push(1.0);\r\n        vertexOffset++;\r\n\r\n        indices.push(centerIdx, centerIdx + 1 + i, centerIdx + 1 + ((i + 1) % normalizedVerts.length));\r\n      }\r\n\r\n      // Update offset\r\n      if (surfaceBlockType === HexBlockType.WATER) {\r\n        chunk.waterVertexOffset = vertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.DIRT) {\r\n        chunk.dirtVertexOffset = vertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.STONE) {\r\n        chunk.stoneVertexOffset = vertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.SAND) {\r\n        chunk.sandVertexOffset = vertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.WOOD) {\r\n        chunk.woodVertexOffset = vertexOffset;\r\n      } else {\r\n        chunk.grassVertexOffset = vertexOffset;\r\n      }\r\n    }\r\n\r\n    // Third pass: generate side walls (uses cached edge-neighbor mapping)\r\n    for (const [tileIndex] of columnsMap) {\r\n      if (nearbyTilesSet.has(tileIndex)) continue;\r\n\r\n      const precomputed = cachedPrecomputed.get(tileIndex)!;\r\n\r\n      // Back-face culling: skip tiles facing away from camera\r\n      if (cameraDir) {\r\n        const nc = precomputed.normalizedCenter;\r\n        const dot = nc.x * cameraDir.x + nc.y * cameraDir.y + nc.z * cameraDir.z;\r\n        if (dot < CULL_THRESHOLD) continue;\r\n      }\r\n\r\n      const info = tileInfo.get(tileIndex)!\r\n      const thisRadius = info.radius;\r\n      const thisIsWater = info.isWater;\r\n      const normalizedVerts = precomputed.normalizedVertices;\r\n      const edgeNeighborIdx = precomputed.edgeNeighborIdx;\r\n      const numSides = normalizedVerts.length;\r\n\r\n      const chunkIdx = tileToChunkMap.get(tileIndex) ?? 0;\r\n      const chunk = chunkGeometries[chunkIdx];\r\n\r\n      for (let i = 0; i < numSides; i++) {\r\n        const neighborTileIdx = edgeNeighborIdx[i];\r\n        if (neighborTileIdx < 0) continue;\r\n\r\n        const neighborInfo = tileInfo.get(neighborTileIdx);\r\n        if (!neighborInfo) continue;\r\n\r\n        const neighborRadius = neighborInfo.radius;\r\n\r\n        // Generate wall only when this tile is higher than neighbor\r\n        // This applies to both solid and water tiles - walls show height differences\r\n        if (thisRadius <= neighborRadius) continue;\r\n\r\n        const next = (i + 1) % numSides;\r\n        const nv1 = normalizedVerts[i];\r\n        const nv2 = normalizedVerts[next];\r\n\r\n        // Create wall vertices using pre-normalized directions\r\n        const innerV1x = nv1.x * neighborRadius, innerV1y = nv1.y * neighborRadius, innerV1z = nv1.z * neighborRadius;\r\n        const innerV2x = nv2.x * neighborRadius, innerV2y = nv2.y * neighborRadius, innerV2z = nv2.z * neighborRadius;\r\n        const outerV1x = nv1.x * thisRadius, outerV1y = nv1.y * thisRadius, outerV1z = nv1.z * thisRadius;\r\n        const outerV2x = nv2.x * thisRadius, outerV2y = nv2.y * thisRadius, outerV2z = nv2.z * thisRadius;\r\n\r\n        // Calculate side normal\r\n        const edge1x = innerV2x - innerV1x, edge1y = innerV2y - innerV1y, edge1z = innerV2z - innerV1z;\r\n        const edge2x = outerV1x - innerV1x, edge2y = outerV1y - innerV1y, edge2z = outerV1z - innerV1z;\r\n        const crossX = edge1y * edge2z - edge1z * edge2y;\r\n        const crossY = edge1z * edge2x - edge1x * edge2z;\r\n        const crossZ = edge1x * edge2y - edge1y * edge2x;\r\n        const crossLen = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);\r\n        const snx = crossLen > 0 ? crossX / crossLen : 0;\r\n        const sny = crossLen > 0 ? crossY / crossLen : 0;\r\n        const snz = crossLen > 0 ? crossZ / crossLen : 0;\r\n\r\n        const positions = thisIsWater ? chunk.waterSidePositions : chunk.sidePositions;\r\n        const normals = thisIsWater ? chunk.waterSideNormals : chunk.sideNormals;\r\n        const uvs = thisIsWater ? chunk.waterSideUvs : chunk.sideUvs;\r\n        const skyLight = thisIsWater ? null : chunk.sideSkyLight;\r\n        const indices = thisIsWater ? chunk.waterSideIndices : chunk.sideIndices;\r\n        const baseIdx = thisIsWater ? chunk.waterSideVertexOffset : chunk.sideVertexOffset;\r\n\r\n        positions.push(\r\n          innerV1x, innerV1y, innerV1z,\r\n          innerV2x, innerV2y, innerV2z,\r\n          outerV2x, outerV2y, outerV2z,\r\n          outerV1x, outerV1y, outerV1z\r\n        );\r\n\r\n        normals.push(snx, sny, snz, snx, sny, snz, snx, sny, snz, snx, sny, snz);\r\n        uvs.push(0, 0, 1, 0, 1, 1, 0, 1);\r\n        if (skyLight) skyLight.push(1.0, 1.0, 1.0, 1.0); // Full sky exposure for LOD\r\n\r\n        indices.push(baseIdx, baseIdx + 1, baseIdx + 2);\r\n        indices.push(baseIdx, baseIdx + 2, baseIdx + 3);\r\n\r\n        if (thisIsWater) {\r\n          chunk.waterSideVertexOffset += 4;\r\n        } else {\r\n          chunk.sideVertexOffset += 4;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fourth pass: water boundary walls at LOD/terrain edge\r\n    for (const [tileIndex] of columnsMap) {\r\n      if (nearbyTilesSet.has(tileIndex)) continue;\r\n\r\n      const precomputed = cachedPrecomputed.get(tileIndex)!;\r\n\r\n      // Back-face culling: skip tiles facing away from camera\r\n      if (cameraDir) {\r\n        const nc = precomputed.normalizedCenter;\r\n        const dot = nc.x * cameraDir.x + nc.y * cameraDir.y + nc.z * cameraDir.z;\r\n        if (dot < CULL_THRESHOLD) continue;\r\n      }\r\n\r\n      const info = tileInfo.get(tileIndex);\r\n      if (!info || !info.isWater) continue;\r\n      const normalizedVerts = precomputed.normalizedVertices;\r\n      const edgeNeighborIdx = precomputed.edgeNeighborIdx;\r\n      const numSides = normalizedVerts.length;\r\n\r\n      const chunkIdx = tileToChunkMap.get(tileIndex) ?? 0;\r\n      const chunk = chunkGeometries[chunkIdx];\r\n\r\n      for (let i = 0; i < numSides; i++) {\r\n        const neighborTileIdx = edgeNeighborIdx[i];\r\n        if (neighborTileIdx < 0) continue;\r\n        if (!nearbyTilesSet.has(neighborTileIdx)) continue;\r\n\r\n        const neighborInfo = tileInfo.get(neighborTileIdx);\r\n        if (!neighborInfo) continue;\r\n\r\n        // Use terrainRadius (solid ground) not radius (which could be water surface)\r\n        const bottomRadius = neighborInfo.terrainRadius;\r\n        const topRadius = waterRadius;\r\n        if (bottomRadius >= topRadius) continue;\r\n\r\n        const next = (i + 1) % numSides;\r\n        const nv1 = normalizedVerts[i];\r\n        const nv2 = normalizedVerts[next];\r\n\r\n        const innerV1x = nv1.x * bottomRadius, innerV1y = nv1.y * bottomRadius, innerV1z = nv1.z * bottomRadius;\r\n        const innerV2x = nv2.x * bottomRadius, innerV2y = nv2.y * bottomRadius, innerV2z = nv2.z * bottomRadius;\r\n        const outerV1x = nv1.x * topRadius, outerV1y = nv1.y * topRadius, outerV1z = nv1.z * topRadius;\r\n        const outerV2x = nv2.x * topRadius, outerV2y = nv2.y * topRadius, outerV2z = nv2.z * topRadius;\r\n\r\n        const edge1x = innerV2x - innerV1x, edge1y = innerV2y - innerV1y, edge1z = innerV2z - innerV1z;\r\n        const edge2x = outerV1x - innerV1x, edge2y = outerV1y - innerV1y, edge2z = outerV1z - innerV1z;\r\n        const crossX = edge1y * edge2z - edge1z * edge2y;\r\n        const crossY = edge1z * edge2x - edge1x * edge2z;\r\n        const crossZ = edge1x * edge2y - edge1y * edge2x;\r\n        const crossLen = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);\r\n        const snx = crossLen > 0 ? crossX / crossLen : 0;\r\n        const sny = crossLen > 0 ? crossY / crossLen : 0;\r\n        const snz = crossLen > 0 ? crossZ / crossLen : 0;\r\n\r\n        const baseIdx = chunk.waterSideVertexOffset;\r\n\r\n        chunk.waterSidePositions.push(\r\n          innerV1x, innerV1y, innerV1z,\r\n          innerV2x, innerV2y, innerV2z,\r\n          outerV2x, outerV2y, outerV2z,\r\n          outerV1x, outerV1y, outerV1z\r\n        );\r\n\r\n        chunk.waterSideNormals.push(snx, sny, snz, snx, sny, snz, snx, sny, snz, snx, sny, snz);\r\n        chunk.waterSideUvs.push(0, 0, 1, 0, 1, 1, 0, 1);\r\n\r\n        chunk.waterSideIndices.push(baseIdx, baseIdx + 1, baseIdx + 2);\r\n        chunk.waterSideIndices.push(baseIdx, baseIdx + 2, baseIdx + 3);\r\n\r\n        chunk.waterSideVertexOffset += 4;\r\n      }\r\n    }\r\n\r\n    const result: LODGeometryResultMessage = {\r\n      type: 'lodGeometryResult',\r\n      chunkGeometries\r\n    };\r\n\r\n    self.postMessage(result);\r\n  }\r\n};\r\n\r\nexport {};\r\n"],"names":["createEmptyChunkGeometry","HexBlockType","depthToRadius","depth","config","getSeaLevelDepth","cachedPrecomputed","cachedTileCount","e","type","tileData","blockData","nearbyTiles","tileToChunk","nearbyTilesSet","tileToChunkMap","k","v","columnsMap","tileIndexStr","tile","tileIndex","blocks","tileCount","column","numVerts","centerLen","normalizedCenter","normalizedVertices","vLen","edgeMidDirs","next","v1","v2","midX","midY","midZ","midLen","edgeNeighborIdx","edgeMidDir","closestNeighbor","closestDist","nIdx","neighborColumn","nc","ncLen","ncNormX","ncNormY","ncNormZ","dx","dy","dz","dist","up","tangentX","tangentY","tangentZ","tangentLen","tangent","bitangentX","bitangentY","bitangentZ","bitangent","localCoords","minU","maxU","minV","maxV","vert","toVertX","toVertY","toVertZ","u","rangeU","rangeV","normalizedUVs","coord","centerUV","chunkGeometries","i","seaLevelDepth","waterRadius","tileInfo","surfaceDepth","surfaceBlockType","terrainDepth","d","isWater","displayRadius","terrainRadius","cameraDir","CULL_THRESHOLD","precomputed","info","chunkIdx","chunk","positions","normals","uvs","skyLight","indices","vertexOffset","normal","normalizedVerts","centerIdx","nv","thisRadius","thisIsWater","numSides","neighborTileIdx","neighborInfo","neighborRadius","nv1","nv2","innerV1x","innerV1y","innerV1z","innerV2x","innerV2y","innerV2z","outerV1x","outerV1y","outerV1z","outerV2x","outerV2y","outerV2z","edge1x","edge1y","edge1z","edge2x","edge2y","edge2z","crossX","crossY","crossZ","crossLen","snx","sny","snz","baseIdx","bottomRadius","topRadius","result"],"mappings":"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"}