{"version":3,"file":"lodGeometryWorker-CIUgOB9L.js","sources":["../src/workers/lodGeometryWorker.ts"],"sourcesContent":["// LOD Geometry Worker - builds LOD terrain geometry off the main thread\r\n// Optimized: pre-computed normalizations, cached surface data, reduced passes\r\n\r\n// Vector3-like operations using plain objects\r\ninterface Vec3 {\r\n  x: number;\r\n  y: number;\r\n  z: number;\r\n}\r\n\r\n// Note: Vector operations are inlined in hot loops to avoid function call overhead\r\n// and object allocations. The raw x/y/z math is faster than helper functions.\r\n\r\n// Per-chunk geometry buffers\r\ninterface ChunkGeometry {\r\n  grassPositions: number[];\r\n  grassNormals: number[];\r\n  grassUvs: number[];\r\n  grassSkyLight: number[];  // Sky light attribute for terrain shader\r\n  grassIndices: number[];\r\n  grassVertexOffset: number;\r\n  dirtPositions: number[];\r\n  dirtNormals: number[];\r\n  dirtUvs: number[];\r\n  dirtSkyLight: number[];\r\n  dirtIndices: number[];\r\n  dirtVertexOffset: number;\r\n  waterPositions: number[];\r\n  waterNormals: number[];\r\n  waterUvs: number[];\r\n  waterIndices: number[];\r\n  waterVertexOffset: number;\r\n  sidePositions: number[];\r\n  sideNormals: number[];\r\n  sideUvs: number[];\r\n  sideSkyLight: number[];\r\n  sideIndices: number[];\r\n  sideVertexOffset: number;\r\n  waterSidePositions: number[];\r\n  waterSideNormals: number[];\r\n  waterSideUvs: number[];\r\n  waterSideIndices: number[];\r\n  waterSideVertexOffset: number;\r\n}\r\n\r\nfunction createEmptyChunkGeometry(): ChunkGeometry {\r\n  return {\r\n    grassPositions: [], grassNormals: [], grassUvs: [], grassSkyLight: [], grassIndices: [], grassVertexOffset: 0,\r\n    dirtPositions: [], dirtNormals: [], dirtUvs: [], dirtSkyLight: [], dirtIndices: [], dirtVertexOffset: 0,\r\n    waterPositions: [], waterNormals: [], waterUvs: [], waterIndices: [], waterVertexOffset: 0,\r\n    sidePositions: [], sideNormals: [], sideUvs: [], sideSkyLight: [], sideIndices: [], sideVertexOffset: 0,\r\n    waterSidePositions: [], waterSideNormals: [], waterSideUvs: [], waterSideIndices: [], waterSideVertexOffset: 0\r\n  };\r\n}\r\n\r\n// Tile data passed from main thread\r\ninterface TileData {\r\n  index: number;\r\n  vertices: Vec3[];\r\n  center: Vec3;\r\n  neighbors: number[];\r\n}\r\n\r\n// Column data passed from main thread\r\ninterface ColumnData {\r\n  tileIndex: number;\r\n  tile: TileData;\r\n  blocks: number[];\r\n}\r\n\r\n// Pre-computed tile data for fast access\r\ninterface PrecomputedTileData {\r\n  normalizedCenter: Vec3;\r\n  normalizedVertices: Vec3[];\r\n  // Edge midpoint normalized directions (for neighbor lookup)\r\n  edgeMidDirs: Vec3[];\r\n  // Which neighbor is across each edge (index into neighbors array, -1 if none found)\r\n  edgeNeighborIdx: number[];\r\n  // Pre-computed normalized UVs for each vertex (0-1 range, touching edges)\r\n  normalizedUVs: { u: number; v: number }[];\r\n  // Center UV (where the face center maps to in UV space)\r\n  centerUV: { u: number; v: number };\r\n}\r\n\r\n// Block types (must match HexBlock.ts)\r\nconst HexBlockType = {\r\n  AIR: 0,\r\n  STONE: 1,\r\n  DIRT: 2,\r\n  GRASS: 3,\r\n  WATER: 4,\r\n  SAND: 5,\r\n  WOOD: 6,\r\n  LEAVES: 7\r\n};\r\n\r\n// Config passed from main thread\r\ninterface LODWorkerConfig {\r\n  radius: number;\r\n  blockHeight: number;\r\n  seaLevel: number;\r\n  waterSurfaceOffset: number;\r\n  lodOffset: number;\r\n  chunkCount: number;\r\n  // Camera direction from planet center for back-face culling\r\n  cameraDir?: Vec3;\r\n}\r\n\r\n// Message types\r\ninterface BuildLODGeometryMessage {\r\n  type: 'buildLODGeometry';\r\n  tileData: Record<number, TileData>;\r\n  blockData: Record<number, number[]>;\r\n  nearbyTiles: number[];\r\n  tileToChunk: Record<number, number>;\r\n  config: LODWorkerConfig;\r\n}\r\n\r\ninterface LODGeometryResultMessage {\r\n  type: 'lodGeometryResult';\r\n  chunkGeometries: ChunkGeometry[];\r\n}\r\n\r\n// Cached pre-computed data (persists across messages for same tile structure)\r\nlet cachedPrecomputed: Map<number, PrecomputedTileData> | null = null;\r\nlet cachedTileCount = 0;\r\n\r\n// Worker message handler\r\nself.onmessage = (e: MessageEvent<BuildLODGeometryMessage>) => {\r\n  const { type, tileData, blockData, nearbyTiles, tileToChunk, config } = e.data;\r\n\r\n  if (type === 'buildLODGeometry') {\r\n    const nearbyTilesSet = new Set(nearbyTiles);\r\n    const tileToChunkMap = new Map(Object.entries(tileToChunk).map(([k, v]) => [parseInt(k), v]));\r\n\r\n    // Reconstruct columns from separate tile and block data\r\n    const columnsMap = new Map<number, ColumnData>();\r\n    for (const [tileIndexStr, tile] of Object.entries(tileData)) {\r\n      const tileIndex = parseInt(tileIndexStr);\r\n      const blocks = blockData[tileIndex];\r\n      if (blocks) {\r\n        columnsMap.set(tileIndex, { tileIndex, tile, blocks });\r\n      }\r\n    }\r\n\r\n    // Pre-compute normalized data if not cached or tile count changed\r\n    const tileCount = Object.keys(tileData).length;\r\n    if (!cachedPrecomputed || cachedTileCount !== tileCount) {\r\n      cachedPrecomputed = new Map();\r\n      cachedTileCount = tileCount;\r\n\r\n      for (const [tileIndex, column] of columnsMap) {\r\n        const tile = column.tile;\r\n        const numVerts = tile.vertices.length;\r\n\r\n        // Normalize center once\r\n        const centerLen = Math.sqrt(tile.center.x * tile.center.x + tile.center.y * tile.center.y + tile.center.z * tile.center.z);\r\n        const normalizedCenter: Vec3 = centerLen > 0\r\n          ? { x: tile.center.x / centerLen, y: tile.center.y / centerLen, z: tile.center.z / centerLen }\r\n          : { x: 0, y: 0, z: 0 };\r\n\r\n        // Normalize all vertices once\r\n        const normalizedVertices: Vec3[] = [];\r\n        for (const v of tile.vertices) {\r\n          const vLen = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\r\n          normalizedVertices.push(vLen > 0\r\n            ? { x: v.x / vLen, y: v.y / vLen, z: v.z / vLen }\r\n            : { x: 0, y: 0, z: 0 });\r\n        }\r\n\r\n        // Pre-compute edge midpoint directions\r\n        const edgeMidDirs: Vec3[] = [];\r\n        for (let i = 0; i < numVerts; i++) {\r\n          const next = (i + 1) % numVerts;\r\n          const v1 = tile.vertices[i];\r\n          const v2 = tile.vertices[next];\r\n          const midX = v1.x + v2.x;\r\n          const midY = v1.y + v2.y;\r\n          const midZ = v1.z + v2.z;\r\n          const midLen = Math.sqrt(midX * midX + midY * midY + midZ * midZ);\r\n          edgeMidDirs.push(midLen > 0\r\n            ? { x: midX / midLen, y: midY / midLen, z: midZ / midLen }\r\n            : { x: 0, y: 0, z: 0 });\r\n        }\r\n\r\n        // Pre-compute which neighbor is across each edge\r\n        const edgeNeighborIdx: number[] = [];\r\n        for (let i = 0; i < numVerts; i++) {\r\n          const edgeMidDir = edgeMidDirs[i];\r\n          let closestNeighbor = -1;\r\n          let closestDist = Infinity;\r\n\r\n          for (const nIdx of tile.neighbors) {\r\n            const neighborColumn = columnsMap.get(nIdx);\r\n            if (!neighborColumn) continue;\r\n\r\n            const nc = neighborColumn.tile.center;\r\n            const ncLen = Math.sqrt(nc.x * nc.x + nc.y * nc.y + nc.z * nc.z);\r\n            if (ncLen === 0) continue;\r\n\r\n            const ncNormX = nc.x / ncLen;\r\n            const ncNormY = nc.y / ncLen;\r\n            const ncNormZ = nc.z / ncLen;\r\n\r\n            const dx = ncNormX - edgeMidDir.x;\r\n            const dy = ncNormY - edgeMidDir.y;\r\n            const dz = ncNormZ - edgeMidDir.z;\r\n            const dist = dx * dx + dy * dy + dz * dz;\r\n\r\n            if (dist < closestDist) {\r\n              closestDist = dist;\r\n              closestNeighbor = nIdx;\r\n            }\r\n          }\r\n          edgeNeighborIdx.push(closestNeighbor);\r\n        }\r\n\r\n        // Pre-compute local coordinate system for UV mapping\r\n        // Create tangent and bitangent vectors perpendicular to the normal\r\n        const up: Vec3 = Math.abs(normalizedCenter.y) < 0.9\r\n          ? { x: 0, y: 1, z: 0 }\r\n          : { x: 1, y: 0, z: 0 };\r\n\r\n        // tangent = cross(up, normal)\r\n        const tangentX = up.y * normalizedCenter.z - up.z * normalizedCenter.y;\r\n        const tangentY = up.z * normalizedCenter.x - up.x * normalizedCenter.z;\r\n        const tangentZ = up.x * normalizedCenter.y - up.y * normalizedCenter.x;\r\n        const tangentLen = Math.sqrt(tangentX * tangentX + tangentY * tangentY + tangentZ * tangentZ);\r\n        const tangent: Vec3 = tangentLen > 0\r\n          ? { x: tangentX / tangentLen, y: tangentY / tangentLen, z: tangentZ / tangentLen }\r\n          : { x: 1, y: 0, z: 0 };\r\n\r\n        // bitangent = cross(normal, tangent)\r\n        const bitangentX = normalizedCenter.y * tangent.z - normalizedCenter.z * tangent.y;\r\n        const bitangentY = normalizedCenter.z * tangent.x - normalizedCenter.x * tangent.z;\r\n        const bitangentZ = normalizedCenter.x * tangent.y - normalizedCenter.y * tangent.x;\r\n        const bitangent: Vec3 = { x: bitangentX, y: bitangentY, z: bitangentZ };\r\n\r\n        // Project vertices onto local 2D plane and find bounding box\r\n        const localCoords: { u: number; v: number }[] = [];\r\n        let minU = Infinity, maxU = -Infinity, minV = Infinity, maxV = -Infinity;\r\n\r\n        for (const vert of tile.vertices) {\r\n          // Vector from center to vertex\r\n          const toVertX = vert.x - tile.center.x;\r\n          const toVertY = vert.y - tile.center.y;\r\n          const toVertZ = vert.z - tile.center.z;\r\n\r\n          // Project onto tangent and bitangent\r\n          const u = toVertX * tangent.x + toVertY * tangent.y + toVertZ * tangent.z;\r\n          const v = toVertX * bitangent.x + toVertY * bitangent.y + toVertZ * bitangent.z;\r\n          localCoords.push({ u, v });\r\n\r\n          minU = Math.min(minU, u);\r\n          maxU = Math.max(maxU, u);\r\n          minV = Math.min(minV, v);\r\n          maxV = Math.max(maxV, v);\r\n        }\r\n\r\n        // Normalize UVs to 0-1 range\r\n        const rangeU = maxU - minU;\r\n        const rangeV = maxV - minV;\r\n        const normalizedUVs: { u: number; v: number }[] = localCoords.map(coord => ({\r\n          u: (coord.u - minU) / rangeU,\r\n          v: (coord.v - minV) / rangeV\r\n        }));\r\n\r\n        // Center UV (the center vertex at (0,0) in local coords maps to this UV)\r\n        const centerUV = {\r\n          u: (0 - minU) / rangeU,\r\n          v: (0 - minV) / rangeV\r\n        };\r\n\r\n        cachedPrecomputed.set(tileIndex, {\r\n          normalizedCenter,\r\n          normalizedVertices,\r\n          edgeMidDirs,\r\n          edgeNeighborIdx,\r\n          normalizedUVs,\r\n          centerUV\r\n        });\r\n      }\r\n    }\r\n\r\n    const chunkGeometries: ChunkGeometry[] = [];\r\n    for (let i = 0; i < config.chunkCount; i++) {\r\n      chunkGeometries.push(createEmptyChunkGeometry());\r\n    }\r\n\r\n    const waterRadius = config.radius - config.seaLevel * config.blockHeight - config.lodOffset;\r\n\r\n    // Combined first pass: calculate display radius AND surface block type for each tile\r\n    // This eliminates redundant block array searches\r\n    interface TileInfo {\r\n      radius: number;\r\n      isWater: boolean;\r\n      surfaceBlockType: number;\r\n    }\r\n    const tileInfo = new Map<number, TileInfo>();\r\n\r\n    for (const [tileIndex, column] of columnsMap) {\r\n      let surfaceDepth = 0;\r\n      let surfaceBlockType = HexBlockType.GRASS;\r\n      const blocks = column.blocks;\r\n      for (let d = 0; d < blocks.length; d++) {\r\n        if (blocks[d] !== HexBlockType.AIR) {\r\n          surfaceDepth = d;\r\n          surfaceBlockType = blocks[d];\r\n          break;\r\n        }\r\n      }\r\n\r\n      const isWater = surfaceBlockType === HexBlockType.WATER;\r\n      const displayRadius = isWater\r\n        ? waterRadius\r\n        : config.radius - surfaceDepth * config.blockHeight - config.lodOffset;\r\n\r\n      tileInfo.set(tileIndex, { radius: displayRadius, isWater, surfaceBlockType });\r\n    }\r\n\r\n    // Back-face culling threshold: skip tiles facing away from camera\r\n    // Use -0.2 to include tiles slightly past the horizon (for smooth edges)\r\n    const cameraDir = config.cameraDir;\r\n    const CULL_THRESHOLD = -0.2;\r\n\r\n    // Second pass: build top faces for LOD tiles (uses cached data)\r\n    for (const [tileIndex] of columnsMap) {\r\n      if (nearbyTilesSet.has(tileIndex)) continue;\r\n\r\n      const precomputed = cachedPrecomputed.get(tileIndex)!;\r\n\r\n      // Back-face culling: skip tiles facing away from camera\r\n      if (cameraDir) {\r\n        const nc = precomputed.normalizedCenter;\r\n        const dot = nc.x * cameraDir.x + nc.y * cameraDir.y + nc.z * cameraDir.z;\r\n        if (dot < CULL_THRESHOLD) continue;\r\n      }\r\n\r\n      const info = tileInfo.get(tileIndex)!\r\n      const displayRadius = info.radius;\r\n      const surfaceBlockType = info.surfaceBlockType;\r\n\r\n      const chunkIdx = tileToChunkMap.get(tileIndex) ?? 0;\r\n      const chunk = chunkGeometries[chunkIdx];\r\n\r\n      // Select buffer based on surface type\r\n      let positions: number[], normals: number[], uvs: number[], skyLight: number[] | null, indices: number[];\r\n      let vertexOffset: number;\r\n\r\n      if (surfaceBlockType === HexBlockType.WATER) {\r\n        positions = chunk.waterPositions;\r\n        normals = chunk.waterNormals;\r\n        uvs = chunk.waterUvs;\r\n        skyLight = null; // Water uses different shader, doesn't need skyLight\r\n        indices = chunk.waterIndices;\r\n        vertexOffset = chunk.waterVertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.DIRT) {\r\n        positions = chunk.dirtPositions;\r\n        normals = chunk.dirtNormals;\r\n        uvs = chunk.dirtUvs;\r\n        skyLight = chunk.dirtSkyLight;\r\n        indices = chunk.dirtIndices;\r\n        vertexOffset = chunk.dirtVertexOffset;\r\n      } else {\r\n        positions = chunk.grassPositions;\r\n        normals = chunk.grassNormals;\r\n        uvs = chunk.grassUvs;\r\n        skyLight = chunk.grassSkyLight;\r\n        indices = chunk.grassIndices;\r\n        vertexOffset = chunk.grassVertexOffset;\r\n      }\r\n\r\n      // Use pre-computed normalized center, vertices, and UVs\r\n      const normal = precomputed.normalizedCenter;\r\n      const normalizedVerts = precomputed.normalizedVertices;\r\n      const normalizedUVs = precomputed.normalizedUVs;\r\n      const centerUV = precomputed.centerUV;\r\n\r\n      // Fan triangulation from center\r\n      const centerIdx = vertexOffset;\r\n      positions.push(\r\n        normal.x * displayRadius,\r\n        normal.y * displayRadius,\r\n        normal.z * displayRadius\r\n      );\r\n      normals.push(normal.x, normal.y, normal.z);\r\n      uvs.push(centerUV.u, centerUV.v);\r\n      if (skyLight) skyLight.push(1.0); // LOD terrain is always at surface, full sky exposure\r\n      vertexOffset++;\r\n\r\n      for (let i = 0; i < normalizedVerts.length; i++) {\r\n        const nv = normalizedVerts[i];\r\n        positions.push(nv.x * displayRadius, nv.y * displayRadius, nv.z * displayRadius);\r\n        normals.push(normal.x, normal.y, normal.z);\r\n        uvs.push(normalizedUVs[i].u, normalizedUVs[i].v);\r\n        if (skyLight) skyLight.push(1.0);\r\n        vertexOffset++;\r\n\r\n        indices.push(centerIdx, centerIdx + 1 + i, centerIdx + 1 + ((i + 1) % normalizedVerts.length));\r\n      }\r\n\r\n      // Update offset\r\n      if (surfaceBlockType === HexBlockType.WATER) {\r\n        chunk.waterVertexOffset = vertexOffset;\r\n      } else if (surfaceBlockType === HexBlockType.DIRT) {\r\n        chunk.dirtVertexOffset = vertexOffset;\r\n      } else {\r\n        chunk.grassVertexOffset = vertexOffset;\r\n      }\r\n    }\r\n\r\n    // Third pass: generate side walls (uses cached edge-neighbor mapping)\r\n    for (const [tileIndex] of columnsMap) {\r\n      if (nearbyTilesSet.has(tileIndex)) continue;\r\n\r\n      const precomputed = cachedPrecomputed.get(tileIndex)!;\r\n\r\n      // Back-face culling: skip tiles facing away from camera\r\n      if (cameraDir) {\r\n        const nc = precomputed.normalizedCenter;\r\n        const dot = nc.x * cameraDir.x + nc.y * cameraDir.y + nc.z * cameraDir.z;\r\n        if (dot < CULL_THRESHOLD) continue;\r\n      }\r\n\r\n      const info = tileInfo.get(tileIndex)!\r\n      const thisRadius = info.radius;\r\n      const thisIsWater = info.isWater;\r\n      const normalizedVerts = precomputed.normalizedVertices;\r\n      const edgeNeighborIdx = precomputed.edgeNeighborIdx;\r\n      const numSides = normalizedVerts.length;\r\n\r\n      const chunkIdx = tileToChunkMap.get(tileIndex) ?? 0;\r\n      const chunk = chunkGeometries[chunkIdx];\r\n\r\n      for (let i = 0; i < numSides; i++) {\r\n        const neighborTileIdx = edgeNeighborIdx[i];\r\n        if (neighborTileIdx < 0) continue;\r\n\r\n        const neighborInfo = tileInfo.get(neighborTileIdx);\r\n        if (!neighborInfo) continue;\r\n\r\n        const neighborRadius = neighborInfo.radius;\r\n        const neighborIsWater = neighborInfo.isWater;\r\n\r\n        const needsWall = thisRadius > neighborRadius || (thisIsWater && !neighborIsWater);\r\n        if (!needsWall) continue;\r\n\r\n        const next = (i + 1) % numSides;\r\n        const nv1 = normalizedVerts[i];\r\n        const nv2 = normalizedVerts[next];\r\n\r\n        // Create wall vertices using pre-normalized directions\r\n        const innerV1x = nv1.x * neighborRadius, innerV1y = nv1.y * neighborRadius, innerV1z = nv1.z * neighborRadius;\r\n        const innerV2x = nv2.x * neighborRadius, innerV2y = nv2.y * neighborRadius, innerV2z = nv2.z * neighborRadius;\r\n        const outerV1x = nv1.x * thisRadius, outerV1y = nv1.y * thisRadius, outerV1z = nv1.z * thisRadius;\r\n        const outerV2x = nv2.x * thisRadius, outerV2y = nv2.y * thisRadius, outerV2z = nv2.z * thisRadius;\r\n\r\n        // Calculate side normal\r\n        const edge1x = innerV2x - innerV1x, edge1y = innerV2y - innerV1y, edge1z = innerV2z - innerV1z;\r\n        const edge2x = outerV1x - innerV1x, edge2y = outerV1y - innerV1y, edge2z = outerV1z - innerV1z;\r\n        const crossX = edge1y * edge2z - edge1z * edge2y;\r\n        const crossY = edge1z * edge2x - edge1x * edge2z;\r\n        const crossZ = edge1x * edge2y - edge1y * edge2x;\r\n        const crossLen = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);\r\n        const snx = crossLen > 0 ? crossX / crossLen : 0;\r\n        const sny = crossLen > 0 ? crossY / crossLen : 0;\r\n        const snz = crossLen > 0 ? crossZ / crossLen : 0;\r\n\r\n        const positions = thisIsWater ? chunk.waterSidePositions : chunk.sidePositions;\r\n        const normals = thisIsWater ? chunk.waterSideNormals : chunk.sideNormals;\r\n        const uvs = thisIsWater ? chunk.waterSideUvs : chunk.sideUvs;\r\n        const skyLight = thisIsWater ? null : chunk.sideSkyLight;\r\n        const indices = thisIsWater ? chunk.waterSideIndices : chunk.sideIndices;\r\n        const baseIdx = thisIsWater ? chunk.waterSideVertexOffset : chunk.sideVertexOffset;\r\n\r\n        positions.push(\r\n          innerV1x, innerV1y, innerV1z,\r\n          innerV2x, innerV2y, innerV2z,\r\n          outerV2x, outerV2y, outerV2z,\r\n          outerV1x, outerV1y, outerV1z\r\n        );\r\n\r\n        normals.push(snx, sny, snz, snx, sny, snz, snx, sny, snz, snx, sny, snz);\r\n        uvs.push(0, 0, 1, 0, 1, 1, 0, 1);\r\n        if (skyLight) skyLight.push(1.0, 1.0, 1.0, 1.0); // Full sky exposure for LOD\r\n\r\n        indices.push(baseIdx, baseIdx + 1, baseIdx + 2);\r\n        indices.push(baseIdx, baseIdx + 2, baseIdx + 3);\r\n\r\n        if (thisIsWater) {\r\n          chunk.waterSideVertexOffset += 4;\r\n        } else {\r\n          chunk.sideVertexOffset += 4;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fourth pass: water boundary walls at LOD/terrain edge\r\n    for (const [tileIndex] of columnsMap) {\r\n      if (nearbyTilesSet.has(tileIndex)) continue;\r\n\r\n      const precomputed = cachedPrecomputed.get(tileIndex)!;\r\n\r\n      // Back-face culling: skip tiles facing away from camera\r\n      if (cameraDir) {\r\n        const nc = precomputed.normalizedCenter;\r\n        const dot = nc.x * cameraDir.x + nc.y * cameraDir.y + nc.z * cameraDir.z;\r\n        if (dot < CULL_THRESHOLD) continue;\r\n      }\r\n\r\n      const info = tileInfo.get(tileIndex);\r\n      if (!info || !info.isWater) continue;\r\n      const normalizedVerts = precomputed.normalizedVertices;\r\n      const edgeNeighborIdx = precomputed.edgeNeighborIdx;\r\n      const numSides = normalizedVerts.length;\r\n\r\n      const chunkIdx = tileToChunkMap.get(tileIndex) ?? 0;\r\n      const chunk = chunkGeometries[chunkIdx];\r\n\r\n      for (let i = 0; i < numSides; i++) {\r\n        const neighborTileIdx = edgeNeighborIdx[i];\r\n        if (neighborTileIdx < 0) continue;\r\n        if (!nearbyTilesSet.has(neighborTileIdx)) continue;\r\n\r\n        const neighborInfo = tileInfo.get(neighborTileIdx);\r\n        if (!neighborInfo) continue;\r\n\r\n        const bottomRadius = neighborInfo.radius;\r\n        const topRadius = waterRadius;\r\n        if (bottomRadius >= topRadius) continue;\r\n\r\n        const next = (i + 1) % numSides;\r\n        const nv1 = normalizedVerts[i];\r\n        const nv2 = normalizedVerts[next];\r\n\r\n        const innerV1x = nv1.x * bottomRadius, innerV1y = nv1.y * bottomRadius, innerV1z = nv1.z * bottomRadius;\r\n        const innerV2x = nv2.x * bottomRadius, innerV2y = nv2.y * bottomRadius, innerV2z = nv2.z * bottomRadius;\r\n        const outerV1x = nv1.x * topRadius, outerV1y = nv1.y * topRadius, outerV1z = nv1.z * topRadius;\r\n        const outerV2x = nv2.x * topRadius, outerV2y = nv2.y * topRadius, outerV2z = nv2.z * topRadius;\r\n\r\n        const edge1x = innerV2x - innerV1x, edge1y = innerV2y - innerV1y, edge1z = innerV2z - innerV1z;\r\n        const edge2x = outerV1x - innerV1x, edge2y = outerV1y - innerV1y, edge2z = outerV1z - innerV1z;\r\n        const crossX = edge1y * edge2z - edge1z * edge2y;\r\n        const crossY = edge1z * edge2x - edge1x * edge2z;\r\n        const crossZ = edge1x * edge2y - edge1y * edge2x;\r\n        const crossLen = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);\r\n        const snx = crossLen > 0 ? crossX / crossLen : 0;\r\n        const sny = crossLen > 0 ? crossY / crossLen : 0;\r\n        const snz = crossLen > 0 ? crossZ / crossLen : 0;\r\n\r\n        const baseIdx = chunk.waterSideVertexOffset;\r\n\r\n        chunk.waterSidePositions.push(\r\n          innerV1x, innerV1y, innerV1z,\r\n          innerV2x, innerV2y, innerV2z,\r\n          outerV2x, outerV2y, outerV2z,\r\n          outerV1x, outerV1y, outerV1z\r\n        );\r\n\r\n        chunk.waterSideNormals.push(snx, sny, snz, snx, sny, snz, snx, sny, snz, snx, sny, snz);\r\n        chunk.waterSideUvs.push(0, 0, 1, 0, 1, 1, 0, 1);\r\n\r\n        chunk.waterSideIndices.push(baseIdx, baseIdx + 1, baseIdx + 2);\r\n        chunk.waterSideIndices.push(baseIdx, baseIdx + 2, baseIdx + 3);\r\n\r\n        chunk.waterSideVertexOffset += 4;\r\n      }\r\n    }\r\n\r\n    const result: LODGeometryResultMessage = {\r\n      type: 'lodGeometryResult',\r\n      chunkGeometries\r\n    };\r\n\r\n    self.postMessage(result);\r\n  }\r\n};\r\n\r\nexport {};\r\n"],"names":["createEmptyChunkGeometry","HexBlockType","cachedPrecomputed","cachedTileCount","e","type","tileData","blockData","nearbyTiles","tileToChunk","config","nearbyTilesSet","tileToChunkMap","k","v","columnsMap","tileIndexStr","tile","tileIndex","blocks","tileCount","column","numVerts","centerLen","normalizedCenter","normalizedVertices","vLen","edgeMidDirs","i","next","v1","v2","midX","midY","midZ","midLen","edgeNeighborIdx","edgeMidDir","closestNeighbor","closestDist","nIdx","neighborColumn","nc","ncLen","ncNormX","ncNormY","ncNormZ","dx","dy","dz","dist","up","tangentX","tangentY","tangentZ","tangentLen","tangent","bitangentX","bitangentY","bitangentZ","bitangent","localCoords","minU","maxU","minV","maxV","vert","toVertX","toVertY","toVertZ","u","rangeU","rangeV","normalizedUVs","coord","centerUV","chunkGeometries","waterRadius","tileInfo","surfaceDepth","surfaceBlockType","d","isWater","displayRadius","cameraDir","CULL_THRESHOLD","precomputed","info","chunkIdx","chunk","positions","normals","uvs","skyLight","indices","vertexOffset","normal","normalizedVerts","centerIdx","nv","thisRadius","thisIsWater","numSides","neighborTileIdx","neighborInfo","neighborRadius","neighborIsWater","nv1","nv2","innerV1x","innerV1y","innerV1z","innerV2x","innerV2y","innerV2z","outerV1x","outerV1y","outerV1z","outerV2x","outerV2y","outerV2z","edge1x","edge1y","edge1z","edge2x","edge2y","edge2z","crossX","crossY","crossZ","crossLen","snx","sny","snz","baseIdx","bottomRadius","topRadius","result"],"mappings":"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"}