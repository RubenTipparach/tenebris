{"version":3,"file":"geometryWorker-CFUyd0hF.js","sources":["../src/shared/blockTypes.ts","../src/shared/vec3.ts","../src/shared/geometry.ts","../src/workers/geometryWorker.ts"],"sourcesContent":["// Shared block type definitions and helpers\r\n// This module is used by both main thread and web workers\r\n\r\nexport enum HexBlockType {\r\n  AIR = 0,\r\n  STONE = 1,\r\n  DIRT = 2,\r\n  GRASS = 3,\r\n  WATER = 4,\r\n  SAND = 5,\r\n  WOOD = 6,\r\n  LEAVES = 7,\r\n  // Mineral ores (underground)\r\n  ORE_COAL = 8,\r\n  ORE_COPPER = 9,\r\n  ORE_IRON = 10,\r\n  ORE_GOLD = 11,\r\n  ORE_LITHIUM = 12,\r\n  ORE_ALUMINUM = 13,\r\n  ORE_COBALT = 14\r\n}\r\n\r\nexport function isSolid(blockType: HexBlockType | number): boolean {\r\n  return blockType !== HexBlockType.AIR && blockType !== HexBlockType.WATER;\r\n}\r\n\r\nexport function isLiquid(blockType: HexBlockType | number): boolean {\r\n  return blockType === HexBlockType.WATER;\r\n}\r\n\r\nexport function isTransparent(blockType: HexBlockType | number): boolean {\r\n  return blockType === HexBlockType.AIR || blockType === HexBlockType.WATER;\r\n}\r\n","// Shared Vec3 math operations for use in web workers\r\n// These are pure functions that don't depend on THREE.js\r\n\r\nexport interface Vec3 {\r\n  x: number;\r\n  y: number;\r\n  z: number;\r\n}\r\n\r\nexport function vec3(x: number, y: number, z: number): Vec3 {\r\n  return { x, y, z };\r\n}\r\n\r\nexport function vec3Clone(v: Vec3): Vec3 {\r\n  return { x: v.x, y: v.y, z: v.z };\r\n}\r\n\r\nexport function vec3Add(a: Vec3, b: Vec3): Vec3 {\r\n  return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };\r\n}\r\n\r\nexport function vec3Sub(a: Vec3, b: Vec3): Vec3 {\r\n  return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };\r\n}\r\n\r\nexport function vec3Scale(v: Vec3, s: number): Vec3 {\r\n  return { x: v.x * s, y: v.y * s, z: v.z * s };\r\n}\r\n\r\nexport function vec3Dot(a: Vec3, b: Vec3): number {\r\n  return a.x * b.x + a.y * b.y + a.z * b.z;\r\n}\r\n\r\nexport function vec3Cross(a: Vec3, b: Vec3): Vec3 {\r\n  return {\r\n    x: a.y * b.z - a.z * b.y,\r\n    y: a.z * b.x - a.x * b.z,\r\n    z: a.x * b.y - a.y * b.x\r\n  };\r\n}\r\n\r\nexport function vec3Length(v: Vec3): number {\r\n  return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\r\n}\r\n\r\nexport function vec3LengthSquared(v: Vec3): number {\r\n  return v.x * v.x + v.y * v.y + v.z * v.z;\r\n}\r\n\r\nexport function vec3Normalize(v: Vec3): Vec3 {\r\n  const len = vec3Length(v);\r\n  if (len === 0) return { x: 0, y: 0, z: 0 };\r\n  return { x: v.x / len, y: v.y / len, z: v.z / len };\r\n}\r\n\r\nexport function vec3Negate(v: Vec3): Vec3 {\r\n  return { x: -v.x, y: -v.y, z: -v.z };\r\n}\r\n\r\nexport function vec3Distance(a: Vec3, b: Vec3): number {\r\n  return vec3Length(vec3Sub(a, b));\r\n}\r\n\r\nexport function vec3DistanceSquared(a: Vec3, b: Vec3): number {\r\n  return vec3LengthSquared(vec3Sub(a, b));\r\n}\r\n","// Shared geometry generation functions for use in web workers\r\n// Pure functions that don't depend on THREE.js\r\n\r\nimport { Vec3, vec3, vec3Add, vec3Sub, vec3Scale, vec3Dot, vec3Cross, vec3Normalize, vec3Negate, vec3Length, vec3Distance } from './vec3';\r\nimport { HexBlockType } from './blockTypes';\r\n\r\n// Tile data structure compatible with both main thread and workers\r\nexport interface TileVertexData {\r\n  index: number;\r\n  center: Vec3;\r\n  vertices: Vec3[];\r\n}\r\n\r\n// Raw geometry data before converting to typed arrays\r\nexport interface RawGeometry {\r\n  positions: number[];\r\n  normals: number[];\r\n  uvs: number[];\r\n  indices: number[];\r\n}\r\n\r\n// Geometry data with lighting info\r\nexport interface GeometryData {\r\n  positions: number[];\r\n  normals: number[];\r\n  uvs: number[];\r\n  colors: number[];\r\n  skyLight: number[];\r\n  indices: number[];\r\n  vertexOffset: number;\r\n}\r\n\r\nexport function createEmptyGeometryData(): GeometryData {\r\n  return { positions: [], normals: [], uvs: [], colors: [], skyLight: [], indices: [], vertexOffset: 0 };\r\n}\r\n\r\n// Sky light constants\r\nexport const SKY_LIGHT_FALLOFF = 0.8;\r\nexport const MIN_SKY_LIGHT = 0.05;\r\n\r\n// Calculate sky light level based on depth from surface\r\nexport function calculateSkyLight(depthFromSurface: number): number {\r\n  if (depthFromSurface <= 0) return 1.0;\r\n  return Math.max(MIN_SKY_LIGHT, Math.pow(SKY_LIGHT_FALLOFF, depthFromSurface));\r\n}\r\n\r\n// Pre-compute regular polygon UVs for hexagons/pentagons\r\nexport function computePolygonUVs(numSides: number, uvRadius: number = 0.5): { u: number; v: number }[] {\r\n  const uvs: { u: number; v: number }[] = [];\r\n  for (let i = 0; i < numSides; i++) {\r\n    const angle = (i / numSides) * Math.PI * 2 - Math.PI / 2; // Start from top\r\n    uvs.push({\r\n      u: 0.5 + Math.cos(angle) * uvRadius,\r\n      v: 0.5 + Math.sin(angle) * uvRadius\r\n    });\r\n  }\r\n  return uvs;\r\n}\r\n\r\n// Create local tangent space for a tile\r\nexport function createTangentSpace(radialDir: Vec3): { right: Vec3; forward: Vec3 } {\r\n  let localRight = vec3(1, 0, 0);\r\n  if (Math.abs(vec3Dot(radialDir, localRight)) > 0.9) {\r\n    localRight = vec3(0, 0, 1);\r\n  }\r\n  const localForward = vec3Normalize(vec3Cross(radialDir, localRight));\r\n  localRight = vec3Normalize(vec3Cross(localForward, radialDir));\r\n  return { right: localRight, forward: localForward };\r\n}\r\n\r\n// Scale tile vertices to specific radius\r\nexport function scaleVerticesToRadius(\r\n  vertices: Vec3[],\r\n  planetCenter: Vec3,\r\n  radius: number\r\n): Vec3[] {\r\n  return vertices.map(v => {\r\n    const dir = vec3Normalize(vec3Sub(v, planetCenter));\r\n    return vec3Scale(dir, radius);\r\n  });\r\n}\r\n\r\n// Create separate geometries for top, bottom, and sides of a hex prism\r\nexport function createSeparateGeometries(\r\n  tile: TileVertexData,\r\n  innerRadius: number,\r\n  outerRadius: number,\r\n  planetCenter: Vec3,\r\n  isTopExposed: boolean,\r\n  isBottomExposed: boolean,\r\n  areSidesExposed: boolean\r\n): { top: RawGeometry | null; bottom: RawGeometry | null; sides: RawGeometry | null } {\r\n  const numSides = tile.vertices.length;\r\n\r\n  // Calculate radial direction\r\n  const radialDir = vec3Normalize(vec3Sub(tile.center, planetCenter));\r\n\r\n  // Scale vertices to inner and outer radii\r\n  const innerVerts = scaleVerticesToRadius(tile.vertices, planetCenter, innerRadius);\r\n  const outerVerts = scaleVerticesToRadius(tile.vertices, planetCenter, outerRadius);\r\n\r\n  const innerCenter = vec3Scale(radialDir, innerRadius);\r\n  const outerCenter = vec3Scale(radialDir, outerRadius);\r\n\r\n  let topGeom: RawGeometry | null = null;\r\n  let bottomGeom: RawGeometry | null = null;\r\n  let sidesGeom: RawGeometry | null = null;\r\n\r\n  // Pre-compute regular polygon UVs\r\n  const tileUVs = computePolygonUVs(numSides);\r\n\r\n  // Top face\r\n  if (isTopExposed) {\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n    const indices: number[] = [];\r\n\r\n    positions.push(outerCenter.x, outerCenter.y, outerCenter.z);\r\n    normals.push(radialDir.x, radialDir.y, radialDir.z);\r\n    uvs.push(0.5, 0.5);\r\n\r\n    for (let i = 0; i < numSides; i++) {\r\n      const v = outerVerts[i];\r\n      positions.push(v.x, v.y, v.z);\r\n      normals.push(radialDir.x, radialDir.y, radialDir.z);\r\n      uvs.push(tileUVs[i].u, tileUVs[i].v);\r\n    }\r\n\r\n    for (let i = 0; i < numSides; i++) {\r\n      const next = (i + 1) % numSides;\r\n      indices.push(0, 1 + i, 1 + next);\r\n    }\r\n\r\n    topGeom = { positions, normals, uvs, indices };\r\n  }\r\n\r\n  // Bottom face\r\n  if (isBottomExposed) {\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n    const indices: number[] = [];\r\n\r\n    const bottomNormal = vec3Negate(radialDir);\r\n\r\n    positions.push(innerCenter.x, innerCenter.y, innerCenter.z);\r\n    normals.push(bottomNormal.x, bottomNormal.y, bottomNormal.z);\r\n    uvs.push(0.5, 0.5);\r\n\r\n    for (let i = 0; i < numSides; i++) {\r\n      const v = innerVerts[i];\r\n      positions.push(v.x, v.y, v.z);\r\n      normals.push(bottomNormal.x, bottomNormal.y, bottomNormal.z);\r\n      uvs.push(tileUVs[i].u, tileUVs[i].v);\r\n    }\r\n\r\n    for (let i = 0; i < numSides; i++) {\r\n      const next = (i + 1) % numSides;\r\n      indices.push(0, 1 + next, 1 + i);\r\n    }\r\n\r\n    bottomGeom = { positions, normals, uvs, indices };\r\n  }\r\n\r\n  // Side faces\r\n  if (areSidesExposed) {\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n    const indices: number[] = [];\r\n    let vertexIndex = 0;\r\n\r\n    for (let i = 0; i < numSides; i++) {\r\n      const next = (i + 1) % numSides;\r\n\r\n      const outerV1 = outerVerts[i];\r\n      const outerV2 = outerVerts[next];\r\n      const innerV1 = innerVerts[i];\r\n      const innerV2 = innerVerts[next];\r\n\r\n      // Calculate side normal\r\n      const edge = vec3Sub(outerV2, outerV1);\r\n      const edgeLen = vec3Length(edge);\r\n\r\n      const midPoint = vec3Scale(vec3Add(outerV1, outerV2), 0.5);\r\n      let sideNormal = vec3Normalize(vec3Sub(midPoint, planetCenter));\r\n\r\n      // Remove component parallel to edge to get perpendicular normal\r\n      const tangent = vec3Scale(edge, 1 / edgeLen);\r\n      const dot = vec3Dot(sideNormal, tangent);\r\n      sideNormal = vec3Normalize({\r\n        x: sideNormal.x - tangent.x * dot,\r\n        y: sideNormal.y - tangent.y * dot,\r\n        z: sideNormal.z - tangent.z * dot\r\n      });\r\n\r\n      positions.push(\r\n        innerV1.x, innerV1.y, innerV1.z,\r\n        innerV2.x, innerV2.y, innerV2.z,\r\n        outerV2.x, outerV2.y, outerV2.z,\r\n        outerV1.x, outerV1.y, outerV1.z\r\n      );\r\n\r\n      for (let j = 0; j < 4; j++) {\r\n        normals.push(sideNormal.x, sideNormal.y, sideNormal.z);\r\n      }\r\n\r\n      uvs.push(0, 0,\r\n         1, 0,\r\n         1, 1,\r\n         0, 1);\r\n\r\n      const baseIdx = vertexIndex;\r\n      indices.push(baseIdx, baseIdx + 1, baseIdx + 2, baseIdx, baseIdx + 2, baseIdx + 3);\r\n      vertexIndex += 4;\r\n    }\r\n\r\n    sidesGeom = { positions, normals, uvs, indices };\r\n  }\r\n\r\n  return { top: topGeom, bottom: bottomGeom, sides: sidesGeom };\r\n}\r\n\r\n// Merge raw geometry into target with sky light\r\nexport function mergeGeometry(\r\n  target: GeometryData,\r\n  source: RawGeometry,\r\n  skyLightLevel: number = 1.0\r\n): void {\r\n  const vertexCount = source.positions.length / 3;\r\n  const baseIndex = target.vertexOffset;\r\n\r\n  // Batch push arrays\r\n  target.positions.push(...source.positions);\r\n  target.normals.push(...source.normals);\r\n  target.uvs.push(...source.uvs);\r\n\r\n  // Add vertex colors (white, lighting handled in shader)\r\n  for (let i = 0; i < vertexCount; i++) {\r\n    target.colors.push(1, 1, 1);\r\n  }\r\n\r\n  // Add sky light for each vertex\r\n  for (let i = 0; i < vertexCount; i++) {\r\n    target.skyLight.push(skyLightLevel);\r\n  }\r\n\r\n  // Add indices with offset\r\n  for (const idx of source.indices) {\r\n    target.indices.push(idx + baseIndex);\r\n  }\r\n\r\n  target.vertexOffset += vertexCount;\r\n}\r\n\r\n// Water wall tile data for worker communication\r\nexport interface WaterWallTileData {\r\n  vertices: Vec3[];\r\n  neighbors: number[];\r\n}\r\n\r\n// Water wall configuration\r\nexport interface WaterWallConfig {\r\n  radius: number;\r\n  blockHeight: number;\r\n  maxDepth: number;\r\n  waterSurfaceOffset: number;\r\n}\r\n\r\n// Build water side faces that extend from water surface down to exposed air\r\n// This creates walls where water meets air gaps in neighboring columns\r\n// Pure function version for use in workers\r\nexport function buildWaterWallGeometry(\r\n  tileVertices: Vec3[],\r\n  tileNeighbors: number[],\r\n  ownBlocks: number[],\r\n  neighborBlocksMap: Map<number, { blocks: number[]; vertices: Vec3[] }>,\r\n  waterSurfaceDepth: number,\r\n  outerRadius: number,\r\n  config: WaterWallConfig,\r\n  waterData: GeometryData\r\n): void {\r\n  const numSides = tileVertices.length;\r\n  const edgeThreshold = 0.001;\r\n\r\n  // Check each edge\r\n  for (let i = 0; i < numSides; i++) {\r\n    const next = (i + 1) % numSides;\r\n    const edgeV1 = tileVertices[i];\r\n    const edgeV2 = tileVertices[next];\r\n\r\n    // Find which neighbor shares this edge\r\n    let neighborData: { blocks: number[]; vertices: Vec3[] } | undefined;\r\n    for (const neighborIndex of tileNeighbors) {\r\n      const candidate = neighborBlocksMap.get(neighborIndex);\r\n      if (!candidate) continue;\r\n\r\n      // Check if this neighbor has both edge vertices\r\n      let hasV1 = false;\r\n      let hasV2 = false;\r\n      for (const nv of candidate.vertices) {\r\n        if (vec3Distance(nv, edgeV1) < edgeThreshold) hasV1 = true;\r\n        if (vec3Distance(nv, edgeV2) < edgeThreshold) hasV2 = true;\r\n      }\r\n\r\n      if (hasV1 && hasV2) {\r\n        neighborData = candidate;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!neighborData) continue;\r\n\r\n    // Check if neighbor has air at water surface level - if not, skip this edge\r\n    if (neighborData.blocks[waterSurfaceDepth] !== HexBlockType.AIR) continue;\r\n\r\n    // Find where this water column has solid blocks below the water\r\n    // Depth system: 0 = bedrock (bottom), higher = toward sky\r\n    // Solid blocks (ocean floor) are at LOWER depth values than water\r\n    let ownSolidDepth = 0;\r\n    for (let d = waterSurfaceDepth - 1; d >= 0; d--) {\r\n      const ownBlock = ownBlocks[d];\r\n      if (ownBlock !== HexBlockType.AIR && ownBlock !== HexBlockType.WATER) {\r\n        ownSolidDepth = d;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Find the neighbor's first solid block depth (searching downward)\r\n    let neighborSolidDepth = 0;\r\n    for (let d = waterSurfaceDepth - 1; d >= 0; d--) {\r\n      const neighborBlock = neighborData.blocks[d];\r\n      if (neighborBlock !== HexBlockType.AIR && neighborBlock !== HexBlockType.WATER) {\r\n        neighborSolidDepth = d;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Water wall extends to the maximum of own solid depth or neighbor solid depth\r\n    // (higher depth = closer to water surface, so we take max to get the shallowest floor)\r\n    const wallBottomDepth = Math.max(ownSolidDepth, neighborSolidDepth);\r\n\r\n    // Calculate wall geometry\r\n    // Use correct depth formula: depthToRadius(d) = radius - (maxDepth - 1 - d) * blockHeight\r\n    const wallTopRadius = outerRadius;\r\n    const wallBottomRadius = config.radius - (config.maxDepth - 1 - wallBottomDepth) * config.blockHeight;\r\n\r\n    if (wallBottomRadius >= wallTopRadius) continue;\r\n\r\n    // Scale vertices for top and bottom of wall\r\n    const dir1 = vec3Normalize(edgeV1);\r\n    const dir2 = vec3Normalize(edgeV2);\r\n\r\n    const topV1 = vec3Scale(dir1, wallTopRadius);\r\n    const topV2 = vec3Scale(dir2, wallTopRadius);\r\n    const bottomV1 = vec3Scale(dir1, wallBottomRadius);\r\n    const bottomV2 = vec3Scale(dir2, wallBottomRadius);\r\n\r\n    // Calculate side normal\r\n    const edge1 = vec3Sub(bottomV2, bottomV1);\r\n    const edge2 = vec3Sub(topV1, bottomV1);\r\n    const sideNormal = vec3Normalize(vec3Cross(edge1, edge2));\r\n\r\n    const baseIdx = waterData.vertexOffset;\r\n\r\n    // Four vertices for this side face\r\n    waterData.positions.push(\r\n      bottomV1.x, bottomV1.y, bottomV1.z,\r\n      bottomV2.x, bottomV2.y, bottomV2.z,\r\n      topV2.x, topV2.y, topV2.z,\r\n      topV1.x, topV1.y, topV1.z\r\n    );\r\n\r\n    for (let j = 0; j < 4; j++) {\r\n      waterData.normals.push(sideNormal.x, sideNormal.y, sideNormal.z);\r\n    }\r\n\r\n    waterData.uvs.push(0, 0, 1, 0, 1, 1, 0, 1);\r\n    waterData.skyLight.push(1.0, 1.0, 1.0, 1.0);\r\n    waterData.colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n\r\n    waterData.indices.push(\r\n      baseIdx, baseIdx + 1, baseIdx + 2,\r\n      baseIdx, baseIdx + 2, baseIdx + 3\r\n    );\r\n\r\n    waterData.vertexOffset += 4;\r\n  }\r\n}\r\n\r\n","// Geometry Worker - builds terrain geometry off the main thread\r\n// Uses plain JavaScript math instead of THREE.js (not available in workers)\r\n\r\nimport { HexBlockType } from '../shared/blockTypes';\r\nimport {\r\n  Vec3,\r\n  vec3,\r\n  vec3Clone,\r\n  vec3Sub,\r\n  vec3Scale,\r\n  vec3Dot,\r\n  vec3Cross,\r\n  vec3Normalize,\r\n  vec3Negate\r\n} from '../shared/vec3';\r\nimport { SKY_LIGHT_FALLOFF, MIN_SKY_LIGHT, buildWaterWallGeometry } from '../shared/geometry';\r\n\r\n// Torch data for vertex lighting calculation\r\ninterface TorchData {\r\n  position: Vec3;\r\n  range: number;\r\n  intensity: number;\r\n}\r\n\r\n// Geometry data structure (matches Planet.ts)\r\ninterface GeometryData {\r\n  positions: number[];\r\n  normals: number[];\r\n  uvs: number[];\r\n  colors: number[];\r\n  skyLight: number[];\r\n  torchLight: number[];  // Baked torch light level per vertex\r\n  indices: number[];\r\n  vertexOffset: number;\r\n}\r\n\r\nfunction createEmptyGeometryData(): GeometryData {\r\n  return { positions: [], normals: [], uvs: [], colors: [], skyLight: [], torchLight: [], indices: [], vertexOffset: 0 };\r\n}\r\n\r\n// Tile data passed from main thread\r\ninterface TileData {\r\n  index: number;\r\n  vertices: Vec3[];  // Tile corner vertices\r\n  center: Vec3;      // Tile center\r\n  neighbors: number[];\r\n}\r\n\r\n// Column data passed from main thread\r\ninterface ColumnData {\r\n  tileIndex: number;\r\n  tile: TileData;\r\n  blocks: number[];  // HexBlockType values\r\n}\r\n\r\n// HexBlockType is imported from shared/blockTypes\r\n\r\n// Config passed from main thread\r\ninterface WorkerConfig {\r\n  radius: number;\r\n  blockHeight: number;\r\n  seaLevel: number;\r\n  maxDepth: number;  // Total depth (for radius calculation)\r\n  deepThreshold: number;\r\n  waterSurfaceOffset: number;\r\n  sunDirection: Vec3;\r\n  uvScale: number;  // Texture tiling scale\r\n  torches?: TorchData[];  // Nearby torches for vertex lighting (optional)\r\n}\r\n\r\n// Helper to convert depth to radius (0 = bedrock, maxDepth-1 = sky)\r\nfunction depthToRadius(depth: number, config: WorkerConfig): number {\r\n  return config.radius - (config.maxDepth - 1 - depth) * config.blockHeight;\r\n}\r\n\r\n// Calculate torch light contribution at a point\r\nlet torchLightDebugLogged = false;\r\nfunction calculateTorchLight(x: number, y: number, z: number, torches: TorchData[]): number {\r\n  let totalLight = 0;\r\n  for (const torch of torches) {\r\n    const dx = x - torch.position.x;\r\n    const dy = y - torch.position.y;\r\n    const dz = z - torch.position.z;\r\n    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n\r\n    if (dist < torch.range) {\r\n      // Quadratic falloff matching the shader formula\r\n      const attenuation = 1.0 / (1.0 + 2.0 * dist * dist / (torch.range * torch.range));\r\n      totalLight += attenuation * torch.intensity;\r\n      if (!torchLightDebugLogged) {\r\n        console.log(`[GeometryWorker] Torch light hit! vertex=(${x.toFixed(2)},${y.toFixed(2)},${z.toFixed(2)}), dist=${dist.toFixed(2)}, light=${totalLight.toFixed(3)}`);\r\n        torchLightDebugLogged = true;\r\n      }\r\n    }\r\n  }\r\n  return Math.min(totalLight, 1.5); // Cap at 1.5 like the shader\r\n}\r\n\r\n// Neighbor data includes both blocks and vertices for water wall generation\r\ninterface NeighborData {\r\n  blocks: number[];\r\n  vertices: Vec3[];\r\n}\r\n\r\n// Message types\r\ninterface BuildGeometryMessage {\r\n  type: 'buildGeometry';\r\n  columns: ColumnData[];\r\n  neighborData: Record<string, NeighborData>; // tileIndex -> blocks and vertices for neighbor lookup\r\n  config: WorkerConfig;\r\n}\r\n\r\ninterface GeometryResultMessage {\r\n  type: 'geometryResult';\r\n  topData: GeometryData;\r\n  sideData: GeometryData;\r\n  grassSideData: GeometryData;  // Grass block sides use dirt_grass texture\r\n  stoneData: GeometryData;\r\n  sandData: GeometryData;\r\n  woodData: GeometryData;\r\n  waterData: GeometryData;\r\n  // Mineral ore data\r\n  oreCoalData: GeometryData;\r\n  oreCopperData: GeometryData;\r\n  oreIronData: GeometryData;\r\n  oreGoldData: GeometryData;\r\n  oreLithiumData: GeometryData;\r\n  oreAluminumData: GeometryData;\r\n  oreCobaltData: GeometryData;\r\n}\r\n\r\n// Check if a column has an exposed side at the given depth\r\nfunction hasExposedSide(\r\n  column: ColumnData,\r\n  depth: number,\r\n  neighborDataMap: Map<number, NeighborData>\r\n): boolean {\r\n  const blockType = column.blocks[depth];\r\n  if (blockType === HexBlockType.AIR || blockType === HexBlockType.WATER) return false;\r\n\r\n  for (const neighborIndex of column.tile.neighbors) {\r\n    const neighborInfo = neighborDataMap.get(neighborIndex);\r\n    if (!neighborInfo) return true; // No neighbor data = edge of loaded area\r\n\r\n    const neighborBlock = neighborInfo.blocks[depth];\r\n    if (neighborBlock === undefined) return true;\r\n    if (neighborBlock === HexBlockType.AIR || neighborBlock === HexBlockType.WATER) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n// Merge geometry into target data (simplified version without THREE.js)\r\n// Optimized: uses push.apply for batch operations instead of individual pushes\r\nfunction mergeGeometry(\r\n  target: GeometryData,\r\n  positions: number[],\r\n  normals: number[],\r\n  uvs: number[],\r\n  indices: number[],\r\n  _sunDirection: Vec3,\r\n  skyLightLevel: number,\r\n  torches: TorchData[] = []\r\n): void {\r\n  const vertexCount = positions.length / 3;\r\n  const baseIndex = target.vertexOffset;\r\n\r\n  // Batch push arrays (much faster than individual pushes)\r\n  // Note: push.apply has a limit (~100k args) but face geometry is small\r\n  target.positions.push.apply(target.positions, positions);\r\n  target.normals.push.apply(target.normals, normals);\r\n  target.uvs.push.apply(target.uvs, uvs);\r\n\r\n  // Add vertex colors (white, lighting handled in shader)\r\n  // Pre-build array then batch push\r\n  const colorsToAdd = new Array(vertexCount * 3);\r\n  for (let i = 0; i < vertexCount; i++) {\r\n    const idx = i * 3;\r\n    colorsToAdd[idx] = 1;\r\n    colorsToAdd[idx + 1] = 1;\r\n    colorsToAdd[idx + 2] = 1;\r\n  }\r\n  target.colors.push.apply(target.colors, colorsToAdd);\r\n\r\n  // Add sky light - pre-build array\r\n  const skyLightToAdd = new Array(vertexCount);\r\n  for (let i = 0; i < vertexCount; i++) {\r\n    skyLightToAdd[i] = skyLightLevel;\r\n  }\r\n  target.skyLight.push.apply(target.skyLight, skyLightToAdd);\r\n\r\n  // Add torch light - calculate per vertex based on position\r\n  const torchLightToAdd = new Array(vertexCount);\r\n  for (let i = 0; i < vertexCount; i++) {\r\n    const px = positions[i * 3];\r\n    const py = positions[i * 3 + 1];\r\n    const pz = positions[i * 3 + 2];\r\n    torchLightToAdd[i] = calculateTorchLight(px, py, pz, torches);\r\n  }\r\n  target.torchLight.push.apply(target.torchLight, torchLightToAdd);\r\n\r\n  // Add indices with offset - pre-build array\r\n  const indicesToAdd = new Array(indices.length);\r\n  for (let i = 0; i < indices.length; i++) {\r\n    indicesToAdd[i] = indices[i] + baseIndex;\r\n  }\r\n  target.indices.push.apply(target.indices, indicesToAdd);\r\n\r\n  target.vertexOffset += vertexCount;\r\n}\r\n\r\n// Create geometry for a hex column face (top, bottom, or sides)\r\nfunction createFaceGeometry(\r\n  tile: TileData,\r\n  innerRadius: number,\r\n  outerRadius: number,\r\n  isTop: boolean,\r\n  isBottom: boolean,\r\n  isSides: boolean,\r\n  _uvScale: number = 10\r\n): { positions: number[]; normals: number[]; uvs: number[]; indices: number[] } | null {\r\n  const numSides = tile.vertices.length;\r\n  const radialDir = vec3Normalize(tile.center);\r\n\r\n  // Scale vertices to inner and outer radii\r\n  const innerVerts: Vec3[] = [];\r\n  const outerVerts: Vec3[] = [];\r\n\r\n  for (const v of tile.vertices) {\r\n    const dir = vec3Normalize(v);\r\n    innerVerts.push(vec3Scale(dir, innerRadius));\r\n    outerVerts.push(vec3Scale(dir, outerRadius));\r\n  }\r\n\r\n  const innerCenter = vec3Scale(radialDir, innerRadius);\r\n  const outerCenter = vec3Scale(radialDir, outerRadius);\r\n\r\n  // Create local tangent space for UV mapping\r\n  const localUp = vec3Clone(radialDir);\r\n  let localRight = vec3(1, 0, 0);\r\n  if (Math.abs(vec3Dot(localUp, localRight)) > 0.9) {\r\n    localRight = vec3(0, 0, 1);\r\n  }\r\n  const localForward = vec3Normalize(vec3Cross(localUp, localRight));\r\n  localRight = vec3Normalize(vec3Cross(localForward, localUp));\r\n\r\n  const positions: number[] = [];\r\n  const normals: number[] = [];\r\n  const uvs: number[] = [];\r\n  const indices: number[] = [];\r\n\r\n  if (isTop) {\r\n    // Top face - use regular polygon UVs regardless of 3D distortion\r\n    const topNormal = vec3Clone(radialDir);\r\n\r\n    // Center vertex at UV center\r\n    positions.push(outerCenter.x, outerCenter.y, outerCenter.z);\r\n    normals.push(topNormal.x, topNormal.y, topNormal.z);\r\n    uvs.push(0.5, 0.5);\r\n\r\n    // Edge vertices with regular polygon UVs (same for all hexagons/pentagons)\r\n    const uvRadius = 0.5; // UV radius from center\r\n    for (let i = 0; i < numSides; i++) {\r\n      const v = outerVerts[i];\r\n      positions.push(v.x, v.y, v.z);\r\n      normals.push(topNormal.x, topNormal.y, topNormal.z);\r\n\r\n      // Generate regular polygon UV based on vertex index\r\n      const angle = (i / numSides) * Math.PI * 2 - Math.PI / 2; // Start from top\r\n      const u = 0.5 + Math.cos(angle) * uvRadius;\r\n      const vCoord = 0.5 + Math.sin(angle) * uvRadius;\r\n      uvs.push(u, vCoord);\r\n    }\r\n\r\n    for (let i = 0; i < numSides; i++) {\r\n      const next = (i + 1) % numSides;\r\n      indices.push(0, 1 + i, 1 + next);\r\n    }\r\n  } else if (isBottom) {\r\n    // Bottom face - use regular polygon UVs\r\n    const bottomNormal = vec3Negate(radialDir);\r\n\r\n    positions.push(innerCenter.x, innerCenter.y, innerCenter.z);\r\n    normals.push(bottomNormal.x, bottomNormal.y, bottomNormal.z);\r\n    uvs.push(0.5, 0.5);\r\n\r\n    const uvRadius = 0.5;\r\n    for (let i = 0; i < numSides; i++) {\r\n      const v = innerVerts[i];\r\n      positions.push(v.x, v.y, v.z);\r\n      normals.push(bottomNormal.x, bottomNormal.y, bottomNormal.z);\r\n\r\n      // Generate regular polygon UV based on vertex index\r\n      const angle = (i / numSides) * Math.PI * 2 - Math.PI / 2;\r\n      const u = 0.5 + Math.cos(angle) * uvRadius;\r\n      const vCoord = 0.5 + Math.sin(angle) * uvRadius;\r\n      uvs.push(u, vCoord);\r\n    }\r\n\r\n    for (let i = 0; i < numSides; i++) {\r\n      const next = (i + 1) % numSides;\r\n      indices.push(0, 1 + next, 1 + i);\r\n    }\r\n  } else if (isSides) {\r\n    // Side faces\r\n    let vertexIndex = 0;\r\n\r\n    for (let i = 0; i < numSides; i++) {\r\n      const next = (i + 1) % numSides;\r\n\r\n      const outerV1 = outerVerts[i];\r\n      const outerV2 = outerVerts[next];\r\n      const innerV1 = innerVerts[i];\r\n      const innerV2 = innerVerts[next];\r\n\r\n      // Calculate side normal using cross product\r\n      const edge1 = vec3Sub(innerV2, innerV1);\r\n      const edge2 = vec3Sub(outerV1, innerV1);\r\n      const sideNormal = vec3Normalize(vec3Cross(edge1, edge2));\r\n\r\n      positions.push(\r\n        innerV1.x, innerV1.y, innerV1.z,\r\n        innerV2.x, innerV2.y, innerV2.z,\r\n        outerV2.x, outerV2.y, outerV2.z,\r\n        outerV1.x, outerV1.y, outerV1.z\r\n      );\r\n\r\n      for (let j = 0; j < 4; j++) {\r\n        normals.push(sideNormal.x, sideNormal.y, sideNormal.z);\r\n      }\r\n\r\n      uvs.push(0, 0, 1, 0, 1, 1, 0, 1);\r\n\r\n      indices.push(\r\n        vertexIndex, vertexIndex + 1, vertexIndex + 2,\r\n        vertexIndex, vertexIndex + 2, vertexIndex + 3\r\n      );\r\n      vertexIndex += 4;\r\n    }\r\n  }\r\n\r\n  if (positions.length === 0) return null;\r\n  return { positions, normals, uvs, indices };\r\n}\r\n\r\n// Build geometry for a single column\r\nfunction buildColumnGeometry(\r\n  column: ColumnData,\r\n  neighborDataMap: Map<number, NeighborData>,\r\n  config: WorkerConfig,\r\n  topData: GeometryData,\r\n  sideData: GeometryData,\r\n  grassSideData: GeometryData,\r\n  stoneData: GeometryData,\r\n  sandData: GeometryData,\r\n  woodData: GeometryData,\r\n  waterData: GeometryData,\r\n  oreCoalData: GeometryData,\r\n  oreCopperData: GeometryData,\r\n  oreIronData: GeometryData,\r\n  oreGoldData: GeometryData,\r\n  oreLithiumData: GeometryData,\r\n  oreAluminumData: GeometryData,\r\n  oreCobaltData: GeometryData\r\n): void {\r\n  // Find surface depth (topmost solid block, searching from top down)\r\n  // Depth system: 0 = bedrock, maxDepth-1 = sky\r\n  let surfaceDepth = 0;\r\n  for (let d = column.blocks.length - 1; d >= 0; d--) {\r\n    if (column.blocks[d] !== HexBlockType.AIR && column.blocks[d] !== HexBlockType.WATER) {\r\n      surfaceDepth = d;\r\n      break;\r\n    }\r\n  }\r\n\r\n  for (let depth = 0; depth < column.blocks.length; depth++) {\r\n    const blockType = column.blocks[depth];\r\n    if (blockType === HexBlockType.AIR) continue;\r\n\r\n    const isWater = blockType === HexBlockType.WATER;\r\n    // In new depth system: \"above\" = higher depth (toward sky), \"below\" = lower depth (toward bedrock)\r\n    const blockAbove = depth >= column.blocks.length - 1 ? HexBlockType.AIR : column.blocks[depth + 1];\r\n    const blockBelow = depth === 0 ? HexBlockType.AIR : column.blocks[depth - 1];\r\n\r\n    const hasTopExposed = blockAbove === HexBlockType.AIR || (!isWater && blockAbove === HexBlockType.WATER);\r\n    const hasBottomExposed = blockBelow === HexBlockType.AIR || (!isWater && blockBelow === HexBlockType.WATER);\r\n\r\n    if (isWater && blockAbove !== HexBlockType.AIR) continue;\r\n\r\n    const hasSideExposed = !isWater && hasExposedSide(column, depth, neighborDataMap);\r\n\r\n    if (!isWater && !hasTopExposed && !hasBottomExposed && !hasSideExposed) continue;\r\n\r\n    // In new system: higher depth = larger radius (closer to surface)\r\n    let outerRadius = depthToRadius(depth, config);\r\n    let innerRadius = outerRadius - config.blockHeight;\r\n\r\n    if (isWater) {\r\n      outerRadius -= config.waterSurfaceOffset;\r\n      innerRadius -= config.waterSurfaceOffset;\r\n    }\r\n\r\n    if (innerRadius <= 0) continue;\r\n\r\n    // depthFromSurface: positive = below surface (lower depth)\r\n    const depthFromSurface = surfaceDepth - depth;\r\n\r\n    // Get the geometry buffer for this block type\r\n    // Ore blocks use their specific ore textures, other blocks use their standard textures\r\n    let blockGeomData: GeometryData;\r\n    switch (blockType) {\r\n      case HexBlockType.ORE_COAL: blockGeomData = oreCoalData; break;\r\n      case HexBlockType.ORE_COPPER: blockGeomData = oreCopperData; break;\r\n      case HexBlockType.ORE_IRON: blockGeomData = oreIronData; break;\r\n      case HexBlockType.ORE_GOLD: blockGeomData = oreGoldData; break;\r\n      case HexBlockType.ORE_LITHIUM: blockGeomData = oreLithiumData; break;\r\n      case HexBlockType.ORE_ALUMINUM: blockGeomData = oreAluminumData; break;\r\n      case HexBlockType.ORE_COBALT: blockGeomData = oreCobaltData; break;\r\n      case HexBlockType.STONE: blockGeomData = stoneData; break;\r\n      case HexBlockType.SAND: blockGeomData = sandData; break;\r\n      case HexBlockType.DIRT: blockGeomData = sideData; break;\r\n      case HexBlockType.WOOD: blockGeomData = woodData; break;\r\n      default: blockGeomData = topData; break; // Grass and others use top (grass) texture\r\n    }\r\n\r\n    // Calculate sky light (constants imported from shared/geometry)\r\n    let skyLightLevel = 1.0;\r\n    if (depthFromSurface > 0) {\r\n      skyLightLevel = Math.max(MIN_SKY_LIGHT, Math.pow(SKY_LIGHT_FALLOFF, depthFromSurface));\r\n    }\r\n\r\n    // Get torches array (default to empty)\r\n    const torches = config.torches || [];\r\n\r\n    // Create top face\r\n    if (isWater ? true : hasTopExposed) {\r\n      const topGeom = createFaceGeometry(column.tile, innerRadius, outerRadius, true, false, false, config.uvScale);\r\n      if (topGeom) {\r\n        if (isWater) {\r\n          mergeGeometry(waterData, topGeom.positions, topGeom.normals, topGeom.uvs, topGeom.indices, config.sunDirection, 1.0, torches);\r\n        } else {\r\n          mergeGeometry(blockGeomData, topGeom.positions, topGeom.normals, topGeom.uvs, topGeom.indices, config.sunDirection, skyLightLevel, torches);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Create bottom face\r\n    if (!isWater && hasBottomExposed) {\r\n      const bottomGeom = createFaceGeometry(column.tile, innerRadius, outerRadius, false, true, false, config.uvScale);\r\n      if (bottomGeom) {\r\n        const bottomSkyLight = Math.max(MIN_SKY_LIGHT, skyLightLevel * SKY_LIGHT_FALLOFF);\r\n        // Grass blocks show dirt on bottom, everything else shows its own texture\r\n        if (blockType === HexBlockType.GRASS) {\r\n          mergeGeometry(sideData, bottomGeom.positions, bottomGeom.normals, bottomGeom.uvs, bottomGeom.indices, config.sunDirection, bottomSkyLight, torches);\r\n        } else {\r\n          mergeGeometry(blockGeomData, bottomGeom.positions, bottomGeom.normals, bottomGeom.uvs, bottomGeom.indices, config.sunDirection, bottomSkyLight, torches);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Create side faces\r\n    if (!isWater && hasSideExposed) {\r\n      const sidesGeom = createFaceGeometry(column.tile, innerRadius, outerRadius, false, false, true, config.uvScale);\r\n      if (sidesGeom) {\r\n        // Grass blocks use grassSideData (dirt_grass texture) for sides\r\n        if (blockType === HexBlockType.GRASS) {\r\n          mergeGeometry(grassSideData, sidesGeom.positions, sidesGeom.normals, sidesGeom.uvs, sidesGeom.indices, config.sunDirection, skyLightLevel, torches);\r\n        } else {\r\n          mergeGeometry(blockGeomData, sidesGeom.positions, sidesGeom.normals, sidesGeom.uvs, sidesGeom.indices, config.sunDirection, skyLightLevel, torches);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Worker message handler\r\nself.onmessage = (e: MessageEvent<BuildGeometryMessage>) => {\r\n  const { type, columns, neighborData, config } = e.data;\r\n\r\n  if (type === 'buildGeometry') {\r\n    const torchCount = config.torches?.length || 0;\r\n    console.log(`[GeometryWorker] Received ${torchCount} torches`);\r\n    if (torchCount > 0) {\r\n      const t = config.torches![0];\r\n      console.log(`[GeometryWorker] First torch: pos=(${t.position.x.toFixed(2)}, ${t.position.y.toFixed(2)}, ${t.position.z.toFixed(2)}), range=${t.range}`);\r\n    }\r\n    const topData = createEmptyGeometryData();\r\n    const sideData = createEmptyGeometryData();\r\n    const grassSideData = createEmptyGeometryData();\r\n    const stoneData = createEmptyGeometryData();\r\n    const sandData = createEmptyGeometryData();\r\n    const woodData = createEmptyGeometryData();\r\n    const waterData = createEmptyGeometryData();\r\n    // Mineral ore geometry data\r\n    const oreCoalData = createEmptyGeometryData();\r\n    const oreCopperData = createEmptyGeometryData();\r\n    const oreIronData = createEmptyGeometryData();\r\n    const oreGoldData = createEmptyGeometryData();\r\n    const oreLithiumData = createEmptyGeometryData();\r\n    const oreAluminumData = createEmptyGeometryData();\r\n    const oreCobaltData = createEmptyGeometryData();\r\n\r\n    // Convert neighborData back to Map (it gets serialized as object)\r\n    const neighborDataMap = new Map<number, NeighborData>(\r\n      Object.entries(neighborData as unknown as Record<string, NeighborData>).map(([k, v]) => [parseInt(k), v])\r\n    );\r\n\r\n    for (const column of columns) {\r\n      buildColumnGeometry(\r\n        column, neighborDataMap, config,\r\n        topData, sideData, grassSideData, stoneData, sandData, woodData, waterData,\r\n        oreCoalData, oreCopperData, oreIronData, oreGoldData, oreLithiumData, oreAluminumData, oreCobaltData\r\n      );\r\n\r\n      // Generate water walls for water blocks\r\n      for (let depth = 0; depth < column.blocks.length; depth++) {\r\n        if (column.blocks[depth] === HexBlockType.WATER) {\r\n          // In new depth system: \"above\" = higher depth\r\n          const blockAbove = depth >= column.blocks.length - 1 ? HexBlockType.AIR : column.blocks[depth + 1];\r\n          if (blockAbove === HexBlockType.AIR) {\r\n            // This is a water surface - generate water walls\r\n            const outerRadius = depthToRadius(depth, config) - config.waterSurfaceOffset;\r\n            buildWaterWallGeometry(\r\n              column.tile.vertices,\r\n              column.tile.neighbors,\r\n              column.blocks,\r\n              neighborDataMap,\r\n              depth,\r\n              outerRadius,\r\n              config,\r\n              waterData\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const result: GeometryResultMessage = {\r\n      type: 'geometryResult',\r\n      topData,\r\n      sideData,\r\n      grassSideData,\r\n      stoneData,\r\n      sandData,\r\n      woodData,\r\n      waterData,\r\n      oreCoalData,\r\n      oreCopperData,\r\n      oreIronData,\r\n      oreGoldData,\r\n      oreLithiumData,\r\n      oreAluminumData,\r\n      oreCobaltData\r\n    };\r\n\r\n    // Transfer arrays for better performance\r\n    self.postMessage(result);\r\n  }\r\n};\r\n\r\nexport {};\r\n"],"names":["HexBlockType","vec3","x","y","z","vec3Clone","v","vec3Sub","a","b","vec3Scale","s","vec3Dot","vec3Cross","vec3Length","vec3Normalize","len","vec3Negate","vec3Distance","SKY_LIGHT_FALLOFF","MIN_SKY_LIGHT","buildWaterWallGeometry","tileVertices","tileNeighbors","ownBlocks","neighborBlocksMap","waterSurfaceDepth","outerRadius","config","waterData","numSides","edgeThreshold","i","next","edgeV1","edgeV2","neighborData","neighborIndex","candidate","hasV1","hasV2","nv","ownSolidDepth","d","ownBlock","neighborSolidDepth","neighborBlock","wallBottomDepth","wallTopRadius","wallBottomRadius","dir1","dir2","topV1","topV2","bottomV1","bottomV2","edge1","edge2","sideNormal","baseIdx","j","createEmptyGeometryData","depthToRadius","depth","torchLightDebugLogged","calculateTorchLight","torches","totalLight","torch","dx","dy","dz","dist","attenuation","hasExposedSide","column","neighborDataMap","blockType","neighborInfo","mergeGeometry","target","positions","normals","uvs","indices","_sunDirection","skyLightLevel","vertexCount","baseIndex","colorsToAdd","idx","skyLightToAdd","torchLightToAdd","px","py","pz","indicesToAdd","createFaceGeometry","tile","innerRadius","isTop","isBottom","isSides","_uvScale","radialDir","innerVerts","outerVerts","dir","innerCenter","outerCenter","localUp","localRight","localForward","topNormal","uvRadius","angle","u","vCoord","bottomNormal","vertexIndex","outerV1","outerV2","innerV1","innerV2","buildColumnGeometry","topData","sideData","grassSideData","stoneData","sandData","woodData","oreCoalData","oreCopperData","oreIronData","oreGoldData","oreLithiumData","oreAluminumData","oreCobaltData","surfaceDepth","isWater","blockAbove","blockBelow","hasTopExposed","hasBottomExposed","hasSideExposed","depthFromSurface","blockGeomData","topGeom","bottomGeom","bottomSkyLight","sidesGeom","e","type","columns","torchCount","_a","t","k","result"],"mappings":"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"}