(function(){"use strict";var l=(s=>(s[s.AIR=0]="AIR",s[s.STONE=1]="STONE",s[s.DIRT=2]="DIRT",s[s.GRASS=3]="GRASS",s[s.WATER=4]="WATER",s[s.SAND=5]="SAND",s[s.WOOD=6]="WOOD",s[s.LEAVES=7]="LEAVES",s))(l||{});function w(s,o,c){return{x:s,y:o,z:c}}function P(s){return{x:s.x,y:s.y,z:s.z}}function V(s,o){return{x:s.x-o.x,y:s.y-o.y,z:s.z-o.z}}function L(s,o){return{x:s.x*o,y:s.y*o,z:s.z*o}}function X(s,o){return s.x*o.x+s.y*o.y+s.z*o.z}function C(s,o){return{x:s.y*o.z-s.z*o.y,y:s.z*o.x-s.x*o.z,z:s.x*o.y-s.y*o.x}}function j(s){return Math.sqrt(s.x*s.x+s.y*s.y+s.z*s.z)}function T(s){const o=j(s);return o===0?{x:0,y:0,z:0}:{x:s.x/o,y:s.y/o,z:s.z/o}}function Z(s){return{x:-s.x,y:-s.y,z:-s.z}}function K(s,o){return j(V(s,o))}const Y=.8,q=.05;function $(s,o,c,S,f,k,x,r){const A=s.length,n=.001;for(let d=0;d<A;d++){const a=(d+1)%A,i=s[d],h=s[a];let R;for(const b of o){const M=S.get(b);if(!M)continue;let U=!1,J=!1;for(const Q of M.vertices)K(Q,i)<n&&(U=!0),K(Q,h)<n&&(J=!0);if(U&&J){R=M;break}}if(!R||R.blocks[f]!==l.AIR)continue;let W=f+1;for(let b=f+1;b<c.length;b++){const M=c[b];if(M!==l.AIR&&M!==l.WATER){W=b;break}}let v=f+1;for(let b=f+1;b<R.blocks.length;b++){const M=R.blocks[b];if(M!==l.AIR&&M!==l.WATER){v=b;break}else if(M===l.AIR)v=b+1;else break}const m=Math.min(W,v),z=k,g=x.radius-m*x.blockHeight;if(g>=z)continue;const u=T(i),p=T(h),e=L(u,z),t=L(p,z),y=L(u,g),I=L(p,g),E=V(I,y),_=V(e,y),N=T(C(E,_)),D=r.vertexOffset;r.positions.push(y.x,y.y,y.z,I.x,I.y,I.z,t.x,t.y,t.z,e.x,e.y,e.z);for(let b=0;b<4;b++)r.normals.push(N.x,N.y,N.z);r.uvs.push(0,0,1,0,1,1,0,1),r.skyLight.push(1,1,1,1),r.colors.push(1,1,1,1,1,1,1,1,1,1,1,1),r.indices.push(D,D+1,D+2,D,D+2,D+3),r.vertexOffset+=4}}function G(){return{positions:[],normals:[],uvs:[],colors:[],skyLight:[],indices:[],vertexOffset:0}}function B(s,o,c){const S=s.blocks[o];if(S===l.AIR||S===l.WATER)return!1;for(const f of s.tile.neighbors){const k=c.get(f);if(!k)return!0;const x=k.blocks[o];if(x===void 0||x===l.AIR||x===l.WATER)return!0}return!1}function O(s,o,c,S,f,k,x){const r=o.length/3,A=s.vertexOffset;s.positions.push.apply(s.positions,o),s.normals.push.apply(s.normals,c),s.uvs.push.apply(s.uvs,S);const n=new Array(r*3);for(let i=0;i<r;i++){const h=i*3;n[h]=1,n[h+1]=1,n[h+2]=1}s.colors.push.apply(s.colors,n);const d=new Array(r);for(let i=0;i<r;i++)d[i]=x;s.skyLight.push.apply(s.skyLight,d);const a=new Array(f.length);for(let i=0;i<f.length;i++)a[i]=f[i]+A;s.indices.push.apply(s.indices,a),s.vertexOffset+=r}function F(s,o,c,S,f,k,x=10){const r=s.vertices.length,A=T(s.center),n=[],d=[];for(const u of s.vertices){const p=T(u);n.push(L(p,o)),d.push(L(p,c))}const a=L(A,o),i=L(A,c),h=P(A);let R=w(1,0,0);Math.abs(X(h,R))>.9&&(R=w(0,0,1));const W=T(C(h,R));R=T(C(W,h));const v=[],m=[],z=[],g=[];if(S){const u=P(A);v.push(i.x,i.y,i.z),m.push(u.x,u.y,u.z),z.push(.5,.5);const p=.5;for(let e=0;e<r;e++){const t=d[e];v.push(t.x,t.y,t.z),m.push(u.x,u.y,u.z);const y=e/r*Math.PI*2-Math.PI/2,I=.5+Math.cos(y)*p,E=.5+Math.sin(y)*p;z.push(I,E)}for(let e=0;e<r;e++){const t=(e+1)%r;g.push(0,1+e,1+t)}}else if(f){const u=Z(A);v.push(a.x,a.y,a.z),m.push(u.x,u.y,u.z),z.push(.5,.5);const p=.5;for(let e=0;e<r;e++){const t=n[e];v.push(t.x,t.y,t.z),m.push(u.x,u.y,u.z);const y=e/r*Math.PI*2-Math.PI/2,I=.5+Math.cos(y)*p,E=.5+Math.sin(y)*p;z.push(I,E)}for(let e=0;e<r;e++){const t=(e+1)%r;g.push(0,1+t,1+e)}}else if(k){let u=0;for(let p=0;p<r;p++){const e=(p+1)%r,t=d[p],y=d[e],I=n[p],E=n[e],_=V(E,I),N=V(t,I),D=T(C(_,N));v.push(I.x,I.y,I.z,E.x,E.y,E.z,y.x,y.y,y.z,t.x,t.y,t.z);for(let b=0;b<4;b++)m.push(D.x,D.y,D.z);z.push(0,0,1,0,1,1,0,1),g.push(u,u+1,u+2,u,u+2,u+3),u+=4}}return v.length===0?null:{positions:v,normals:m,uvs:z,indices:g}}function H(s,o,c,S,f,k,x,r){let A=0;for(let n=0;n<s.blocks.length;n++)if(s.blocks[n]!==l.AIR&&s.blocks[n]!==l.WATER){A=n;break}for(let n=0;n<s.blocks.length;n++){const d=s.blocks[n];if(d===l.AIR)continue;const a=d===l.WATER,i=n===0?l.AIR:s.blocks[n-1],h=n>=s.blocks.length-1?l.AIR:s.blocks[n+1],R=i===l.AIR||!a&&i===l.WATER,W=h===l.AIR||!a&&h===l.WATER;if(a&&i!==l.AIR)continue;const v=!a&&B(s,n,o);if(!a&&!R&&!W&&!v)continue;let m=c.radius-n*c.blockHeight,z=m-c.blockHeight;if(a&&(m-=c.waterSurfaceOffset,z-=c.waterSurfaceOffset),z<=0)continue;const g=n-A,u=d===l.STONE,p=d===l.DIRT;let e=1;if(g>0&&(e=Math.max(q,Math.pow(Y,g))),a||R){const t=F(s.tile,z,m,!0,!1,!1,c.uvScale);t&&(a?O(r,t.positions,t.normals,t.uvs,t.indices,c.sunDirection,1):O(u?x:p?f:S,t.positions,t.normals,t.uvs,t.indices,c.sunDirection,e))}if(!a&&W){const t=F(s.tile,z,m,!1,!0,!1,c.uvScale);if(t){const y=Math.max(q,e*Y);O(u?x:f,t.positions,t.normals,t.uvs,t.indices,c.sunDirection,y)}}if(!a&&v){const t=F(s.tile,z,m,!1,!1,!0,c.uvScale);t&&O(u?x:p?f:k,t.positions,t.normals,t.uvs,t.indices,c.sunDirection,e)}}}self.onmessage=s=>{const{type:o,columns:c,neighborData:S,config:f}=s.data;if(o==="buildGeometry"){const k=G(),x=G(),r=G(),A=G(),n=G(),d=new Map(Object.entries(S).map(([i,h])=>[parseInt(i),h]));for(const i of c){H(i,d,f,k,x,r,A,n);for(let h=0;h<i.blocks.length;h++)if(i.blocks[h]===l.WATER&&(h===0?l.AIR:i.blocks[h-1])===l.AIR){const W=f.radius-h*f.blockHeight-f.waterSurfaceOffset;$(i.tile.vertices,i.tile.neighbors,i.blocks,d,h,W,f,n)}}const a={type:"geometryResult",topData:k,sideData:x,grassSideData:r,stoneData:A,waterData:n};self.postMessage(a)}}})();
//# sourceMappingURL=geometryWorker-B85QpABT.js.map
