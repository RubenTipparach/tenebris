(function(){"use strict";function re(){return{grassPositions:[],grassNormals:[],grassUvs:[],grassSkyLight:[],grassIndices:[],grassVertexOffset:0,dirtPositions:[],dirtNormals:[],dirtUvs:[],dirtSkyLight:[],dirtIndices:[],dirtVertexOffset:0,waterPositions:[],waterNormals:[],waterUvs:[],waterIndices:[],waterVertexOffset:0,sidePositions:[],sideNormals:[],sideUvs:[],sideSkyLight:[],sideIndices:[],sideVertexOffset:0,waterSidePositions:[],waterSideNormals:[],waterSideUvs:[],waterSideIndices:[],waterSideVertexOffset:0}}const Y={AIR:0,DIRT:2,GRASS:3,WATER:4};let H=null,te=0;self.onmessage=ae=>{const{type:de,tileData:se,blockData:fe,nearbyTiles:le,tileToChunk:ue,config:W}=ae.data;if(de==="buildLODGeometry"){const K=new Set(le),$=new Map(Object.entries(ue).map(([a,y])=>[parseInt(a),y])),Z=new Map;for(const[a,y]of Object.entries(se)){const e=parseInt(a),n=fe[e];n&&Z.set(e,{tileIndex:e,tile:y,blocks:n})}const ne=Object.keys(se).length;if(!H||te!==ne){H=new Map,te=ne;for(const[a,y]of Z){const e=y.tile,n=e.vertices.length,f=Math.sqrt(e.center.x*e.center.x+e.center.y*e.center.y+e.center.z*e.center.z),i=f>0?{x:e.center.x/f,y:e.center.y/f,z:e.center.z/f}:{x:0,y:0,z:0},o=[];for(const s of e.vertices){const m=Math.sqrt(s.x*s.x+s.y*s.y+s.z*s.z);o.push(m>0?{x:s.x/m,y:s.y/m,z:s.z/m}:{x:0,y:0,z:0})}const c=[];for(let s=0;s<n;s++){const m=(s+1)%n,S=e.vertices[s],b=e.vertices[m],p=S.x+b.x,I=S.y+b.y,z=S.z+b.z,v=Math.sqrt(p*p+I*I+z*z);c.push(v>0?{x:p/v,y:I/v,z:z/v}:{x:0,y:0,z:0})}const g=[];for(let s=0;s<n;s++){const m=c[s];let S=-1,b=1/0;for(const p of e.neighbors){const I=Z.get(p);if(!I)continue;const z=I.tile.center,v=Math.sqrt(z.x*z.x+z.y*z.y+z.z*z.z);if(v===0)continue;const X=z.x/v,N=z.y/v,P=z.z/v,T=X-m.x,k=N-m.y,O=P-m.z,G=T*T+k*k+O*O;G<b&&(b=G,S=p)}g.push(S)}const t=Math.abs(i.y)<.9?{x:0,y:1,z:0}:{x:1,y:0,z:0},l=t.y*i.z-t.z*i.y,h=t.z*i.x-t.x*i.z,d=t.x*i.y-t.y*i.x,u=Math.sqrt(l*l+h*h+d*d),x=u>0?{x:l/u,y:h/u,z:d/u}:{x:1,y:0,z:0},U=i.y*x.z-i.z*x.y,C=i.z*x.x-i.x*x.z,V=i.x*x.y-i.y*x.x,r={x:U,y:C,z:V},w=[];let L=1/0,D=-1/0,R=1/0,A=-1/0;for(const s of e.vertices){const m=s.x-e.center.x,S=s.y-e.center.y,b=s.z-e.center.z,p=m*x.x+S*x.y+b*x.z,I=m*r.x+S*r.y+b*r.z;w.push({u:p,v:I}),L=Math.min(L,p),D=Math.max(D,p),R=Math.min(R,I),A=Math.max(A,I)}const q=D-L,E=A-R,j=w.map(s=>({u:(s.u-L)/q,v:(s.v-R)/E})),_={u:(0-L)/q,v:(0-R)/E};H.set(a,{normalizedCenter:i,normalizedVertices:o,edgeMidDirs:c,edgeNeighborIdx:g,normalizedUVs:j,centerUV:_})}}const J=[];for(let a=0;a<W.chunkCount;a++)J.push(re());const oe=W.radius-W.seaLevel*W.blockHeight-W.lodOffset,B=new Map;for(const[a,y]of Z){let e=0,n=Y.GRASS;const f=y.blocks;for(let c=0;c<f.length;c++)if(f[c]!==Y.AIR){e=c,n=f[c];break}const i=n===Y.WATER,o=i?oe:W.radius-e*W.blockHeight-W.lodOffset;B.set(a,{radius:o,isWater:i,surfaceBlockType:n})}const M=W.cameraDir,ee=-.2;for(const[a]of Z){if(K.has(a))continue;const y=H.get(a);if(M){const r=y.normalizedCenter;if(r.x*M.x+r.y*M.y+r.z*M.z<ee)continue}const e=B.get(a),n=e.radius,f=e.surfaceBlockType,i=$.get(a)??0,o=J[i];let c,g,t,l,h,d;f===Y.WATER?(c=o.waterPositions,g=o.waterNormals,t=o.waterUvs,l=null,h=o.waterIndices,d=o.waterVertexOffset):f===Y.DIRT?(c=o.dirtPositions,g=o.dirtNormals,t=o.dirtUvs,l=o.dirtSkyLight,h=o.dirtIndices,d=o.dirtVertexOffset):(c=o.grassPositions,g=o.grassNormals,t=o.grassUvs,l=o.grassSkyLight,h=o.grassIndices,d=o.grassVertexOffset);const u=y.normalizedCenter,x=y.normalizedVertices,U=y.normalizedUVs,C=y.centerUV,V=d;c.push(u.x*n,u.y*n,u.z*n),g.push(u.x,u.y,u.z),t.push(C.u,C.v),l&&l.push(1),d++;for(let r=0;r<x.length;r++){const w=x[r];c.push(w.x*n,w.y*n,w.z*n),g.push(u.x,u.y,u.z),t.push(U[r].u,U[r].v),l&&l.push(1),d++,h.push(V,V+1+r,V+1+(r+1)%x.length)}f===Y.WATER?o.waterVertexOffset=d:f===Y.DIRT?o.dirtVertexOffset=d:o.grassVertexOffset=d}for(const[a]of Z){if(K.has(a))continue;const y=H.get(a);if(M){const l=y.normalizedCenter;if(l.x*M.x+l.y*M.y+l.z*M.z<ee)continue}const e=B.get(a),n=e.radius,f=e.isWater,i=y.normalizedVertices,o=y.edgeNeighborIdx,c=i.length,g=$.get(a)??0,t=J[g];for(let l=0;l<c;l++){const h=o[l];if(h<0)continue;const d=B.get(h);if(!d)continue;const u=d.radius,x=d.isWater;if(!(n>u||f&&!x))continue;const C=(l+1)%c,V=i[l],r=i[C],w=V.x*u,L=V.y*u,D=V.z*u,R=r.x*u,A=r.y*u,q=r.z*u,E=V.x*n,j=V.y*n,_=V.z*n,s=r.x*n,m=r.y*n,S=r.z*n,b=R-w,p=A-L,I=q-D,z=E-w,v=j-L,X=_-D,N=p*X-I*v,P=I*z-b*X,T=b*v-p*z,k=Math.sqrt(N*N+P*P+T*T),O=k>0?N/k:0,G=k>0?P/k:0,Q=k>0?T/k:0,ye=f?t.waterSidePositions:t.sidePositions,ge=f?t.waterSideNormals:t.sideNormals,he=f?t.waterSideUvs:t.sideUvs,ie=f?null:t.sideSkyLight,ce=f?t.waterSideIndices:t.sideIndices,F=f?t.waterSideVertexOffset:t.sideVertexOffset;ye.push(w,L,D,R,A,q,s,m,S,E,j,_),ge.push(O,G,Q,O,G,Q,O,G,Q,O,G,Q),he.push(0,0,1,0,1,1,0,1),ie&&ie.push(1,1,1,1),ce.push(F,F+1,F+2),ce.push(F,F+2,F+3),f?t.waterSideVertexOffset+=4:t.sideVertexOffset+=4}}for(const[a]of Z){if(K.has(a))continue;const y=H.get(a);if(M){const g=y.normalizedCenter;if(g.x*M.x+g.y*M.y+g.z*M.z<ee)continue}const e=B.get(a);if(!e||!e.isWater)continue;const n=y.normalizedVertices,f=y.edgeNeighborIdx,i=n.length,o=$.get(a)??0,c=J[o];for(let g=0;g<i;g++){const t=f[g];if(t<0||!K.has(t))continue;const l=B.get(t);if(!l)continue;const h=l.radius,d=oe;if(h>=d)continue;const u=(g+1)%i,x=n[g],U=n[u],C=x.x*h,V=x.y*h,r=x.z*h,w=U.x*h,L=U.y*h,D=U.z*h,R=x.x*d,A=x.y*d,q=x.z*d,E=U.x*d,j=U.y*d,_=U.z*d,s=w-C,m=L-V,S=D-r,b=R-C,p=A-V,I=q-r,z=m*I-S*p,v=S*b-s*I,X=s*p-m*b,N=Math.sqrt(z*z+v*v+X*X),P=N>0?z/N:0,T=N>0?v/N:0,k=N>0?X/N:0,O=c.waterSideVertexOffset;c.waterSidePositions.push(C,V,r,w,L,D,E,j,_,R,A,q),c.waterSideNormals.push(P,T,k,P,T,k,P,T,k,P,T,k),c.waterSideUvs.push(0,0,1,0,1,1,0,1),c.waterSideIndices.push(O,O+1,O+2),c.waterSideIndices.push(O,O+2,O+3),c.waterSideVertexOffset+=4}}const xe={type:"lodGeometryResult",chunkGeometries:J};self.postMessage(xe)}}})();
//# sourceMappingURL=lodGeometryWorker-CIUgOB9L.js.map
