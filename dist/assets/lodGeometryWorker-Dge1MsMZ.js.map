{"version":3,"file":"lodGeometryWorker-Dge1MsMZ.js","sources":["../src/workers/lodGeometryWorker.ts"],"sourcesContent":["// LOD Geometry Worker - builds LOD terrain geometry off the main thread\n// Optimized: pre-computed normalizations, cached surface data, reduced passes\n\n// Vector3-like operations using plain objects\ninterface Vec3 {\n  x: number;\n  y: number;\n  z: number;\n}\n\n// Note: Vector operations are inlined in hot loops to avoid function call overhead\n// and object allocations. The raw x/y/z math is faster than helper functions.\n\n// Torch data for vertex lighting calculation\ninterface TorchData {\n  position: Vec3;\n  range: number;\n  intensity: number;\n}\n\n// Calculate torch light contribution at a point\nfunction calculateTorchLight(x: number, y: number, z: number, torches: TorchData[]): number {\n  let totalLight = 0;\n  for (const torch of torches) {\n    const dx = x - torch.position.x;\n    const dy = y - torch.position.y;\n    const dz = z - torch.position.z;\n    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n    if (dist < torch.range) {\n      // Quadratic falloff matching the shader formula\n      const attenuation = 1.0 / (1.0 + 2.0 * dist * dist / (torch.range * torch.range));\n      totalLight += attenuation * torch.intensity;\n    }\n  }\n  return Math.min(totalLight, 1.5); // Cap at 1.5 like the shader\n}\n\n// Per-chunk geometry buffers\ninterface ChunkGeometry {\n  grassPositions: number[];\n  grassNormals: number[];\n  grassUvs: number[];\n  grassSkyLight: number[];  // Sky light attribute for terrain shader\n  grassTorchLight: number[];  // Torch light attribute for terrain shader\n  grassIndices: number[];\n  grassVertexOffset: number;\n  dirtPositions: number[];\n  dirtNormals: number[];\n  dirtUvs: number[];\n  dirtSkyLight: number[];\n  dirtTorchLight: number[];\n  dirtIndices: number[];\n  dirtVertexOffset: number;\n  stonePositions: number[];\n  stoneNormals: number[];\n  stoneUvs: number[];\n  stoneSkyLight: number[];\n  stoneTorchLight: number[];\n  stoneIndices: number[];\n  stoneVertexOffset: number;\n  sandPositions: number[];\n  sandNormals: number[];\n  sandUvs: number[];\n  sandSkyLight: number[];\n  sandTorchLight: number[];\n  sandIndices: number[];\n  sandVertexOffset: number;\n  woodPositions: number[];\n  woodNormals: number[];\n  woodUvs: number[];\n  woodSkyLight: number[];\n  woodTorchLight: number[];\n  woodIndices: number[];\n  woodVertexOffset: number;\n  waterPositions: number[];\n  waterNormals: number[];\n  waterUvs: number[];\n  waterIndices: number[];\n  waterVertexOffset: number;\n  sidePositions: number[];\n  sideNormals: number[];\n  sideUvs: number[];\n  sideSkyLight: number[];\n  sideTorchLight: number[];\n  sideIndices: number[];\n  sideVertexOffset: number;\n  waterSidePositions: number[];\n  waterSideNormals: number[];\n  waterSideUvs: number[];\n  waterSideIndices: number[];\n  waterSideVertexOffset: number;\n  // Snow biome buffers\n  snowPositions: number[];\n  snowNormals: number[];\n  snowUvs: number[];\n  snowSkyLight: number[];\n  snowTorchLight: number[];\n  snowIndices: number[];\n  snowVertexOffset: number;\n  icePositions: number[];\n  iceNormals: number[];\n  iceUvs: number[];\n  iceSkyLight: number[];\n  iceTorchLight: number[];\n  iceIndices: number[];\n  iceVertexOffset: number;\n}\n\nfunction createEmptyChunkGeometry(): ChunkGeometry {\n  return {\n    grassPositions: [], grassNormals: [], grassUvs: [], grassSkyLight: [], grassTorchLight: [], grassIndices: [], grassVertexOffset: 0,\n    dirtPositions: [], dirtNormals: [], dirtUvs: [], dirtSkyLight: [], dirtTorchLight: [], dirtIndices: [], dirtVertexOffset: 0,\n    stonePositions: [], stoneNormals: [], stoneUvs: [], stoneSkyLight: [], stoneTorchLight: [], stoneIndices: [], stoneVertexOffset: 0,\n    sandPositions: [], sandNormals: [], sandUvs: [], sandSkyLight: [], sandTorchLight: [], sandIndices: [], sandVertexOffset: 0,\n    woodPositions: [], woodNormals: [], woodUvs: [], woodSkyLight: [], woodTorchLight: [], woodIndices: [], woodVertexOffset: 0,\n    waterPositions: [], waterNormals: [], waterUvs: [], waterIndices: [], waterVertexOffset: 0,\n    sidePositions: [], sideNormals: [], sideUvs: [], sideSkyLight: [], sideTorchLight: [], sideIndices: [], sideVertexOffset: 0,\n    waterSidePositions: [], waterSideNormals: [], waterSideUvs: [], waterSideIndices: [], waterSideVertexOffset: 0,\n    snowPositions: [], snowNormals: [], snowUvs: [], snowSkyLight: [], snowTorchLight: [], snowIndices: [], snowVertexOffset: 0,\n    icePositions: [], iceNormals: [], iceUvs: [], iceSkyLight: [], iceTorchLight: [], iceIndices: [], iceVertexOffset: 0\n  };\n}\n\n// Tile data passed from main thread\ninterface TileData {\n  index: number;\n  vertices: Vec3[];\n  center: Vec3;\n  neighbors: number[];\n}\n\n// Column data passed from main thread\ninterface ColumnData {\n  tileIndex: number;\n  tile: TileData;\n  blocks: number[];\n}\n\n// Pre-computed tile data for fast access\ninterface PrecomputedTileData {\n  normalizedCenter: Vec3;\n  normalizedVertices: Vec3[];\n  // Edge midpoint normalized directions (for neighbor lookup)\n  edgeMidDirs: Vec3[];\n  // Which neighbor is across each edge (index into neighbors array, -1 if none found)\n  edgeNeighborIdx: number[];\n  // Pre-computed normalized UVs for each vertex (0-1 range, touching edges)\n  normalizedUVs: { u: number; v: number }[];\n  // Center UV (where the face center maps to in UV space)\n  centerUV: { u: number; v: number };\n}\n\n// Block types (must match HexBlock.ts)\nconst HexBlockType = {\n  AIR: 0,\n  STONE: 1,\n  DIRT: 2,\n  GRASS: 3,\n  WATER: 4,\n  SAND: 5,\n  WOOD: 6,\n  LEAVES: 7,\n  // Mineral ores\n  ORE_COAL: 8,\n  ORE_COPPER: 9,\n  ORE_IRON: 10,\n  ORE_GOLD: 11,\n  ORE_LITHIUM: 12,\n  ORE_ALUMINUM: 13,\n  ORE_COBALT: 14,\n  // Snow biome blocks\n  SNOW: 15,\n  DIRT_SNOW: 16,\n  ICE: 17,\n  // Technology blocks\n  FURNACE: 18,\n  // Glass\n  GLASS: 19,\n  // Advanced technology blocks\n  COMPUTER: 20,\n  PRINTER_3D: 21\n};\n\n// Config passed from main thread\ninterface LODWorkerConfig {\n  radius: number;\n  blockHeight: number;\n  seaLevel: number;\n  maxDepth: number;  // Total depth (for radius calculation)\n  waterSurfaceOffset: number;\n  lodOffset: number;\n  chunkCount: number;\n}\n\n// Helper to convert depth to radius (0 = bedrock, maxDepth-1 = sky)\nfunction depthToRadius(depth: number, config: LODWorkerConfig): number {\n  return config.radius - (config.maxDepth - 1 - depth) * config.blockHeight;\n}\n\n// Get sea level depth in new system (0 = bedrock)\nfunction getSeaLevelDepth(config: LODWorkerConfig): number {\n  return config.maxDepth - 1 - config.seaLevel;\n}\n\n// Message types\ninterface BuildLODGeometryMessage {\n  type: 'buildLODGeometry';\n  tileData: Record<number, TileData>;\n  blockData: Record<number, number[]>;\n  nearbyTiles: number[];\n  tileToChunk: Record<number, number>;\n  config: LODWorkerConfig;\n  torches?: TorchData[];  // Torch positions for vertex lighting\n}\n\ninterface LODGeometryResultMessage {\n  type: 'lodGeometryResult';\n  chunkGeometries: ChunkGeometry[];\n}\n\n// Cached pre-computed data (persists across messages for same tile structure)\nlet cachedPrecomputed: Map<number, PrecomputedTileData> | null = null;\nlet cachedTileCount = 0;\n\n// Worker message handler\nself.onmessage = (e: MessageEvent<BuildLODGeometryMessage>) => {\n  const { type, tileData, blockData, nearbyTiles, tileToChunk, config, torches = [] } = e.data;\n\n  if (type === 'buildLODGeometry') {\n    const nearbyTilesSet = new Set(nearbyTiles);\n    const tileToChunkMap = new Map(Object.entries(tileToChunk).map(([k, v]) => [parseInt(k), v]));\n\n    // Reconstruct columns from separate tile and block data\n    const columnsMap = new Map<number, ColumnData>();\n    for (const [tileIndexStr, tile] of Object.entries(tileData)) {\n      const tileIndex = parseInt(tileIndexStr);\n      const blocks = blockData[tileIndex];\n      if (blocks) {\n        columnsMap.set(tileIndex, { tileIndex, tile, blocks });\n      }\n    }\n\n    // Pre-compute normalized data if not cached or tile count changed\n    const tileCount = Object.keys(tileData).length;\n    if (!cachedPrecomputed || cachedTileCount !== tileCount) {\n      cachedPrecomputed = new Map();\n      cachedTileCount = tileCount;\n\n      for (const [tileIndex, column] of columnsMap) {\n        const tile = column.tile;\n        const numVerts = tile.vertices.length;\n\n        // Normalize center once\n        const centerLen = Math.sqrt(tile.center.x * tile.center.x + tile.center.y * tile.center.y + tile.center.z * tile.center.z);\n        const normalizedCenter: Vec3 = centerLen > 0\n          ? { x: tile.center.x / centerLen, y: tile.center.y / centerLen, z: tile.center.z / centerLen }\n          : { x: 0, y: 0, z: 0 };\n\n        // Normalize all vertices once\n        const normalizedVertices: Vec3[] = [];\n        for (const v of tile.vertices) {\n          const vLen = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n          normalizedVertices.push(vLen > 0\n            ? { x: v.x / vLen, y: v.y / vLen, z: v.z / vLen }\n            : { x: 0, y: 0, z: 0 });\n        }\n\n        // Pre-compute edge midpoint directions\n        const edgeMidDirs: Vec3[] = [];\n        for (let i = 0; i < numVerts; i++) {\n          const next = (i + 1) % numVerts;\n          const v1 = tile.vertices[i];\n          const v2 = tile.vertices[next];\n          const midX = v1.x + v2.x;\n          const midY = v1.y + v2.y;\n          const midZ = v1.z + v2.z;\n          const midLen = Math.sqrt(midX * midX + midY * midY + midZ * midZ);\n          edgeMidDirs.push(midLen > 0\n            ? { x: midX / midLen, y: midY / midLen, z: midZ / midLen }\n            : { x: 0, y: 0, z: 0 });\n        }\n\n        // Pre-compute which neighbor is across each edge\n        const edgeNeighborIdx: number[] = [];\n        for (let i = 0; i < numVerts; i++) {\n          const edgeMidDir = edgeMidDirs[i];\n          let closestNeighbor = -1;\n          let closestDist = Infinity;\n\n          for (const nIdx of tile.neighbors) {\n            const neighborColumn = columnsMap.get(nIdx);\n            if (!neighborColumn) continue;\n\n            const nc = neighborColumn.tile.center;\n            const ncLen = Math.sqrt(nc.x * nc.x + nc.y * nc.y + nc.z * nc.z);\n            if (ncLen === 0) continue;\n\n            const ncNormX = nc.x / ncLen;\n            const ncNormY = nc.y / ncLen;\n            const ncNormZ = nc.z / ncLen;\n\n            const dx = ncNormX - edgeMidDir.x;\n            const dy = ncNormY - edgeMidDir.y;\n            const dz = ncNormZ - edgeMidDir.z;\n            const dist = dx * dx + dy * dy + dz * dz;\n\n            if (dist < closestDist) {\n              closestDist = dist;\n              closestNeighbor = nIdx;\n            }\n          }\n          edgeNeighborIdx.push(closestNeighbor);\n        }\n\n        // Pre-compute local coordinate system for UV mapping\n        // Create tangent and bitangent vectors perpendicular to the normal\n        const up: Vec3 = Math.abs(normalizedCenter.y) < 0.9\n          ? { x: 0, y: 1, z: 0 }\n          : { x: 1, y: 0, z: 0 };\n\n        // tangent = cross(up, normal)\n        const tangentX = up.y * normalizedCenter.z - up.z * normalizedCenter.y;\n        const tangentY = up.z * normalizedCenter.x - up.x * normalizedCenter.z;\n        const tangentZ = up.x * normalizedCenter.y - up.y * normalizedCenter.x;\n        const tangentLen = Math.sqrt(tangentX * tangentX + tangentY * tangentY + tangentZ * tangentZ);\n        const tangent: Vec3 = tangentLen > 0\n          ? { x: tangentX / tangentLen, y: tangentY / tangentLen, z: tangentZ / tangentLen }\n          : { x: 1, y: 0, z: 0 };\n\n        // bitangent = cross(normal, tangent)\n        const bitangentX = normalizedCenter.y * tangent.z - normalizedCenter.z * tangent.y;\n        const bitangentY = normalizedCenter.z * tangent.x - normalizedCenter.x * tangent.z;\n        const bitangentZ = normalizedCenter.x * tangent.y - normalizedCenter.y * tangent.x;\n        const bitangent: Vec3 = { x: bitangentX, y: bitangentY, z: bitangentZ };\n\n        // Project vertices onto local 2D plane and find bounding box\n        const localCoords: { u: number; v: number }[] = [];\n        let minU = Infinity, maxU = -Infinity, minV = Infinity, maxV = -Infinity;\n\n        for (const vert of tile.vertices) {\n          // Vector from center to vertex\n          const toVertX = vert.x - tile.center.x;\n          const toVertY = vert.y - tile.center.y;\n          const toVertZ = vert.z - tile.center.z;\n\n          // Project onto tangent and bitangent\n          const u = toVertX * tangent.x + toVertY * tangent.y + toVertZ * tangent.z;\n          const v = toVertX * bitangent.x + toVertY * bitangent.y + toVertZ * bitangent.z;\n          localCoords.push({ u, v });\n\n          minU = Math.min(minU, u);\n          maxU = Math.max(maxU, u);\n          minV = Math.min(minV, v);\n          maxV = Math.max(maxV, v);\n        }\n\n        // Normalize UVs to 0-1 range\n        const rangeU = maxU - minU;\n        const rangeV = maxV - minV;\n        const normalizedUVs: { u: number; v: number }[] = localCoords.map(coord => ({\n          u: (coord.u - minU) / rangeU,\n          v: (coord.v - minV) / rangeV\n        }));\n\n        // Center UV (the center vertex at (0,0) in local coords maps to this UV)\n        const centerUV = {\n          u: (0 - minU) / rangeU,\n          v: (0 - minV) / rangeV\n        };\n\n        cachedPrecomputed.set(tileIndex, {\n          normalizedCenter,\n          normalizedVertices,\n          edgeMidDirs,\n          edgeNeighborIdx,\n          normalizedUVs,\n          centerUV\n        });\n      }\n    }\n\n    const chunkGeometries: ChunkGeometry[] = [];\n    for (let i = 0; i < config.chunkCount; i++) {\n      chunkGeometries.push(createEmptyChunkGeometry());\n    }\n\n    const seaLevelDepth = getSeaLevelDepth(config);\n    const waterRadius = depthToRadius(seaLevelDepth, config) - config.lodOffset;\n\n    // Combined first pass: calculate display radius AND surface block type for each tile\n    // This eliminates redundant block array searches\n    interface TileInfo {\n      radius: number;           // Display radius for LOD rendering\n      isWater: boolean;         // True if surface is water\n      surfaceBlockType: number; // The topmost non-air block type\n      terrainRadius: number;    // Radius of actual solid terrain (for water walls)\n    }\n    const tileInfo = new Map<number, TileInfo>();\n\n    for (const [tileIndex, column] of columnsMap) {\n      // Find surface depth (topmost non-air block, searching from top down)\n      let surfaceDepth = 0;\n      let surfaceBlockType = HexBlockType.GRASS;\n      let terrainDepth = 0; // Topmost solid block (ignoring water)\n      const blocks = column.blocks;\n      for (let d = blocks.length - 1; d >= 0; d--) {\n        if (blocks[d] !== HexBlockType.AIR) {\n          if (surfaceBlockType === HexBlockType.GRASS) {\n            // First non-air block found\n            surfaceDepth = d;\n            surfaceBlockType = blocks[d];\n          }\n          if (blocks[d] !== HexBlockType.WATER) {\n            // First solid (non-water) block found\n            terrainDepth = d;\n            break;\n          }\n        }\n      }\n\n      const isWater = surfaceBlockType === HexBlockType.WATER;\n      const displayRadius = isWater\n        ? waterRadius\n        : depthToRadius(surfaceDepth, config) - config.lodOffset;\n      const terrainRadius = depthToRadius(terrainDepth, config) - config.lodOffset;\n\n      tileInfo.set(tileIndex, { radius: displayRadius, isWater, surfaceBlockType, terrainRadius });\n    }\n\n    // NOTE: Do NOT do camera-based back-face culling here - the geometry is built once\n    // but the camera moves after. THREE.js handles per-chunk frustum culling at render time\n    // via cullLODChunks() in Planet.ts\n\n    // Second pass: build top faces for LOD tiles (uses cached data)\n    for (const [tileIndex] of columnsMap) {\n      if (nearbyTilesSet.has(tileIndex)) continue;\n\n      const precomputed = cachedPrecomputed.get(tileIndex)!;\n      const info = tileInfo.get(tileIndex)!\n      const displayRadius = info.radius;\n      const surfaceBlockType = info.surfaceBlockType;\n\n      const chunkIdx = tileToChunkMap.get(tileIndex) ?? 0;\n      const chunk = chunkGeometries[chunkIdx];\n\n      // Select buffer based on surface type\n      let positions: number[], normals: number[], uvs: number[], skyLight: number[] | null, torchLight: number[] | null, indices: number[];\n      let vertexOffset: number;\n\n      if (surfaceBlockType === HexBlockType.WATER) {\n        positions = chunk.waterPositions;\n        normals = chunk.waterNormals;\n        uvs = chunk.waterUvs;\n        skyLight = null; // Water uses different shader, doesn't need skyLight\n        torchLight = null;\n        indices = chunk.waterIndices;\n        vertexOffset = chunk.waterVertexOffset;\n      } else if (surfaceBlockType === HexBlockType.DIRT) {\n        positions = chunk.dirtPositions;\n        normals = chunk.dirtNormals;\n        uvs = chunk.dirtUvs;\n        skyLight = chunk.dirtSkyLight;\n        torchLight = chunk.dirtTorchLight;\n        indices = chunk.dirtIndices;\n        vertexOffset = chunk.dirtVertexOffset;\n      } else if (surfaceBlockType === HexBlockType.STONE) {\n        positions = chunk.stonePositions;\n        normals = chunk.stoneNormals;\n        uvs = chunk.stoneUvs;\n        skyLight = chunk.stoneSkyLight;\n        torchLight = chunk.stoneTorchLight;\n        indices = chunk.stoneIndices;\n        vertexOffset = chunk.stoneVertexOffset;\n      } else if (surfaceBlockType === HexBlockType.SAND) {\n        positions = chunk.sandPositions;\n        normals = chunk.sandNormals;\n        uvs = chunk.sandUvs;\n        skyLight = chunk.sandSkyLight;\n        torchLight = chunk.sandTorchLight;\n        indices = chunk.sandIndices;\n        vertexOffset = chunk.sandVertexOffset;\n      } else if (surfaceBlockType === HexBlockType.WOOD) {\n        positions = chunk.woodPositions;\n        normals = chunk.woodNormals;\n        uvs = chunk.woodUvs;\n        skyLight = chunk.woodSkyLight;\n        torchLight = chunk.woodTorchLight;\n        indices = chunk.woodIndices;\n        vertexOffset = chunk.woodVertexOffset;\n      } else if (surfaceBlockType === HexBlockType.SNOW || surfaceBlockType === HexBlockType.DIRT_SNOW) {\n        positions = chunk.snowPositions;\n        normals = chunk.snowNormals;\n        uvs = chunk.snowUvs;\n        skyLight = chunk.snowSkyLight;\n        torchLight = chunk.snowTorchLight;\n        indices = chunk.snowIndices;\n        vertexOffset = chunk.snowVertexOffset;\n      } else if (surfaceBlockType === HexBlockType.ICE || surfaceBlockType === HexBlockType.GLASS) {\n        positions = chunk.icePositions;\n        normals = chunk.iceNormals;\n        uvs = chunk.iceUvs;\n        skyLight = chunk.iceSkyLight;\n        torchLight = chunk.iceTorchLight;\n        indices = chunk.iceIndices;\n        vertexOffset = chunk.iceVertexOffset;\n      } else {\n        // GRASS, LEAVES, or any other type defaults to grass\n        positions = chunk.grassPositions;\n        normals = chunk.grassNormals;\n        uvs = chunk.grassUvs;\n        skyLight = chunk.grassSkyLight;\n        torchLight = chunk.grassTorchLight;\n        indices = chunk.grassIndices;\n        vertexOffset = chunk.grassVertexOffset;\n      }\n\n      // Use pre-computed normalized center, vertices, and UVs\n      const normal = precomputed.normalizedCenter;\n      const normalizedVerts = precomputed.normalizedVertices;\n      const normalizedUVs = precomputed.normalizedUVs;\n      const centerUV = precomputed.centerUV;\n\n      // Fan triangulation from center\n      const centerIdx = vertexOffset;\n      const cx = normal.x * displayRadius;\n      const cy = normal.y * displayRadius;\n      const cz = normal.z * displayRadius;\n      positions.push(cx, cy, cz);\n      normals.push(normal.x, normal.y, normal.z);\n      uvs.push(centerUV.u, centerUV.v);\n      if (skyLight) skyLight.push(1.0); // LOD terrain is always at surface, full sky exposure\n      if (torchLight) torchLight.push(calculateTorchLight(cx, cy, cz, torches));\n      vertexOffset++;\n\n      for (let i = 0; i < normalizedVerts.length; i++) {\n        const nv = normalizedVerts[i];\n        const vx = nv.x * displayRadius;\n        const vy = nv.y * displayRadius;\n        const vz = nv.z * displayRadius;\n        positions.push(vx, vy, vz);\n        normals.push(normal.x, normal.y, normal.z);\n        uvs.push(normalizedUVs[i].u, normalizedUVs[i].v);\n        if (skyLight) skyLight.push(1.0);\n        if (torchLight) torchLight.push(calculateTorchLight(vx, vy, vz, torches));\n        vertexOffset++;\n\n        indices.push(centerIdx, centerIdx + 1 + i, centerIdx + 1 + ((i + 1) % normalizedVerts.length));\n      }\n\n      // Update offset\n      if (surfaceBlockType === HexBlockType.WATER) {\n        chunk.waterVertexOffset = vertexOffset;\n      } else if (surfaceBlockType === HexBlockType.DIRT) {\n        chunk.dirtVertexOffset = vertexOffset;\n      } else if (surfaceBlockType === HexBlockType.STONE) {\n        chunk.stoneVertexOffset = vertexOffset;\n      } else if (surfaceBlockType === HexBlockType.SAND) {\n        chunk.sandVertexOffset = vertexOffset;\n      } else if (surfaceBlockType === HexBlockType.WOOD) {\n        chunk.woodVertexOffset = vertexOffset;\n      } else if (surfaceBlockType === HexBlockType.SNOW || surfaceBlockType === HexBlockType.DIRT_SNOW) {\n        chunk.snowVertexOffset = vertexOffset;\n      } else if (surfaceBlockType === HexBlockType.ICE || surfaceBlockType === HexBlockType.GLASS) {\n        chunk.iceVertexOffset = vertexOffset;\n      } else {\n        chunk.grassVertexOffset = vertexOffset;\n      }\n    }\n\n    // Third pass: generate side walls (uses cached edge-neighbor mapping)\n    for (const [tileIndex] of columnsMap) {\n      if (nearbyTilesSet.has(tileIndex)) continue;\n\n      const precomputed = cachedPrecomputed.get(tileIndex)!;\n      const info = tileInfo.get(tileIndex)!\n      const thisRadius = info.radius;\n      const thisIsWater = info.isWater;\n      const normalizedVerts = precomputed.normalizedVertices;\n      const edgeNeighborIdx = precomputed.edgeNeighborIdx;\n      const numSides = normalizedVerts.length;\n\n      const chunkIdx = tileToChunkMap.get(tileIndex) ?? 0;\n      const chunk = chunkGeometries[chunkIdx];\n\n      for (let i = 0; i < numSides; i++) {\n        const neighborTileIdx = edgeNeighborIdx[i];\n        if (neighborTileIdx < 0) continue;\n\n        const neighborInfo = tileInfo.get(neighborTileIdx);\n        if (!neighborInfo) continue;\n\n        const neighborRadius = neighborInfo.radius;\n\n        // Generate wall only when this tile is higher than neighbor\n        // This applies to both solid and water tiles - walls show height differences\n        if (thisRadius <= neighborRadius) continue;\n\n        const next = (i + 1) % numSides;\n        const nv1 = normalizedVerts[i];\n        const nv2 = normalizedVerts[next];\n\n        // Create wall vertices using pre-normalized directions\n        const innerV1x = nv1.x * neighborRadius, innerV1y = nv1.y * neighborRadius, innerV1z = nv1.z * neighborRadius;\n        const innerV2x = nv2.x * neighborRadius, innerV2y = nv2.y * neighborRadius, innerV2z = nv2.z * neighborRadius;\n        const outerV1x = nv1.x * thisRadius, outerV1y = nv1.y * thisRadius, outerV1z = nv1.z * thisRadius;\n        const outerV2x = nv2.x * thisRadius, outerV2y = nv2.y * thisRadius, outerV2z = nv2.z * thisRadius;\n\n        // Calculate side normal\n        const edge1x = innerV2x - innerV1x, edge1y = innerV2y - innerV1y, edge1z = innerV2z - innerV1z;\n        const edge2x = outerV1x - innerV1x, edge2y = outerV1y - innerV1y, edge2z = outerV1z - innerV1z;\n        const crossX = edge1y * edge2z - edge1z * edge2y;\n        const crossY = edge1z * edge2x - edge1x * edge2z;\n        const crossZ = edge1x * edge2y - edge1y * edge2x;\n        const crossLen = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);\n        const snx = crossLen > 0 ? crossX / crossLen : 0;\n        const sny = crossLen > 0 ? crossY / crossLen : 0;\n        const snz = crossLen > 0 ? crossZ / crossLen : 0;\n\n        const positions = thisIsWater ? chunk.waterSidePositions : chunk.sidePositions;\n        const normals = thisIsWater ? chunk.waterSideNormals : chunk.sideNormals;\n        const uvs = thisIsWater ? chunk.waterSideUvs : chunk.sideUvs;\n        const skyLight = thisIsWater ? null : chunk.sideSkyLight;\n        const sideTorchLight = thisIsWater ? null : chunk.sideTorchLight;\n        const indices = thisIsWater ? chunk.waterSideIndices : chunk.sideIndices;\n        const baseIdx = thisIsWater ? chunk.waterSideVertexOffset : chunk.sideVertexOffset;\n\n        positions.push(\n          innerV1x, innerV1y, innerV1z,\n          innerV2x, innerV2y, innerV2z,\n          outerV2x, outerV2y, outerV2z,\n          outerV1x, outerV1y, outerV1z\n        );\n\n        normals.push(snx, sny, snz, snx, sny, snz, snx, sny, snz, snx, sny, snz);\n        uvs.push(0, 0, 1, 0, 1, 1, 0, 1);\n        if (skyLight) skyLight.push(1.0, 1.0, 1.0, 1.0); // Full sky exposure for LOD\n        if (sideTorchLight) {\n          sideTorchLight.push(\n            calculateTorchLight(innerV1x, innerV1y, innerV1z, torches),\n            calculateTorchLight(innerV2x, innerV2y, innerV2z, torches),\n            calculateTorchLight(outerV2x, outerV2y, outerV2z, torches),\n            calculateTorchLight(outerV1x, outerV1y, outerV1z, torches)\n          );\n        }\n\n        indices.push(baseIdx, baseIdx + 1, baseIdx + 2);\n        indices.push(baseIdx, baseIdx + 2, baseIdx + 3);\n\n        if (thisIsWater) {\n          chunk.waterSideVertexOffset += 4;\n        } else {\n          chunk.sideVertexOffset += 4;\n        }\n      }\n    }\n\n    // Fourth pass: water boundary walls at LOD/terrain edge\n    for (const [tileIndex] of columnsMap) {\n      if (nearbyTilesSet.has(tileIndex)) continue;\n\n      const precomputed = cachedPrecomputed.get(tileIndex)!;\n      const info = tileInfo.get(tileIndex);\n      if (!info || !info.isWater) continue;\n      const normalizedVerts = precomputed.normalizedVertices;\n      const edgeNeighborIdx = precomputed.edgeNeighborIdx;\n      const numSides = normalizedVerts.length;\n\n      const chunkIdx = tileToChunkMap.get(tileIndex) ?? 0;\n      const chunk = chunkGeometries[chunkIdx];\n\n      for (let i = 0; i < numSides; i++) {\n        const neighborTileIdx = edgeNeighborIdx[i];\n        if (neighborTileIdx < 0) continue;\n        if (!nearbyTilesSet.has(neighborTileIdx)) continue;\n\n        const neighborInfo = tileInfo.get(neighborTileIdx);\n        if (!neighborInfo) continue;\n\n        // Use terrainRadius (solid ground) not radius (which could be water surface)\n        const bottomRadius = neighborInfo.terrainRadius;\n        const topRadius = waterRadius;\n        if (bottomRadius >= topRadius) continue;\n\n        const next = (i + 1) % numSides;\n        const nv1 = normalizedVerts[i];\n        const nv2 = normalizedVerts[next];\n\n        const innerV1x = nv1.x * bottomRadius, innerV1y = nv1.y * bottomRadius, innerV1z = nv1.z * bottomRadius;\n        const innerV2x = nv2.x * bottomRadius, innerV2y = nv2.y * bottomRadius, innerV2z = nv2.z * bottomRadius;\n        const outerV1x = nv1.x * topRadius, outerV1y = nv1.y * topRadius, outerV1z = nv1.z * topRadius;\n        const outerV2x = nv2.x * topRadius, outerV2y = nv2.y * topRadius, outerV2z = nv2.z * topRadius;\n\n        const edge1x = innerV2x - innerV1x, edge1y = innerV2y - innerV1y, edge1z = innerV2z - innerV1z;\n        const edge2x = outerV1x - innerV1x, edge2y = outerV1y - innerV1y, edge2z = outerV1z - innerV1z;\n        const crossX = edge1y * edge2z - edge1z * edge2y;\n        const crossY = edge1z * edge2x - edge1x * edge2z;\n        const crossZ = edge1x * edge2y - edge1y * edge2x;\n        const crossLen = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ);\n        const snx = crossLen > 0 ? crossX / crossLen : 0;\n        const sny = crossLen > 0 ? crossY / crossLen : 0;\n        const snz = crossLen > 0 ? crossZ / crossLen : 0;\n\n        const baseIdx = chunk.waterSideVertexOffset;\n\n        chunk.waterSidePositions.push(\n          innerV1x, innerV1y, innerV1z,\n          innerV2x, innerV2y, innerV2z,\n          outerV2x, outerV2y, outerV2z,\n          outerV1x, outerV1y, outerV1z\n        );\n\n        chunk.waterSideNormals.push(snx, sny, snz, snx, sny, snz, snx, sny, snz, snx, sny, snz);\n        chunk.waterSideUvs.push(0, 0, 1, 0, 1, 1, 0, 1);\n\n        chunk.waterSideIndices.push(baseIdx, baseIdx + 1, baseIdx + 2);\n        chunk.waterSideIndices.push(baseIdx, baseIdx + 2, baseIdx + 3);\n\n        chunk.waterSideVertexOffset += 4;\n      }\n    }\n\n    const result: LODGeometryResultMessage = {\n      type: 'lodGeometryResult',\n      chunkGeometries\n    };\n\n    self.postMessage(result);\n  }\n};\n\nexport {};\n"],"names":["calculateTorchLight","x","y","z","torches","totalLight","torch","dx","dy","dz","dist","attenuation","createEmptyChunkGeometry","HexBlockType","depthToRadius","depth","config","getSeaLevelDepth","cachedPrecomputed","cachedTileCount","e","type","tileData","blockData","nearbyTiles","tileToChunk","nearbyTilesSet","tileToChunkMap","k","v","columnsMap","tileIndexStr","tile","tileIndex","blocks","tileCount","column","numVerts","centerLen","normalizedCenter","normalizedVertices","vLen","edgeMidDirs","next","v1","v2","midX","midY","midZ","midLen","edgeNeighborIdx","edgeMidDir","closestNeighbor","closestDist","nIdx","neighborColumn","nc","ncLen","ncNormX","ncNormY","ncNormZ","up","tangentX","tangentY","tangentZ","tangentLen","tangent","bitangentX","bitangentY","bitangentZ","bitangent","localCoords","minU","maxU","minV","maxV","vert","toVertX","toVertY","toVertZ","u","rangeU","rangeV","normalizedUVs","coord","centerUV","chunkGeometries","i","seaLevelDepth","waterRadius","tileInfo","surfaceDepth","surfaceBlockType","terrainDepth","d","isWater","displayRadius","terrainRadius","precomputed","info","chunkIdx","chunk","positions","normals","uvs","skyLight","torchLight","indices","vertexOffset","normal","normalizedVerts","centerIdx","cx","cy","cz","nv","vx","vy","vz","thisRadius","thisIsWater","numSides","neighborTileIdx","neighborInfo","neighborRadius","nv1","nv2","innerV1x","innerV1y","innerV1z","innerV2x","innerV2y","innerV2z","outerV1x","outerV1y","outerV1z","outerV2x","outerV2y","outerV2z","edge1x","edge1y","edge1z","edge2x","edge2y","edge2z","crossX","crossY","crossZ","crossLen","snx","sny","snz","sideTorchLight","baseIdx","bottomRadius","topRadius","result"],"mappings":"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"}