(function(){"use strict";function ce(){return{grassPositions:[],grassNormals:[],grassUvs:[],grassSkyLight:[],grassIndices:[],grassVertexOffset:0,dirtPositions:[],dirtNormals:[],dirtUvs:[],dirtSkyLight:[],dirtIndices:[],dirtVertexOffset:0,stonePositions:[],stoneNormals:[],stoneUvs:[],stoneSkyLight:[],stoneIndices:[],stoneVertexOffset:0,sandPositions:[],sandNormals:[],sandUvs:[],sandSkyLight:[],sandIndices:[],sandVertexOffset:0,woodPositions:[],woodNormals:[],woodUvs:[],woodSkyLight:[],woodIndices:[],woodVertexOffset:0,waterPositions:[],waterNormals:[],waterUvs:[],waterIndices:[],waterVertexOffset:0,sidePositions:[],sideNormals:[],sideUvs:[],sideSkyLight:[],sideIndices:[],sideVertexOffset:0,waterSidePositions:[],waterSideNormals:[],waterSideUvs:[],waterSideIndices:[],waterSideVertexOffset:0}}const N={AIR:0,STONE:1,DIRT:2,GRASS:3,WATER:4,SAND:5,WOOD:6};let G=null,ee=0;self.onmessage=re=>{const{type:de,tileData:te,blockData:ae,nearbyTiles:fe,tileToChunk:le,config:A}=re.data;if(de==="buildLODGeometry"){const J=new Set(fe),Q=new Map(Object.entries(le).map(([f,h])=>[parseInt(f),h])),Y=new Map;for(const[f,h]of Object.entries(te)){const t=parseInt(f),i=ae[t];i&&Y.set(t,{tileIndex:t,tile:h,blocks:i})}const se=Object.keys(te).length;if(!G||ee!==se){G=new Map,ee=se;for(const[f,h]of Y){const t=h.tile,i=t.vertices.length,c=Math.sqrt(t.center.x*t.center.x+t.center.y*t.center.y+t.center.z*t.center.z),a=c>0?{x:t.center.x/c,y:t.center.y/c,z:t.center.z/c}:{x:0,y:0,z:0},e=[];for(const o of t.vertices){const m=Math.sqrt(o.x*o.x+o.y*o.y+o.z*o.z);e.push(m>0?{x:o.x/m,y:o.y/m,z:o.z/m}:{x:0,y:0,z:0})}const r=[];for(let o=0;o<i;o++){const m=(o+1)%i,O=t.vertices[o],v=t.vertices[m],I=O.x+v.x,w=O.y+v.y,z=O.z+v.z,p=Math.sqrt(I*I+w*w+z*z);r.push(p>0?{x:I/p,y:w/p,z:z/p}:{x:0,y:0,z:0})}const x=[];for(let o=0;o<i;o++){const m=r[o];let O=-1,v=1/0;for(const I of t.neighbors){const w=Y.get(I);if(!w)continue;const z=w.tile.center,p=Math.sqrt(z.x*z.x+z.y*z.y+z.z*z.z);if(p===0)continue;const q=z.x/p,M=z.y/p,L=z.z/p,R=q-m.x,D=M-m.y,b=L-m.z,K=R*R+D*D+b*b;K<v&&(v=K,O=I)}x.push(O)}const s=Math.abs(a.y)<.9?{x:0,y:1,z:0}:{x:1,y:0,z:0},d=s.y*a.z-s.z*a.y,u=s.z*a.x-s.x*a.z,n=s.x*a.y-s.y*a.x,l=Math.sqrt(d*d+u*u+n*n),g=l>0?{x:d/l,y:u/l,z:n/l}:{x:1,y:0,z:0},V=a.y*g.z-a.z*g.y,S=a.z*g.x-a.x*g.z,U=a.x*g.y-a.y*g.x,y={x:V,y:S,z:U},k=[];let P=1/0,W=-1/0,C=1/0,E=-1/0;for(const o of t.vertices){const m=o.x-t.center.x,O=o.y-t.center.y,v=o.z-t.center.z,I=m*g.x+O*g.y+v*g.z,w=m*y.x+O*y.y+v*y.z;k.push({u:I,v:w}),P=Math.min(P,I),W=Math.max(W,I),C=Math.min(C,w),E=Math.max(E,w)}const X=W-P,Z=E-C,_=k.map(o=>({u:(o.u-P)/X,v:(o.v-C)/Z})),F={u:(0-P)/X,v:(0-C)/Z};G.set(f,{normalizedCenter:a,normalizedVertices:e,edgeMidDirs:r,edgeNeighborIdx:x,normalizedUVs:_,centerUV:F})}}const j=[];for(let f=0;f<A.chunkCount;f++)j.push(ce());const ne=A.radius-A.seaLevel*A.blockHeight-A.lodOffset,H=new Map;for(const[f,h]of Y){let t=0,i=N.GRASS;const c=h.blocks;for(let r=0;r<c.length;r++)if(c[r]!==N.AIR){t=r,i=c[r];break}const a=i===N.WATER,e=a?ne:A.radius-t*A.blockHeight-A.lodOffset;H.set(f,{radius:e,isWater:a,surfaceBlockType:i})}const T=A.cameraDir,$=-.2;for(const[f]of Y){if(J.has(f))continue;const h=G.get(f);if(T){const y=h.normalizedCenter;if(y.x*T.x+y.y*T.y+y.z*T.z<$)continue}const t=H.get(f),i=t.radius,c=t.surfaceBlockType,a=Q.get(f)??0,e=j[a];let r,x,s,d,u,n;c===N.WATER?(r=e.waterPositions,x=e.waterNormals,s=e.waterUvs,d=null,u=e.waterIndices,n=e.waterVertexOffset):c===N.DIRT?(r=e.dirtPositions,x=e.dirtNormals,s=e.dirtUvs,d=e.dirtSkyLight,u=e.dirtIndices,n=e.dirtVertexOffset):c===N.STONE?(r=e.stonePositions,x=e.stoneNormals,s=e.stoneUvs,d=e.stoneSkyLight,u=e.stoneIndices,n=e.stoneVertexOffset):c===N.SAND?(r=e.sandPositions,x=e.sandNormals,s=e.sandUvs,d=e.sandSkyLight,u=e.sandIndices,n=e.sandVertexOffset):c===N.WOOD?(r=e.woodPositions,x=e.woodNormals,s=e.woodUvs,d=e.woodSkyLight,u=e.woodIndices,n=e.woodVertexOffset):(r=e.grassPositions,x=e.grassNormals,s=e.grassUvs,d=e.grassSkyLight,u=e.grassIndices,n=e.grassVertexOffset);const l=h.normalizedCenter,g=h.normalizedVertices,V=h.normalizedUVs,S=h.centerUV,U=n;r.push(l.x*i,l.y*i,l.z*i),x.push(l.x,l.y,l.z),s.push(S.u,S.v),d&&d.push(1),n++;for(let y=0;y<g.length;y++){const k=g[y];r.push(k.x*i,k.y*i,k.z*i),x.push(l.x,l.y,l.z),s.push(V[y].u,V[y].v),d&&d.push(1),n++,u.push(U,U+1+y,U+1+(y+1)%g.length)}c===N.WATER?e.waterVertexOffset=n:c===N.DIRT?e.dirtVertexOffset=n:c===N.STONE?e.stoneVertexOffset=n:c===N.SAND?e.sandVertexOffset=n:c===N.WOOD?e.woodVertexOffset=n:e.grassVertexOffset=n}for(const[f]of Y){if(J.has(f))continue;const h=G.get(f);if(T){const d=h.normalizedCenter;if(d.x*T.x+d.y*T.y+d.z*T.z<$)continue}const t=H.get(f),i=t.radius,c=t.isWater,a=h.normalizedVertices,e=h.edgeNeighborIdx,r=a.length,x=Q.get(f)??0,s=j[x];for(let d=0;d<r;d++){const u=e[d];if(u<0)continue;const n=H.get(u);if(!n)continue;const l=n.radius;if(i<=l)continue;const g=(d+1)%r,V=a[d],S=a[g],U=V.x*l,y=V.y*l,k=V.z*l,P=S.x*l,W=S.y*l,C=S.z*l,E=V.x*i,X=V.y*i,Z=V.z*i,_=S.x*i,F=S.y*i,o=S.z*i,m=P-U,O=W-y,v=C-k,I=E-U,w=X-y,z=Z-k,p=O*z-v*w,q=v*I-m*z,M=m*w-O*I,L=Math.sqrt(p*p+q*q+M*M),R=L>0?p/L:0,D=L>0?q/L:0,b=L>0?M/L:0,K=c?s.waterSidePositions:s.sidePositions,ue=c?s.waterSideNormals:s.sideNormals,ye=c?s.waterSideUvs:s.sideUvs,oe=c?null:s.sideSkyLight,ie=c?s.waterSideIndices:s.sideIndices,B=c?s.waterSideVertexOffset:s.sideVertexOffset;K.push(U,y,k,P,W,C,_,F,o,E,X,Z),ue.push(R,D,b,R,D,b,R,D,b,R,D,b),ye.push(0,0,1,0,1,1,0,1),oe&&oe.push(1,1,1,1),ie.push(B,B+1,B+2),ie.push(B,B+2,B+3),c?s.waterSideVertexOffset+=4:s.sideVertexOffset+=4}}for(const[f]of Y){if(J.has(f))continue;const h=G.get(f);if(T){const x=h.normalizedCenter;if(x.x*T.x+x.y*T.y+x.z*T.z<$)continue}const t=H.get(f);if(!t||!t.isWater)continue;const i=h.normalizedVertices,c=h.edgeNeighborIdx,a=i.length,e=Q.get(f)??0,r=j[e];for(let x=0;x<a;x++){const s=c[x];if(s<0||!J.has(s))continue;const d=H.get(s);if(!d)continue;const u=d.radius,n=ne;if(u>=n)continue;const l=(x+1)%a,g=i[x],V=i[l],S=g.x*u,U=g.y*u,y=g.z*u,k=V.x*u,P=V.y*u,W=V.z*u,C=g.x*n,E=g.y*n,X=g.z*n,Z=V.x*n,_=V.y*n,F=V.z*n,o=k-S,m=P-U,O=W-y,v=C-S,I=E-U,w=X-y,z=m*w-O*I,p=O*v-o*w,q=o*I-m*v,M=Math.sqrt(z*z+p*p+q*q),L=M>0?z/M:0,R=M>0?p/M:0,D=M>0?q/M:0,b=r.waterSideVertexOffset;r.waterSidePositions.push(S,U,y,k,P,W,Z,_,F,C,E,X),r.waterSideNormals.push(L,R,D,L,R,D,L,R,D,L,R,D),r.waterSideUvs.push(0,0,1,0,1,1,0,1),r.waterSideIndices.push(b,b+1,b+2),r.waterSideIndices.push(b,b+2,b+3),r.waterSideVertexOffset+=4}}const xe={type:"lodGeometryResult",chunkGeometries:j};self.postMessage(xe)}}})();
//# sourceMappingURL=lodGeometryWorker-BfBahJRa.js.map
