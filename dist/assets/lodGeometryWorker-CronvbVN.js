(function(){"use strict";function ae(){return{grassPositions:[],grassNormals:[],grassUvs:[],grassSkyLight:[],grassIndices:[],grassVertexOffset:0,dirtPositions:[],dirtNormals:[],dirtUvs:[],dirtSkyLight:[],dirtIndices:[],dirtVertexOffset:0,stonePositions:[],stoneNormals:[],stoneUvs:[],stoneSkyLight:[],stoneIndices:[],stoneVertexOffset:0,sandPositions:[],sandNormals:[],sandUvs:[],sandSkyLight:[],sandIndices:[],sandVertexOffset:0,woodPositions:[],woodNormals:[],woodUvs:[],woodSkyLight:[],woodIndices:[],woodVertexOffset:0,waterPositions:[],waterNormals:[],waterUvs:[],waterIndices:[],waterVertexOffset:0,sidePositions:[],sideNormals:[],sideUvs:[],sideSkyLight:[],sideIndices:[],sideVertexOffset:0,waterSidePositions:[],waterSideNormals:[],waterSideUvs:[],waterSideIndices:[],waterSideVertexOffset:0}}const w={AIR:0,STONE:1,DIRT:2,GRASS:3,WATER:4,SAND:5,WOOD:6};function ee(B,_){return _.radius-(_.maxDepth-1-B)*_.blockHeight}function fe(B){return B.maxDepth-1-B.seaLevel}let Z=null,ne=0;self.onmessage=B=>{const{type:_,tileData:oe,blockData:le,nearbyTiles:xe,tileToChunk:ue,config:A}=B.data;if(_==="buildLODGeometry"){const Q=new Set(xe),te=new Map(Object.entries(ue).map(([a,g])=>[parseInt(a),g])),X=new Map;for(const[a,g]of Object.entries(oe)){const s=parseInt(a),n=le[s];n&&X.set(s,{tileIndex:s,tile:g,blocks:n})}const ie=Object.keys(oe).length;if(!Z||ne!==ie){Z=new Map,ne=ie;for(const[a,g]of X){const s=g.tile,n=s.vertices.length,r=Math.sqrt(s.center.x*s.center.x+s.center.y*s.center.y+s.center.z*s.center.z),c=r>0?{x:s.center.x/r,y:s.center.y/r,z:s.center.z/r}:{x:0,y:0,z:0},e=[];for(const i of s.vertices){const m=Math.sqrt(i.x*i.x+i.y*i.y+i.z*i.z);e.push(m>0?{x:i.x/m,y:i.y/m,z:i.z/m}:{x:0,y:0,z:0})}const f=[];for(let i=0;i<n;i++){const m=(i+1)%n,O=s.vertices[i],k=s.vertices[m],I=O.x+k.x,S=O.y+k.y,z=O.z+k.z,p=Math.sqrt(I*I+S*S+z*z);f.push(p>0?{x:I/p,y:S/p,z:z/p}:{x:0,y:0,z:0})}const l=[];for(let i=0;i<n;i++){const m=f[i];let O=-1,k=1/0;for(const I of s.neighbors){const S=X.get(I);if(!S)continue;const z=S.tile.center,p=Math.sqrt(z.x*z.x+z.y*z.y+z.z*z.z);if(p===0)continue;const q=z.x/p,D=z.y/p,U=z.z/p,T=q-m.x,M=D-m.y,N=U-m.z,$=T*T+M*M+N*N;$<k&&(k=$,O=I)}l.push(O)}const t=Math.abs(c.y)<.9?{x:0,y:1,z:0}:{x:1,y:0,z:0},d=t.y*c.z-t.z*c.y,u=t.z*c.x-t.x*c.z,o=t.x*c.y-t.y*c.x,x=Math.sqrt(d*d+u*u+o*o),h=x>0?{x:d/x,y:u/x,z:o/x}:{x:1,y:0,z:0},V=c.y*h.z-c.z*h.y,v=c.z*h.x-c.x*h.z,L=c.x*h.y-c.y*h.x,y={x:V,y:v,z:L},b=[];let P=1/0,W=-1/0,C=1/0,E=-1/0;for(const i of s.vertices){const m=i.x-s.center.x,O=i.y-s.center.y,k=i.z-s.center.z,I=m*h.x+O*h.y+k*h.z,S=m*y.x+O*y.y+k*y.z;b.push({u:I,v:S}),P=Math.min(P,I),W=Math.max(W,I),C=Math.min(C,S),E=Math.max(E,S)}const G=W-P,Y=E-C,J=b.map(i=>({u:(i.u-P)/G,v:(i.v-C)/Y})),K={u:(0-P)/G,v:(0-C)/Y};Z.set(a,{normalizedCenter:c,normalizedVertices:e,edgeMidDirs:f,edgeNeighborIdx:l,normalizedUVs:J,centerUV:K})}}const F=[];for(let a=0;a<A.chunkCount;a++)F.push(ae());const ye=fe(A),re=ee(ye,A)-A.lodOffset,H=new Map;for(const[a,g]of X){let s=0,n=w.GRASS,r=0;const c=g.blocks;for(let t=c.length-1;t>=0;t--)if(c[t]!==w.AIR&&(n===w.GRASS&&(s=t,n=c[t]),c[t]!==w.WATER)){r=t;break}const e=n===w.WATER,f=e?re:ee(s,A)-A.lodOffset,l=ee(r,A)-A.lodOffset;H.set(a,{radius:f,isWater:e,surfaceBlockType:n,terrainRadius:l})}const R=A.cameraDir,se=-.2;for(const[a]of X){if(Q.has(a))continue;const g=Z.get(a);if(R){const y=g.normalizedCenter;if(y.x*R.x+y.y*R.y+y.z*R.z<se)continue}const s=H.get(a),n=s.radius,r=s.surfaceBlockType,c=te.get(a)??0,e=F[c];let f,l,t,d,u,o;r===w.WATER?(f=e.waterPositions,l=e.waterNormals,t=e.waterUvs,d=null,u=e.waterIndices,o=e.waterVertexOffset):r===w.DIRT?(f=e.dirtPositions,l=e.dirtNormals,t=e.dirtUvs,d=e.dirtSkyLight,u=e.dirtIndices,o=e.dirtVertexOffset):r===w.STONE?(f=e.stonePositions,l=e.stoneNormals,t=e.stoneUvs,d=e.stoneSkyLight,u=e.stoneIndices,o=e.stoneVertexOffset):r===w.SAND?(f=e.sandPositions,l=e.sandNormals,t=e.sandUvs,d=e.sandSkyLight,u=e.sandIndices,o=e.sandVertexOffset):r===w.WOOD?(f=e.woodPositions,l=e.woodNormals,t=e.woodUvs,d=e.woodSkyLight,u=e.woodIndices,o=e.woodVertexOffset):(f=e.grassPositions,l=e.grassNormals,t=e.grassUvs,d=e.grassSkyLight,u=e.grassIndices,o=e.grassVertexOffset);const x=g.normalizedCenter,h=g.normalizedVertices,V=g.normalizedUVs,v=g.centerUV,L=o;f.push(x.x*n,x.y*n,x.z*n),l.push(x.x,x.y,x.z),t.push(v.u,v.v),d&&d.push(1),o++;for(let y=0;y<h.length;y++){const b=h[y];f.push(b.x*n,b.y*n,b.z*n),l.push(x.x,x.y,x.z),t.push(V[y].u,V[y].v),d&&d.push(1),o++,u.push(L,L+1+y,L+1+(y+1)%h.length)}r===w.WATER?e.waterVertexOffset=o:r===w.DIRT?e.dirtVertexOffset=o:r===w.STONE?e.stoneVertexOffset=o:r===w.SAND?e.sandVertexOffset=o:r===w.WOOD?e.woodVertexOffset=o:e.grassVertexOffset=o}for(const[a]of X){if(Q.has(a))continue;const g=Z.get(a);if(R){const d=g.normalizedCenter;if(d.x*R.x+d.y*R.y+d.z*R.z<se)continue}const s=H.get(a),n=s.radius,r=s.isWater,c=g.normalizedVertices,e=g.edgeNeighborIdx,f=c.length,l=te.get(a)??0,t=F[l];for(let d=0;d<f;d++){const u=e[d];if(u<0)continue;const o=H.get(u);if(!o)continue;const x=o.radius;if(n<=x)continue;const h=(d+1)%f,V=c[d],v=c[h],L=V.x*x,y=V.y*x,b=V.z*x,P=v.x*x,W=v.y*x,C=v.z*x,E=V.x*n,G=V.y*n,Y=V.z*n,J=v.x*n,K=v.y*n,i=v.z*n,m=P-L,O=W-y,k=C-b,I=E-L,S=G-y,z=Y-b,p=O*z-k*S,q=k*I-m*z,D=m*S-O*I,U=Math.sqrt(p*p+q*q+D*D),T=U>0?p/U:0,M=U>0?q/U:0,N=U>0?D/U:0,$=r?t.waterSidePositions:t.sidePositions,ge=r?t.waterSideNormals:t.sideNormals,ze=r?t.waterSideUvs:t.sideUvs,ce=r?null:t.sideSkyLight,de=r?t.waterSideIndices:t.sideIndices,j=r?t.waterSideVertexOffset:t.sideVertexOffset;$.push(L,y,b,P,W,C,J,K,i,E,G,Y),ge.push(T,M,N,T,M,N,T,M,N,T,M,N),ze.push(0,0,1,0,1,1,0,1),ce&&ce.push(1,1,1,1),de.push(j,j+1,j+2),de.push(j,j+2,j+3),r?t.waterSideVertexOffset+=4:t.sideVertexOffset+=4}}for(const[a]of X){if(Q.has(a))continue;const g=Z.get(a);if(R){const l=g.normalizedCenter;if(l.x*R.x+l.y*R.y+l.z*R.z<se)continue}const s=H.get(a);if(!s||!s.isWater)continue;const n=g.normalizedVertices,r=g.edgeNeighborIdx,c=n.length,e=te.get(a)??0,f=F[e];for(let l=0;l<c;l++){const t=r[l];if(t<0||!Q.has(t))continue;const d=H.get(t);if(!d)continue;const u=d.terrainRadius,o=re;if(u>=o)continue;const x=(l+1)%c,h=n[l],V=n[x],v=h.x*u,L=h.y*u,y=h.z*u,b=V.x*u,P=V.y*u,W=V.z*u,C=h.x*o,E=h.y*o,G=h.z*o,Y=V.x*o,J=V.y*o,K=V.z*o,i=b-v,m=P-L,O=W-y,k=C-v,I=E-L,S=G-y,z=m*S-O*I,p=O*k-i*S,q=i*I-m*k,D=Math.sqrt(z*z+p*p+q*q),U=D>0?z/D:0,T=D>0?p/D:0,M=D>0?q/D:0,N=f.waterSideVertexOffset;f.waterSidePositions.push(v,L,y,b,P,W,Y,J,K,C,E,G),f.waterSideNormals.push(U,T,M,U,T,M,U,T,M,U,T,M),f.waterSideUvs.push(0,0,1,0,1,1,0,1),f.waterSideIndices.push(N,N+1,N+2),f.waterSideIndices.push(N,N+2,N+3),f.waterSideVertexOffset+=4}}const he={type:"lodGeometryResult",chunkGeometries:F};self.postMessage(he)}}})();
//# sourceMappingURL=lodGeometryWorker-CronvbVN.js.map
